require(['bowser', 'underscore', 'backbone', 'semver', 'react', 'react-dom', 'html-react-parser', 'libraries/chart.min', 'libraries/canvas-helper', 'libraries/async.min', 'libraries/xapiwrapper.min', 'libraries/url-polyfill.min'], (function (Bowser, _$1, Backbone$1, semver, React, ReactDOM, HTMLReactParser, Chart, canvasHelper, Async, xapiwrapper_min, urlPolyfill_min) {

  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

  var Bowser__default = /*#__PURE__*/_interopDefaultLegacy(Bowser);
  var ___default = /*#__PURE__*/_interopDefaultLegacy(_$1);
  var Backbone__default = /*#__PURE__*/_interopDefaultLegacy(Backbone$1);
  var semver__default = /*#__PURE__*/_interopDefaultLegacy(semver);
  var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
  var ReactDOM__default = /*#__PURE__*/_interopDefaultLegacy(ReactDOM);
  var HTMLReactParser__default = /*#__PURE__*/_interopDefaultLegacy(HTMLReactParser);
  var Chart__default = /*#__PURE__*/_interopDefaultLegacy(Chart);
  var Async__default = /*#__PURE__*/_interopDefaultLegacy(Async);

  class Wait extends Backbone.Controller {
    initialize() {
      this._waitCount = 0;
      this._callbackHandle = null;
      this.being = this.begin.bind(this);
      this.end = this.end.bind(this);
    }

    isWaiting() {
      return this._waitCount !== 0;
    }

    begin() {
      if (!this.isWaiting()) this.trigger('wait');
      this._waitCount++;

      if (this._callbackHandle) {
        clearTimeout(this._callbackHandle);
        this._callbackHandle = null;
      }

      return this;
    }

    end() {
      if (!this.isWaiting()) return this;
      this._waitCount--;
      if (this.isWaiting() || this._callbackHandle) return this;
      this._callbackHandle = setTimeout(function () {
        this._callbackHandle = null;
        this.trigger('ready');
      }.bind(this), 0);
      return this;
    }

    queue(callback) {
      if (!callback) {
        this.begin();
        return new Promise(resolve => {
          this.once('ready', resolve);
          this.end();
        });
      }

      this.begin();
      this.once('ready', callback);
      this.end();
      return this;
    }

    for(callback) {
      this.begin();

      _.defer(() => callback(_.once(this.end)));

      return this;
    }

  }

  const wait = new Wait();
  var wait$1 = __AMD("core/js/wait", wait);

  var LockingModel = __AMD("core/js/models/lockingModel", class LockingModel extends Backbone.Model {
    set(attrName, attrVal) {
      let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      const stopProcessing = typeof attrName === 'object' || typeof attrVal !== 'boolean' || !this.isLocking(attrName);
      if (stopProcessing) return super.set(...arguments);
      const isSettingValueForSpecificPlugin = options?.pluginName;

      if (!isSettingValueForSpecificPlugin) {
        console.error('Must supply a pluginName to change a locked attribute');
        options.pluginName = 'compatibility';
      }

      const pluginName = options.pluginName;

      if (this.defaults[attrName] !== undefined) {
        this._lockedAttributes[attrName] = !this.defaults[attrName];
      }

      const lockingValue = this._lockedAttributes[attrName];
      const isAttemptingToLock = lockingValue === attrVal;

      if (isAttemptingToLock) {
        this.setLockState(attrName, true, {
          pluginName: pluginName,
          skipcheck: true
        });
        return super.set(attrName, lockingValue);
      }

      this.setLockState(attrName, false, {
        pluginName: pluginName,
        skipcheck: true
      });
      const totalLockValue = this.getLockCount(attrName, {
        skipcheck: true
      });

      if (totalLockValue === 0) {
        return super.set(attrName, !lockingValue);
      }

      return this;
    }

    setLocking(attrName, defaultLockValue) {
      if (this.isLocking(attrName)) return;
      if (!this._lockedAttributes) this._lockedAttributes = {};
      this._lockedAttributes[attrName] = defaultLockValue;
    }

    unsetLocking(attrName) {
      if (!this.isLocking(attrName)) return;
      if (!this._lockedAttributes) return;
      delete this._lockedAttributes[attrName];
      delete this._lockedAttributesValues[attrName];

      if (Object.keys(this._lockedAttributes).length === 0) {
        delete this._lockedAttributes;
        delete this._lockedAttributesValues;
      }
    }

    isLocking(attrName) {
      const isCheckingGeneralLockingState = attrName === undefined;
      const isUsingLockedAttributes = Boolean(this.lockedAttributes || this._lockedAttributes);

      if (isCheckingGeneralLockingState) {
        return isUsingLockedAttributes;
      }

      if (!isUsingLockedAttributes) return false;

      if (!this._lockedAttributes) {
        this._lockedAttributes = _.result(this, 'lockedAttributes');
      }

      const isAttributeALockingAttribute = this._lockedAttributes.hasOwnProperty(attrName);

      if (!isAttributeALockingAttribute) return false;

      if (!this._lockedAttributesValues) {
        this._lockedAttributesValues = {};
      }

      if (!this._lockedAttributesValues[attrName]) {
        this._lockedAttributesValues[attrName] = {};
      }

      return true;
    }

    isLocked(attrName, options) {
      const shouldSkipCheck = options?.skipcheck;

      if (!shouldSkipCheck) {
        const stopProcessing = !this.isLocking(attrName);
        if (stopProcessing) return;
      }

      return this.getLockCount(attrName) > 0;
    }

    getLockCount(attrName, options) {
      const shouldSkipCheck = options?.skipcheck;

      if (!shouldSkipCheck) {
        const stopProcessing = !this.isLocking(attrName);
        if (stopProcessing) return;
      }

      const isGettingValueForSpecificPlugin = options?.pluginName;

      if (isGettingValueForSpecificPlugin) {
        return this._lockedAttributesValues[attrName][options.pluginName] ? 1 : 0;
      }

      const lockingAttributeValues = Object.values(this._lockedAttributesValues[attrName]);
      const lockingAttributeValuesSum = lockingAttributeValues.reduce((sum, value) => sum + (value ? 1 : 0), 0);
      return lockingAttributeValuesSum;
    }

    setLockState(attrName, value, options) {
      const shouldSkipCheck = options?.skipcheck;

      if (!shouldSkipCheck) {
        const stopProcessing = !this.isLocking(attrName);
        if (stopProcessing) return this;
      }

      const isSettingValueForSpecificPlugin = options?.pluginName;

      if (!isSettingValueForSpecificPlugin) {
        console.error('Must supply a pluginName to set a locked attribute lock value');
        options.pluginName = 'compatibility';
      }

      if (value) {
        this._lockedAttributesValues[attrName][options.pluginName] = value;
      } else {
        delete this._lockedAttributesValues[attrName][options.pluginName];
      }

      return this;
    }

  });

  class AdaptSingleton extends LockingModel {
    initialize() {
      this.loadScript = window.__loadScript;
    }

    defaults() {
      return {
        _canScroll: true,
        _outstandingCompletionChecks: 0,
        _pluginWaitCount: 0,
        _isStarted: false,
        _shouldDestroyContentObjects: true
      };
    }

    lockedAttributes() {
      return {
        _canScroll: false
      };
    }

    async init() {
      this.addDirection();
      this.disableAnimation();
      this.trigger('adapt:preInitialize');
      await wait$1.queue();
      this.deferUntilCompletionChecked(async () => {
        this.trigger('adapt:start');
        await wait$1.queue();

        if (!Backbone.History.started) {
          Backbone.history.start();
        }

        this.set('_isStarted', true);
        this.trigger('adapt:initialize');
        await wait$1.queue();
      });
    }

    checkingCompletion() {
      const outstandingChecks = this.get('_outstandingCompletionChecks');
      this.set('_outstandingCompletionChecks', outstandingChecks + 1);
    }

    checkedCompletion() {
      const outstandingChecks = this.get('_outstandingCompletionChecks');
      this.set('_outstandingCompletionChecks', outstandingChecks - 1);
    }

    async deferUntilCompletionChecked() {
      let callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : () => {};
      if (this.get('_outstandingCompletionChecks') === 0) return callback();
      return new Promise(resolve => {
        const checkIfAnyChecksOutstanding = (model, outstandingChecks) => {
          if (outstandingChecks !== 0) return;
          this.off('change:_outstandingCompletionChecks', checkIfAnyChecksOutstanding);
          callback();
          resolve();
        };

        this.on('change:_outstandingCompletionChecks', checkIfAnyChecksOutstanding);
      });
    }

    isWaitingForPlugins() {
      this.log.deprecated('Use wait.isWaiting() as Adapt.isWaitingForPlugins() will be removed in the future');
      return wait$1.isWaiting();
    }

    checkPluginsReady() {
      this.log.deprecated('Use wait.isWaiting() as Adapt.checkPluginsReady() will be removed in the future');

      if (this.isWaitingForPlugins()) {
        return;
      }

      this.trigger('plugins:ready');
    }

    parseRelativeString(relativeString) {
      const parts = relativeString.replace(/\s*([+\-=]+\d+){1}/g, '$1').split(/[@ ]/).filter(Boolean);
      const parsed = parts.map(part => {
        let splitIndex = part.search(/[+\-=\d]{1}/);
        if (splitIndex === -1) splitIndex = part.length;
        const symbol = part.slice(splitIndex, splitIndex + 1);
        const type = part.slice(0, splitIndex).replace(/^@/, '');
        let offset = null;
        let inset = null;

        switch (symbol) {
          case '=':
            inset = parseInt(part.slice(splitIndex + 1).trim() || 0);
            break;

          default:
            offset = parseInt(part.slice(splitIndex).trim() || 0);
            break;
        }

        return {
          type,
          offset,
          inset
        };
      });
      return parsed.length === 1 ? parsed[0] : parsed;
    }

    addDirection() {
      const defaultDirection = this.config.get('_defaultDirection');
      $('html').addClass('dir-' + defaultDirection).attr('dir', defaultDirection);
    }

    disableAnimation() {
      const disableAnimationArray = this.config.get('_disableAnimationFor');
      const disableAnimation = this.config.get('_disableAnimation');

      if (disableAnimationArray) {
        for (let i = 0, l = disableAnimationArray.length; i < l; i++) {
          if (!$('html').is(disableAnimationArray[i])) continue;
          this.config.set('_disableAnimation', true);
          $('html').addClass('disable-animation');
          console.log('Animation disabled.');
        }

        return;
      }

      $('html').toggleClass('disable-animation', disableAnimation === true);
    }

    async remove() {
      const currentView = this.parentView;

      if (currentView) {
        currentView.model.setOnChildren({
          _isReady: false,
          _isRendered: false
        });
      }

      this.trigger('preRemove', currentView);
      await wait$1.queue();

      if (currentView && this.get('_shouldDestroyContentObjects')) {
        currentView.destroy();
      }

      this.trigger('remove', currentView);

      _.defer(this.trigger.bind(this), 'postRemove', currentView);
    }

    get a11y() {}

    get componentStore() {}

    get data() {}

    get device() {}

    get drawer() {}

    get location() {}

    get notify() {}

    get offlineStorage() {}

    get router() {}

    get scrolling() {}

    get startController() {}

    get store() {}

    get tracking() {}

    get wait() {}

    async navigateToElement() {}

    async scrollTo() {}

    register(name, object) {}

    getViewName() {}

    getViewClass() {}

    getModelName() {}

    getModelClass() {}

    findById() {}

    findViewByModelId() {}

    findByTrackingPosition() {}

  }

  const Adapt = new AdaptSingleton();
  var Adapt$1 = __AMD("core/js/adapt", Adapt);

  class OfflineStorage extends Backbone.Controller {
    initialize(handler) {
      this.ready = true;
      this._handler = undefined;

      if (!handler) {
        return;
      }

      this.ready = false;
      this._handler = handler;
    }

    hasHandler() {
      return this._handler !== undefined;
    }

    save() {
      Adapt$1.trigger('tracking:save');
      return this._handler?.save?.(...arguments);
    }

    serialize(value) {
      if (this._handler?.serialize) {
        return this._handler.serialize(...arguments);
      }

      return JSON.stringify(value);
    }

    deserialize(value) {
      if (this._handler?.deserialize) {
        return this._handler.deserialize(...arguments);
      }

      return JSON.parse(value);
    }

    set(name, value) {
      if (this._handler?.set) {
        return this._handler.set(...arguments);
      }

      this[name] = value;
    }

    get(name) {
      if (this._handler?.get) {
        return this._handler.get(...arguments);
      }

      return this[name];
    }

    clear() {
      if (this._handler?.clear) {
        return this._handler.clear(...arguments);
      }

      return false;
    }

    setReadyStatus() {
      this.ready = true;
      Adapt$1.trigger('offlineStorage:ready');
    }

  }

  const offlineStorage$2 = new OfflineStorage();
  var offlineStorage$3 = __AMD("core/js/offlineStorage", offlineStorage$2);

  class Device extends Backbone.Controller {
    initialize() {
      ___default["default"].bindAll(this, 'onWindowResize', 'calculateResize');

      this.bowser = Bowser__default["default"].parse(window.navigator.userAgent);
      this.$html = $('html');
      this.$window = $(window);
      this.touch = Modernizr.touchevents;
      this.screenWidth = this.getScreenWidth();
      this.screenHeight = this.getScreenHeight();
      this.setViewportHeight();
      this.browser = (this.bowser.browser.name || '').toLowerCase();
      this.version = (this.bowser.browser.version || '').toLowerCase();
      this.OS = this.getOperatingSystem().toLowerCase();
      this.osVersion = this.bowser.os.version || '';
      this.renderingEngine = this.getRenderingEngine();
      this.listenTo(Adapt$1, {
        'configModel:dataLoaded': this.onConfigDataLoaded
      });
      const browser = this.browser.toLowerCase();
      let browserString = browser.replace(/msie|internet explorer/, 'ie');
      browserString += ` version-${this.version} OS-${this.OS} ${this.getAppleDeviceType()}`;
      browserString += browserString.replace('.', '-').toLowerCase();
      browserString += ` ${browserString.replace(/\./g, '-').toLowerCase()}`;
      browserString += ` pixel-density-${this.pixelDensity()}`;
      this.$html.addClass(browserString);
    }

    get orientation() {
      return this.screenWidth >= this.screenHeight ? 'landscape' : 'portrait';
    }

    get aspectRatio() {
      return this.screenWidth / this.screenHeight;
    }

    onConfigDataLoaded() {
      this.screenSize = this.checkScreenSize();
      this.$html.addClass('size-' + this.screenSize);

      if (this.orientation) {
        this.$html.addClass('orientation-' + this.orientation);
      }

      this.$window.on('resize orientationchange', this.onWindowResize);
    }

    checkScreenSize() {
      const screenSizeConfig = Adapt$1.config.get('screenSize');
      let screenSize;
      const screensizeEmThreshold = 300;
      const baseFontSize = 16;
      const mediumEmBreakpoint = screenSizeConfig.medium > screensizeEmThreshold ? screenSizeConfig.medium / baseFontSize : screenSizeConfig.medium;
      const smallEmBreakpoint = screenSizeConfig.small > screensizeEmThreshold ? screenSizeConfig.small / baseFontSize : screenSizeConfig.small;
      const fontSize = parseFloat($('html').css('font-size'));
      const screenSizeEmWidth = window.innerWidth / fontSize;

      if (screenSizeEmWidth >= mediumEmBreakpoint) {
        screenSize = 'large';
      } else if (screenSizeEmWidth >= smallEmBreakpoint) {
        screenSize = 'medium';
      } else {
        screenSize = 'small';
      }

      return screenSize;
    }

    getScreenWidth() {
      return this.isAppleDevice() ? this.getAppleScreenWidth() : window.innerWidth || this.$window.width();
    }

    getScreenHeight() {
      return this.isAppleDevice() ? this.getAppleScreenHeight() : window.innerHeight || this.$window.height();
    }

    setViewportHeight() {
      document.documentElement.style.setProperty('--adapt-viewport-height', `${window.innerHeight}px`);
    }

    getOperatingSystem() {
      let os = this.bowser.os.name.toLowerCase() || '';

      if (os === '') {
        const platform = navigator.platform.toLowerCase();
        const match = platform.match(/win|mac|linux/);
        if (match) os = match[0];
        if (os === 'win') os = 'windows';
        if (!os) os = '';
      }

      if (!os) os = 'platformunknown';
      return os;
    }

    getRenderingEngine() {
      return this.bowser.engine.name || '';
    }

    onWindowResize() {
      if (this.hasWindowResized) return;
      requestAnimationFrame(this.calculateResize);
      this.hasWindowResized = true;
    }

    calculateResize() {
      this.hasWindowResized = false;
      const previousWidth = this.screenWidth;
      const previousHeight = this.screenHeight;
      this.screenWidth = this.getScreenWidth();
      this.screenHeight = this.getScreenHeight();
      this.setViewportHeight();

      if (previousWidth === this.screenWidth && previousHeight === this.screenHeight) {
        return;
      }

      if (this.orientation) {
        this.$html.toggleClass('orientation-landscape', this.orientation === 'landscape');
        this.$html.toggleClass('orientation-portrait', this.orientation === 'portrait');
      }

      const newScreenSize = this.checkScreenSize();

      if (newScreenSize !== this.screenSize) {
        this.screenSize = newScreenSize;
        this.$html.toggleClass('size-small', this.screenSize === 'small');
        this.$html.toggleClass('size-medium', this.screenSize === 'medium');
        this.$html.toggleClass('size-large', this.screenSize === 'large');
        Adapt$1.trigger('device:changed', this.screenSize);
      }

      Adapt$1.trigger('device:preResize device:resize device:postResize', this.screenWidth);
    }

    isAppleDevice() {
      return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream || navigator.userAgent.match(/Mac/) && navigator?.maxTouchPoints > 2;
    }

    get shouldReportInvertedAppleScreenSize() {
      const windowRatio = window.innerWidth / window.innerHeight;
      const screenRatio = window.screen.width / window.screen.height;
      const isWindowPortrait = windowRatio < 1;
      const isScreenPortrait = screenRatio < 1;
      const isDeviceBadlyReportingScreenOrientation = isWindowPortrait !== isScreenPortrait;
      return isDeviceBadlyReportingScreenOrientation;
    }

    getAppleScreenWidth() {
      return this.shouldReportInvertedAppleScreenSize ? window.screen.height : window.screen.width;
    }

    getAppleScreenHeight() {
      return this.shouldReportInvertedAppleScreenSize ? window.screen.width : window.screen.height;
    }

    getAppleDeviceType() {
      const platformType = this.bowser.platform.type?.toLowerCase() || '';
      const browserName = this.bowser.browser.name?.toLowerCase() || '';
      const isIPhone = platformType === 'mobile' && browserName === 'safari';
      const isIPad = platformType === 'tablet' && browserName === 'safari';
      if (isIPhone) return 'iphone';
      if (isIPad) return 'ipad';
      return '';
    }

    pixelDensity() {
      const pixelDensity = window.devicePixelRatio || 1;

      if (pixelDensity >= 3) {
        return 'ultra-high';
      } else if (pixelDensity >= 2) {
        return 'high';
      } else if (pixelDensity >= 1.5) {
        return 'medium';
      } else {
        return 'low';
      }
    }

  }

  const device = new Device();
  var device$1 = __AMD("core/js/device", device);

  class Location extends Backbone__default["default"].Controller {
    initialize() {
      this._previousId = null;
      this._previousContentType = null;
      this._previousModel = null;
      this._previousClasses = null;
      this._lastVisitedType = null;
      this._lastVisitedMenu = null;
      this._lastVisitedPage = null;
      this._currentId = null;
      this._currentModel = null;
      this._currentLocation = null;
      this._contentType = null;
    }

  }

  const location$1 = new Location();
  var location$2 = __AMD("core/js/location", location$1);

  var BrowserFocus = __AMD("core/js/a11y/browserFocus", class BrowserFocus extends Backbone.Controller {
    initialize(_ref) {
      let {
        a11y
      } = _ref;
      this.a11y = a11y;
      this._onBlur = this._onBlur.bind(this);
      this._onClick = this._onClick.bind(this);
      this.$body = $('body');
      this.listenTo(Adapt$1, {
        'accessibility:ready': this._attachEventListeners
      });
    }

    _attachEventListeners() {
      this.$body.on('blur', '*', this._onBlur).on('blur', this._onBlur);
      this.$body[0].addEventListener('click', this._onClick, true);
    }

    _onBlur(event) {
      const config = this.a11y.config;

      if (!config._isEnabled || !config._options._isFocusNextOnDisabled) {
        return;
      }

      const $element = $(event.target);

      if ($element.is('[data-a11y-force-focus]')) {
        $element.removeAttr('tabindex data-a11y-force-focus');
      }

      if (event.target !== event.currentTarget) {
        return;
      }

      if (!$element.is('[disabled]') && $element.css('display') !== 'none' && $element.css('visibility') !== 'hidden') {
        return;
      }

      this.a11y.focusNext($element);
    }

    _onClick(event) {
      const $element = $(event.target);
      const isAriaDisabled = $element.closest('[aria-disabled=true]').length === 1;

      if (isAriaDisabled) {
        event.preventDefault();
        event.stopImmediatePropagation();
      }

      const config = this.a11y.config;

      if (!config._isEnabled || !config._options._isFocusOnClickEnabled) {
        return;
      }

      const $stack = $([...$element.toArray(), ...$element.parents().toArray()]);
      const $focusable = $stack.filter(config._options._tabbableElements);

      if (!$focusable.length) {
        return;
      }

      $focusable[0].focus();
    }

  });

  var FocusOptions = __AMD("core/js/a11y/focusOptions", class FocusOptions {
    constructor() {
      let {
        preventScroll = false,
        defer = false
      } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.preventScroll = preventScroll;
      this.defer = defer;
    }

  });

  var KeyboardFocusOutline = __AMD("core/js/a11y/keyboardFocusOutline", class KeyboardFocusOutline extends Backbone.Controller {
    initialize(_ref) {
      let {
        a11y
      } = _ref;
      this.a11y = a11y;
      this._onKeyDown = this._onKeyDown.bind(this);
      this.$html = $('html');
      this.showOnKeys = {
        9: true,
        13: true,
        32: true,
        37: true,
        38: true,
        39: true,
        40: true
      };
      this.listenTo(Adapt$1, {
        'accessibility:ready': this._attachEventListeners
      });
    }

    _attachEventListeners() {
      document.addEventListener('keydown', this._onKeyDown);

      this._start();
    }

    _start() {
      const config = this.a11y.config;

      if (config._options._isFocusOutlineDisabled) {
        this.$html.addClass('a11y-disable-focusoutline');
        return;
      }

      if (!config._isEnabled || !config._options._isFocusOutlineKeyboardOnlyEnabled) {
        return;
      }

      this.$html.addClass('a11y-disable-focusoutline');
    }

    _onKeyDown(event) {
      const config = this.a11y.config;

      if (config._options._isFocusOutlineDisabled) {
        this.$html.addClass('a11y-disable-focusoutline');
        return;
      }

      if (!config._isEnabled || !config._options._isFocusOutlineKeyboardOnlyEnabled || !this.showOnKeys[event.keyCode]) {
        return;
      }

      const $element = $(event.target);

      if (!$element.is(config._options._tabbableElements) || $element.is(config._options._focusOutlineKeyboardOnlyIgnore)) {
        return;
      }

      this.$html.removeClass('a11y-disable-focusoutline');
    }

  });

  const LOG_LEVEL = ENUM(['DEBUG', 'INFO', 'WARN', 'ERROR', 'FATAL']);
  var LOG_LEVEL$1 = __AMD("core/js/enums/logLevelEnum", LOG_LEVEL);

  class Logging extends Backbone.Controller {
    initialize() {
      this._config = {
        _isEnabled: true,
        _level: LOG_LEVEL$1.INFO.asLowerCase,
        _console: true,
        _warnFirstOnly: true
      };
      this._warned = {};
      this.listenToOnce(Adapt$1, 'configModel:dataLoaded', this.onLoadConfigData);
    }

    onLoadConfigData() {
      this.loadConfig();
      this.debug('Logging config loaded');
      this.trigger('log:ready');
    }

    loadConfig() {
      if (Adapt$1.config.has('_logging')) {
        this._config = Adapt$1.config.get('_logging');
      }

      this.checkQueryStringOverride();
    }

    checkQueryStringOverride() {
      const matches = window.location.search.match(/[?&]loglevel=([a-z]*)/i);
      if (!matches || matches.length < 2) return;
      const override = LOG_LEVEL$1(matches[1].toUpperCase());
      if (!override) return;
      this._config._level = override.asLowerCase;
      this.debug('Loglevel override in query string:', this._config._level);
    }

    debug() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      this._log(LOG_LEVEL$1.DEBUG, args);
    }

    info() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      this._log(LOG_LEVEL$1.INFO, args);
    }

    warn() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      this._log(LOG_LEVEL$1.WARN, args);
    }

    error() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }

      this._log(LOG_LEVEL$1.ERROR, args);
    }

    fatal() {
      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        args[_key5] = arguments[_key5];
      }

      this._log(LOG_LEVEL$1.FATAL, args);
    }

    removed() {
      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        args[_key6] = arguments[_key6];
      }

      args = ['REMOVED'].concat(args);
      this.warnOnce(...args);
    }

    deprecated() {
      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
        args[_key7] = arguments[_key7];
      }

      args = ['DEPRECATED'].concat(args);
      this.warnOnce(...args);
    }

    warnOnce() {
      for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
        args[_key8] = arguments[_key8];
      }

      if (this._hasWarned(args)) {
        return;
      }

      this._log(LOG_LEVEL$1.WARN, args);
    }

    _log(level, data) {
      const isEnabled = this._config._isEnabled;
      if (!isEnabled) return;
      const configLevel = LOG_LEVEL$1(this._config._level.toUpperCase());
      const isLogLevelAllowed = level >= configLevel;
      if (!isLogLevelAllowed) return;

      this._logToConsole(level, data);

      this.trigger('log', level, data);
      this.trigger('log:' + level.asLowerCase, level, data);
    }

    _logToConsole(level, data) {
      const shouldLogToConsole = this._config._console;
      if (!shouldLogToConsole) return;
      const log = [level.asUpperCase + ':'];
      data && log.push(...data);

      if (console[level.asLowerCase]) {
        console[level.asLowerCase](...log);
      } else {
        console.log(...log);
      }
    }

    _hasWarned(args) {
      if (!this._config._warnFirstOnly) {
        return false;
      }

      const hash = args.map(String).join(':');

      if (this._warned[hash]) {
        return true;
      }

      this._warned[hash] = true;
      return false;
    }

  }

  const logging = new Logging();
  var logging$1 = __AMD("core/js/logging", logging);

  var Log = __AMD("core/js/a11y/log", class Log extends Backbone.Controller {
    initialize(_ref) {
      let {
        a11y
      } = _ref;
      this.a11y = a11y;
      this._warned = {};
    }

    _hasWarned(args) {
      const config = this.a11y.config;

      if (!config._options._warnFirstOnly) {
        return false;
      }

      const hash = args.map(String).join(':');

      if (this._warned[hash]) {
        return true;
      }

      this._warned[hash] = true;
      return false;
    }

    _canWarn() {
      const config = this.a11y.config;
      return Boolean(config._options._warn);
    }

    removed() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      if (!this._canWarn) {
        return;
      }

      args = ['A11Y'].concat(args);

      if (this._hasWarned(args)) {
        return;
      }

      logging$1.removed(...args);
      return this;
    }

    deprecated() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      if (!this._canWarn) {
        return;
      }

      args = ['A11Y'].concat(args);

      if (this._hasWarned(args)) {
        return;
      }

      logging$1.deprecated(...args);
      return this;
    }

  });

  var Scroll = __AMD("core/js/a11y/scroll", class Scroll extends Backbone.Controller {
    initialize() {
      this._onTouchStart = this._onTouchStart.bind(this);
      this._onTouchEnd = this._onTouchEnd.bind(this);
      this._onScrollEvent = this._onScrollEvent.bind(this);
      this._onKeyDown = this._onKeyDown.bind(this);
      this._scrollDisabledElements = $([]);
      this.$window = $(window);
      this.$body = $('body');
      this._preventScrollOnKeys = {
        37: true,
        38: true,
        39: true,
        40: true
      };
      this._ignoreKeysOnElementsMatching = 'textarea, input, select';
      this._isRunning = false;
      this._touchStartEventObject = null;
    }

    disable($elements) {
      $elements = $($elements);
      this._scrollDisabledElements = this._scrollDisabledElements.add($elements);

      this._checkRunning();

      return this;
    }

    enable($elements) {
      $elements = $($elements);

      if (!$elements.length) {
        this.clear();
        return this;
      }

      this._scrollDisabledElements = this._scrollDisabledElements.not($elements);

      this._checkRunning();

      return this;
    }

    clear() {
      this._scrollDisabledElements = $([]);

      this._checkRunning();

      return this;
    }

    _checkRunning() {
      if (!this._scrollDisabledElements.length) {
        this._stop();

        return;
      }

      this._start();
    }

    _start() {
      if (this._isRunning) {
        return;
      }

      this._isRunning = true;
      window.addEventListener('touchstart', this._onTouchStart);
      window.addEventListener('touchend', this._onTouchEnd);
      window.addEventListener('touchmove', this._onScrollEvent, {
        passive: false
      });
      window.addEventListener('wheel', this._onScrollEvent, {
        passive: false
      });
      document.addEventListener('wheel', this._onScrollEvent, {
        passive: false
      });
      document.addEventListener('keydown', this._onKeyDown);
    }

    _onTouchStart(event) {
      event = $.event.fix(event);
      this._touchStartEventObject = event;
      return true;
    }

    _onTouchEnd() {
      this._touchStartEventObject = null;
      return true;
    }

    _onScrollEvent(event) {
      event = $.event.fix(event);
      return this._preventScroll(event);
    }

    _onKeyDown(event) {
      event = $.event.fix(event);

      if (!this._preventScrollOnKeys[event.keyCode]) {
        return;
      }

      const $target = $(event.target);

      if ($target.is(this._ignoreKeysOnElementsMatching)) {
        return;
      }

      return this._preventScroll(event);
    }

    _preventScroll(event) {
      const isGesture = event.touches?.length > 1;

      if (isGesture) {
        return;
      }

      const $target = $(event.target);

      if (this._scrollDisabledElements.length) {
        const scrollingParent = this._getScrollingParent(event, $target);

        if (scrollingParent.filter(this._scrollDisabledElements).length === 0) {
          this.$window.scroll();
          return;
        }
      }

      event.preventDefault();
      return false;
    }

    _getScrollingParent(event, $target) {
      const isTouchEvent = event.type === 'touchmove';
      const hasTouchStartEvent = this._touchStartEventObject?.originalEvent;

      if (isTouchEvent && !hasTouchStartEvent) {
        return $target;
      }

      const directionY = this._getScrollDirection(event);

      if (directionY === 'none') {
        return this.$body;
      }

      const parents = [$target[0], ...$target.parents()];

      for (let i = 0, l = parents.length; i < l; i++) {
        const $parent = $(parents[i]);

        if ($parent.is('body')) {
          return this.$body;
        }

        if (!this._isScrollable($parent)) {
          continue;
        }

        if (!this._isScrolling($parent, directionY)) {
          continue;
        }

        return $parent;
      }

      return this.$body;
    }

    _isScrollable($target) {
      const scrollType = $target.css('overflow-y');

      if (scrollType !== 'auto' && scrollType !== 'scroll') {
        return false;
      }

      const pointerEvents = $target.css('pointer-events');

      if (pointerEvents === 'none') {
        return false;
      }

      return true;
    }

    _isScrolling($target, directionY) {
      const scrollTop = Math.ceil($target.scrollTop());
      const innerHeight = $target.outerHeight();
      const scrollHeight = $target[0].scrollHeight;
      let hasScrollingSpace = false;

      switch (directionY) {
        case 'down':
          hasScrollingSpace = scrollTop + innerHeight < scrollHeight;

          if (hasScrollingSpace) {
            return true;
          }

          break;

        case 'up':
          hasScrollingSpace = scrollTop > 0;

          if (hasScrollingSpace) {
            return true;
          }

          break;
      }

      return false;
    }

    _getScrollDirection(event) {
      const deltaY = this._getScrollDelta(event);

      if (deltaY === 0) {
        return 'none';
      }

      return deltaY > 0 ? 'up' : 'down';
    }

    _getScrollDelta(event) {
      let deltaY = 0;
      const isTouchEvent = event.type === 'touchmove';
      const originalEvent = event.originalEvent;

      if (isTouchEvent) {
        const startOriginalEvent = this._touchStartEventObject.originalEvent;
        let currentY = originalEvent.pageY;
        let previousY = startOriginalEvent.pageY;

        if (currentY === 0 || currentY === previousY) {
          currentY = originalEvent.touches[0].pageY;
          previousY = startOriginalEvent.touches[0].pageY;
        }

        deltaY = currentY - previousY;
      } else {
        const hasDeltaY = originalEvent.wheelDeltaY || originalEvent.deltaY !== undefined;

        if (hasDeltaY) {
          deltaY = -originalEvent.deltaY;
        } else {
          deltaY = originalEvent.wheelDelta || 0;
        }
      }

      return deltaY;
    }

    _stop() {
      if (!this._isRunning) {
        return;
      }

      this._isRunning = false;
      window.removeEventListener('touchstart', this._onTouchStart);
      window.removeEventListener('touchend', this._onTouchEnd);
      window.removeEventListener('touchmove', this._onScrollEvent, {
        passive: false
      });
      window.removeEventListener('wheel', this._onScrollEvent, {
        passive: false
      });
      document.removeEventListener('wheel', this._onScrollEvent, {
        passive: false
      });
      document.removeEventListener('keydown', this._onKeyDown);
    }

  });

  var WrapFocus = __AMD("core/js/a11y/wrapFocus", class WrapFocus extends Backbone.Controller {
    initialize(_ref) {
      let {
        a11y
      } = _ref;
      this.a11y = a11y;

      _.bindAll(this, '_onWrapAround');

      this.listenTo(Adapt$1, {
        'accessibility:ready': this._attachEventListeners
      });
    }

    _attachEventListeners() {
      const config = this.a11y.config;
      $('body').on('click focus', config._options._focusguard, this._onWrapAround);
    }

    _onWrapAround(event) {
      const config = this.a11y.config;

      if (!config._isEnabled || !config._options._isPopupWrapFocusEnabled) {
        return;
      }

      event.preventDefault();
      event.stopPropagation();
      this.a11y.focusFirst('body', {
        defer: false
      });
    }

  });

  var Popup = __AMD("core/js/a11y/popup", class Popup extends Backbone.Controller {
    initialize(_ref) {
      let {
        a11y
      } = _ref;
      this.a11y = a11y;
      this._floorStack = [$('body')];
      this._focusStack = [];
      this._tabIndexes = {};
      this._ariaHiddens = {};
      this._elementUIDIndex = 0;
      this.listenTo(Adapt$1, {
        'popup:opened'($element, ignoreInternalTrigger) {
          if (ignoreInternalTrigger) {
            return;
          }

          this.a11y.log.deprecated('Adapt.trigger("popup:opened", $element) is replaced with a11y.popupOpened($element);');
          this.opened($element, true);
        },

        'popup:closed'($target, ignoreInternalTrigger) {
          if (ignoreInternalTrigger) {
            return;
          }

          this.a11y.log.deprecated('Adapt.trigger("popup:closed", $target) is replaced with a11y.popupClosed($target);');
          this.closed($target, true);
        }

      });
    }

    opened($popupElement, silent) {
      $popupElement = $popupElement || $(document.activeElement);

      this._addPopupLayer($popupElement);

      if (!silent) {
        Adapt$1.trigger('popup:opened', $popupElement, true);
      }

      return this;
    }

    _addPopupLayer($popupElement) {
      $popupElement = $($popupElement);
      const config = this.a11y.config;

      if (!config._isEnabled || !config._options._isPopupManagementEnabled || $popupElement.length === 0) {
        return $popupElement;
      }

      this._floorStack.push($popupElement);

      this._focusStack.push($(document.activeElement));

      let $elements = $(config._options._tabbableElements).filter(config._options._tabbableElementsExcludes);
      const $branch = $popupElement.add($popupElement.parents());
      const $siblings = $branch.siblings().filter(config._options._tabbableElementsExcludes);
      $elements = $elements.add($siblings);
      $elements.each((index, item) => {
        const $item = $(item);

        if (typeof item.a11y_uid === 'undefined') {
          item.a11y_uid = 'UID' + ++this._elementUIDIndex;
        }

        const elementUID = item.a11y_uid;

        if (this._tabIndexes[elementUID] === undefined) {
          this._tabIndexes[elementUID] = [];
        }

        if (this._ariaHiddens[elementUID] === undefined) {
          this._ariaHiddens[elementUID] = [];
        }

        const tabindex = $item.attr('tabindex');
        const ariaHidden = $item.attr('aria-hidden');

        this._tabIndexes[elementUID].push(tabindex === undefined ? '' : tabindex);

        this._ariaHiddens[elementUID].push(ariaHidden === undefined ? '' : ariaHidden);

        if (config._options._isPopupTabIndexManagementEnabled) {
          $item.attr('tabindex', -1);
        }

        if (config._options._isPopupAriaHiddenManagementEnabled) {
          $item.attr('aria-hidden', true);
        }
      });
      const $items = $popupElement.find(config._options._tabbableElements).filter(config._options._tabbableElementsExcludes);

      if (config._options._isPopupTabIndexManagementEnabled) {
        $items.attr('tabindex', 0);
      }

      if (config._options._isPopupAriaHiddenManagementEnabled) {
        $items.removeAttr('aria-hidden').removeClass('aria-hidden').parents(config._options._ariaHiddenExcludes).removeAttr('aria-hidden').removeClass('aria-hidden');
      }
    }

    closed($focusElement, silent) {
      const $previousFocusElement = this._removeLastPopupLayer();

      $focusElement = $focusElement || $previousFocusElement || $('body');

      if (!silent) {
        Adapt$1.trigger('popup:closed', $focusElement, true);
      }

      this.a11y.focusFirst($($focusElement), {
        preventScroll: true
      });
      return this;
    }

    _removeLastPopupLayer() {
      const config = this.a11y.config;

      if (!config._isEnabled || !config._options._isPopupManagementEnabled) {
        return $(document.activeElement);
      }

      if (this._floorStack.length <= 1) {
        return;
      }

      this._floorStack.pop();

      $(config._options._tabbableElements).filter(config._options._tabbableElementsExcludes).each((index, item) => {
        const $item = $(item);
        let previousTabIndex = '';
        let previousAriaHidden = '';

        if (typeof item.a11y_uid === 'undefined') {
          item.a11y_uid = 'UID' + ++this._elementUIDIndex;
        }

        const elementUID = item.a11y_uid;

        if (this._tabIndexes[elementUID]?.length) {
          previousTabIndex = this._tabIndexes[elementUID].pop();
          previousAriaHidden = this._ariaHiddens[elementUID].pop();
        }

        if (this._tabIndexes[elementUID]?.length) {
          delete this._tabIndexes[elementUID];
          delete this._ariaHiddens[elementUID];
        }

        if (config._options._isPopupTabIndexManagementEnabled) {
          if (previousTabIndex === '') {
            $item.removeAttr('tabindex');
          } else {
            $item.attr({
              tabindex: previousTabIndex
            });
          }
        }

        if (config._options._isPopupAriaHiddenManagementEnabled) {
          if (previousAriaHidden === '') {
            $item.removeAttr('aria-hidden');
          } else {
            $item.attr({
              'aria-hidden': previousAriaHidden
            });
          }
        }
      });
      return this._focusStack.pop();
    }

    setCloseTo($focusElement) {
      const $original = this._focusStack.pop();

      this._focusStack.push($focusElement);

      return $original;
    }

  });

  var defaultAriaLevels = __AMD("core/js/enums/defaultAriaLevels", {
    _menu: 1,
    _menuGroup: 2,
    _menuItem: 2,
    _page: 1,
    _article: 2,
    _block: 3,
    _component: 4,
    _componentItem: 5,
    _notify: 1
  });

  var deprecated = __AMD("core/js/a11y/deprecated", function (a11y) {
    Object.assign($.fn, {
      isFixedPostion() {
        a11y.log.removed('$("..").isFixedPostion was unneeded and has been removed, let us know if you need it back.');
        return false;
      },

      a11y_aria_label() {
        a11y.log.removed('$("..").a11y_aria_label was incorrect behaviour.');
        return this;
      },

      limitedScrollTo() {
        a11y.log.removed('$.limitedScrollTo had no impact on the screen reader cursor.');
        return this;
      },

      a11y_text() {
        a11y.log.removed('a11y_text is no longer required. https://tink.uk/understanding-screen-reader-interaction-modes/');
        return this;
      },

      a11y_selected() {
        a11y.log.removed('$("..").a11y_selected is removed. Please use aria-live instead.');
        return this;
      },

      a11y_on(isOn) {
        a11y.log.deprecated('$("..").a11y_on, use a11y.findTabbable($element); and a11y.toggleAccessible($elements, isAccessible); instead.');
        const $tabbable = a11y.findTabbable(this);
        a11y.toggleAccessible($tabbable, isOn);
        return this;
      },

      a11y_only() {
        a11y.log.removed('$("..").a11y_only, use a11y.popupOpened($popupElement); instead.');
        return this;
      },

      scrollDisable() {
        if (a11y.config._options._isScrollDisableEnabled === false) {
          return this;
        }

        a11y.log.deprecated('$("..").scrollDisable, use a11y.scrollDisable($elements); instead.');
        a11y.scrollDisable(this);
        return this;
      },

      scrollEnable() {
        if (a11y.config._options._isScrollDisableEnabled === false) {
          return this;
        }

        a11y.log.deprecated('$("..").scrollEnable, use a11y.scrollEnable($elements); instead.');
        a11y.scrollEnable(this);
        return this;
      },

      a11y_popup() {
        a11y.log.deprecated('$("..").a11y_popup, use a11y.popupOpened($popupElement); instead.');
        return a11y.popupOpened(this);
      },

      a11y_cntrl(isOn, withDisabled) {
        a11y.log.deprecated('$("..").a11y_cntrl, use a11y.toggleAccessible($elements, isAccessible); and if needed a11y.toggleEnabled($elements, isEnabled); instead.');
        a11y.toggleAccessible(this, isOn);
        if (withDisabled) a11y.toggleEnabled(this, isOn);
        return this;
      },

      a11y_cntrl_enabled(isOn) {
        a11y.log.deprecated('$("..").a11y_cntrl_enabled, use a11y.toggleAccessibleEnabled($elements, isAccessibleEnabled); instead.');
        a11y.toggleAccessibleEnabled(this, isOn);
        return this;
      },

      isReadable() {
        a11y.log.deprecated('$("..").isReadable, use a11y.isReadable($element); instead.');
        return a11y.isReadable(this);
      },

      findForward(selector) {
        a11y.log.removed('$("..").findForward has been removed as the use cases are very small, let us know if you need it back.');
        return a11y._findFirstForward(this, selector);
      },

      findWalk(selector) {
        a11y.log.removed('$("..").findWalk has been removed as the use cases are very small, let us know if you need it back.');
        return a11y._findFindForwardDescendant(this, selector);
      },

      focusNoScroll() {
        a11y.log.deprecated('$("..").focusNoScroll, use a11y.focus($element); instead.');
        return a11y.focus(this);
      },

      focusNext(returnOnly) {
        a11y.log.deprecated('$("..").focusNext, use a11y.focusNext($element); or if needed a11y.findFirstReadable($element); instead.');

        if (returnOnly) {
          return a11y.findFirstReadable(this);
        }

        return a11y.focusNext(this);
      },

      focusOrNext(returnOnly) {
        a11y.log.deprecated('$("..").focusOrNext, use a11y.focusFirst($element); or if needed a11y.findFirstReadable($element); or a11y.isReadable($element); instead.');

        if (returnOnly) {
          if (a11y.isReadable(this)) return this;
          return a11y.findFirstReadable(this);
        }

        return a11y.focusFirst(this);
      },

      a11y_focus(dontDefer) {
        a11y.log.deprecated('$("..").a11y_focus, use a11y.focusFirst($element, { defer: true }); instead.');
        a11y.focusFirst(this, {
          defer: !dontDefer
        });
        return this;
      }

    });
    Object.assign($, {
      a11y_alert() {
        a11y.log.removed('$.a11y_alert is removed. Please use aria-live instead.');
        return this;
      },

      a11y_update() {
        a11y.log.removed('a11y_update is no longer required.');
        return this;
      },

      a11y_text(text) {
        a11y.log.removed('a11y_text is no longer required. https://tink.uk/understanding-screen-reader-interaction-modes/');
        return text;
      },

      a11y_on(isOn, selector) {
        a11y.log.deprecated('$("..").a11y_on, use a11y.toggleHidden($elements, isHidden); instead.');
        return a11y.toggleHidden(selector, !isOn);
      },

      a11y_popdown($focusTarget) {
        a11y.log.removed('$.a11y_popdown, use a11y.popupClosed($focusTarget); instead.');
        return a11y.popupClosed($focusTarget);
      },

      a11y_focus(dontDefer) {
        a11y.log.deprecated('$.a11y_focus, use a11y.focusFirst("body", { defer: true }); instead.');
        a11y.focusFirst('body', {
          defer: !dontDefer
        });
        return this;
      },

      a11y_normalize(html) {
        a11y.log.deprecated('$.a11y_normalize, use a11y.normalize("html"); instead.');
        return a11y.normalize(html);
      },

      a11y_remove_breaks(html) {
        a11y.log.deprecated('$.a11y_remove_breaks, use a11y.removeBreaks("html"); instead.');
        return a11y.removeBreaks(html);
      }

    });
  });

  class Components extends Backbone__default["default"].Controller {
    initialize() {
      this._register = {};
      this.register = this.register.bind(this);
      this.getViewName = this.getViewName.bind(this);
      this.getViewClass = this.getViewClass.bind(this);
      this.getModelName = this.getModelName.bind(this);
      this.getModelClass = this.getModelClass.bind(this);
    }

    register(name, object) {
      if (Array.isArray(name)) {
        name.forEach(name => this.register(name, object));
        return object;
      }

      if (name.split(' ').length > 1) {
        this.register(name.split(' '), object);
        return object;
      }

      if (!object.view && !object.model || object instanceof Backbone__default["default"].View) {
        logging$1.deprecated('View-only registrations are no longer supported');
        object = {
          view: object
        };
      }

      if (object.view && !object.view.template) {
        object.view.template = name;
      }

      const isModelSetAndInvalid = object.model && !(object.model.prototype instanceof Backbone__default["default"].Model) && !(object.model instanceof Function);

      if (isModelSetAndInvalid) {
        throw new Error('The registered model is not a Backbone.Model or Function');
      }

      const isViewSetAndInvalid = object.view && !(object.view.prototype instanceof Backbone__default["default"].View) && !(object.view instanceof Function);

      if (isViewSetAndInvalid) {
        throw new Error('The registered view is not a Backbone.View or Function');
      }

      this._register[name] = Object.assign({}, this._register[name], object);
      return object;
    }

    getViewName(nameModelViewOrData) {
      if (typeof nameModelViewOrData === 'string') {
        return nameModelViewOrData;
      }

      if (nameModelViewOrData instanceof Backbone__default["default"].Model) {
        nameModelViewOrData = nameModelViewOrData.toJSON();
      }

      if (nameModelViewOrData instanceof Backbone__default["default"].View) {
        let foundName;
        Object.entries(this._register).forEach(_ref => {
          let [key, entry] = _ref;
          if (!entry?.view) return;
          if (!(nameModelViewOrData instanceof entry.view)) return;
          foundName = key;
          return true;
        });
        return foundName;
      }

      if (nameModelViewOrData instanceof Object) {
        const names = [typeof nameModelViewOrData._view === 'string' && nameModelViewOrData._view, typeof nameModelViewOrData._component === 'string' && nameModelViewOrData._component, typeof nameModelViewOrData._type === 'string' && nameModelViewOrData._type].filter(Boolean);

        if (names.length) {
          const name = names.find(name => this._register[name]?.view);
          return name || names.pop();
        }
      }

      throw new Error('Cannot derive view class name from input');
    }

    getViewClass(nameModelViewOrData) {
      const name = this.getViewName(nameModelViewOrData);
      const object = this._register[name];

      if (!object) {
        logging$1.error(`A view for '${name}' isn't registered in your project`);
        return;
      }

      const isBackboneView = object.view?.prototype instanceof Backbone__default["default"].View;

      if (!isBackboneView && object.view instanceof Function) {
        return object.view();
      }

      return object.view;
    }

    getModelName(nameModelOrData) {
      if (typeof nameModelOrData === 'string') {
        return nameModelOrData;
      }

      if (nameModelOrData instanceof Backbone__default["default"].Model) {
        nameModelOrData = nameModelOrData.toJSON();
      }

      if (nameModelOrData instanceof Object) {
        const name = nameModelOrData._component;
        const entry = this._register[name];
        const isViewOnlyQuestion = entry && !entry.model && entry.view?._isQuestionType;

        if (isViewOnlyQuestion) {
          logging$1.deprecated(`Assuming a question model for a view-only question: ${name}`);
          return 'question';
        }

        const names = [typeof nameModelOrData._model === 'string' && nameModelOrData._model, typeof nameModelOrData._component === 'string' && nameModelOrData._component, typeof nameModelOrData._type === 'string' && nameModelOrData._type].filter(Boolean);

        if (names.length) {
          const name = names.find(name => this._register[name]?.model);
          return name || names.pop();
        }
      }

      throw new Error('Cannot derive model class name from input');
    }

    getModelClass(nameModelOrData) {
      const name = this.getModelName(nameModelOrData);
      const object = this._register[name];

      if (!object) {
        logging$1.error(`A model for '${name}' isn't registered in your project`);
        return;
      }

      const isBackboneModel = object.model?.prototype instanceof Backbone__default["default"].Model;

      if (!isBackboneModel && object.model instanceof Function) {
        return object.model();
      }

      return object.model;
    }

  }

  const components = new Components();
  var components$1 = __AMD("core/js/components", components);

  var AdaptCollection = __AMD("core/js/collections/adaptCollection", class AdaptCollection extends Backbone.Collection {
    initialize(models, options) {
      this.once('reset', this.loadedData, this);
    }

    loadedData() {
      Adapt$1.trigger('adaptCollection:dataLoaded');
    }

  });

  var BuildModel = __AMD("core/js/models/buildModel", class BuildModel extends LockingModel {
    defaults() {
      return {
        jsonext: 'json'
      };
    }

    initialize(attrs, options) {
      this.url = options.url;
      this.fetch({
        success: () => {
          this.isLoaded = true;
          Adapt$1.trigger('buildModel:dataLoaded');
        },
        error: () => {
          console.log('Unable to load adapt/js/build.js');
          Adapt$1.trigger('buildModel:dataLoaded');
        }
      });
    }

    isFrameworkVersion(version) {
      return semver__default["default"].satisfies(this.get('package').version, version, {
        includePrerelease: true
      });
    }

    isPluginInstalled(name) {
      let version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '*';
      const plugin = this.get('plugins').find(plugin => {
        if (plugin.name !== name) return false;
        return semver__default["default"].satisfies(plugin.version, version, {
          includePrerelease: true
        });
      });
      return Boolean(plugin);
    }

    whenReady() {
      if (this.isLoaded) return Promise.resolve();
      return new Promise(resolve => {
        Adapt$1.once('buildModel:dataLoaded', resolve);
      });
    }

  });

  var ConfigModel = __AMD("core/js/models/configModel", class ConfigModel extends LockingModel {
    defaults() {
      return {
        screenSize: {
          large: 900,
          medium: 760,
          small: 520
        },
        _forceRouteLocking: false,
        _canLoadData: true,
        _disableAnimation: false
      };
    }

    setValuesFromURLParams() {
      const paramMappings = {
        dir: '_defaultDirection',
        lang: '_defaultLanguage'
      };
      const params = new URLSearchParams(window.location.search);
      Object.entries(paramMappings).forEach(_ref => {
        let [key, value] = _ref;
        const passedVal = params.get(key);
        if (!passedVal) return;
        if (key === 'lang' && Adapt$1.build.get('availableLanguageNames')?.includes(passedVal) === false) return;
        this.set(value, passedVal);
      });
    }

    initialize(attrs, options) {
      this.url = options.url;
      this.fetch({
        success: () => {
          this.setValuesFromURLParams();
          Adapt$1.trigger('offlineStorage:prepare');
          wait$1.queue(() => {
            Adapt$1.trigger('configModel:dataLoaded');
            if (!this.get('_canLoadData')) return;
            Adapt$1.trigger('configModel:loadCourseData');
          });
        },
        error: () => logging$1.error('Unable to load course/config.json')
      });
    }

    loadData() {}

  });

  class Data extends AdaptCollection {
    model(json) {
      const ModelClass = components$1.getModelClass(json);

      if (!ModelClass) {
        return new LockingModel(json);
      }

      return new ModelClass(json, {
        parse: true
      });
    }

    initialize() {
      super.initialize();
      this.findById = this.findById.bind(this);
      this.findViewByModelId = this.findViewByModelId.bind(this);
      this.findByTrackingPosition = this.findByTrackingPosition.bind(this);
      this.on({
        add: this.onAdded,
        remove: this.onRemoved
      });
    }

    async init() {
      this.reset();
      this._byAdaptID = {};
      Adapt$1.build = new BuildModel(null, {
        url: 'adapt/js/build.min.js',
        reset: true
      });
      await Adapt$1.build.whenReady();
      $('html').attr('data-adapt-framework-version', Adapt$1.build.get('package').version);
      this.loadConfigData();
    }

    onAdded(model) {
      this._byAdaptID[model.get('_id')] = model;
    }

    onRemoved(model) {
      delete this._byAdaptID[model.get('_id')];
    }

    loadConfigData() {
      Adapt$1.config = new ConfigModel(null, {
        url: Adapt$1.build.get('coursedir') + '/config.' + Adapt$1.build.get('jsonext'),
        reset: true
      });
      this.listenToOnce(Adapt$1, 'configModel:loadCourseData', this.onLoadCourseData);
      this.listenTo(Adapt$1.config, {
        'change:_activeLanguage': this.onLanguageChange,
        'change:_defaultDirection': this.onDirectionChange
      });
    }

    onDirectionChange(model, direction) {
      if (direction === 'rtl') {
        $('html').removeClass('dir-ltr').addClass('dir-rtl').attr('dir', 'rtl');
      } else {
        $('html').removeClass('dir-rtl').addClass('dir-ltr').attr('dir', 'ltr');
      }
    }

    onLoadCourseData() {
      if (!Adapt$1.config.get('_activeLanguage')) {
        Adapt$1.config.set('_activeLanguage', Adapt$1.config.get('_defaultLanguage'));
        return;
      }

      this.loadCourseData();
    }

    async onLanguageChange(model, language) {
      await wait$1.queue();
      offlineStorage$3.set('lang', language);

      if (Adapt$1.get('_isStarted')) {
        Adapt$1.set('_isStarted', false);
      }

      this.loadCourseData(language);
    }

    async loadCourseData(newLanguage) {
      const language = Adapt$1.config.get('_activeLanguage');
      const courseFolder = Adapt$1.build.get('coursedir') + '/' + language + '/';
      $('html').attr('lang', language);
      await this.loadManifestFiles(courseFolder);
      await this.triggerDataLoaded();
      await this.triggerDataReady(newLanguage);
      this.triggerInit();
    }

    getJSON(path) {
      return new Promise((resolve, reject) => {
        $.getJSON(path, data => {
          data.__path__ = path;
          resolve(data);
        }).fail(() => {
          reject(new Error(`Unable to load ${path}`));
        });
      });
    }

    async loadManifestFiles(languagePath) {
      this.trigger('loading');
      this.reset();
      const manifestPath = languagePath + 'language_data_manifest.js';
      let manifest;

      try {
        manifest = await this.getJSON(manifestPath);
      } catch (err) {
        manifest = ['course.json', 'contentObjects.json', 'articles.json', 'blocks.json', 'components.json'];
        logging$1.error(`Manifest path '${manifestPath} not found. Using traditional files: ${manifest.join(', ')}`);
      }

      let allFileData;

      try {
        allFileData = await Promise.all(manifest.map(filePath => {
          return this.getJSON(`${languagePath}${filePath}`);
        }));
      } catch (error) {
        logging$1.error(error);
        return;
      }

      const allModelData = allFileData.reduce((result, fileData) => {
        if (Array.isArray(fileData)) {
          fileData.forEach((datum, index) => {
            datum.__path__ = fileData.__path__;
            datum.__index__ = index;
          });
          result.push(...fileData);
        } else if (fileData instanceof Object) {
          result.push(fileData);
        } else {
          logging$1.warnOnce(`File data isn't an array or object: ${fileData.__path__}`);
        }

        return result;
      }, []);
      const course = allModelData.find(modelData => modelData._type === 'course');

      if (!course) {
        throw new Error('Expected a model data with "_type": "course", none found.');
      }

      Adapt$1.trigger('courseModel:dataLoading');
      Adapt$1.course = this.push(course);
      Adapt$1.trigger('courseModel:dataLoaded');
      allModelData.forEach(modelData => {
        if (modelData._type === 'course') {
          return;
        }

        try {
          components$1.getModelName(modelData);
        } catch (error) {
          logging$1.error(`Failed to load object ${modelData.__path__}${Object.prototype.hasOwnProperty.call(modelData, '__index__') ? `[${modelData.__index__}]` : ''}`);
          logging$1.error(error);
          return;
        }

        this.push(modelData);
      });
      this.checkData();
      this.trigger('reset');
      this.trigger('loaded');
      await wait$1.queue();
    }

    async triggerDataLoaded() {
      logging$1.debug('Firing app:dataLoaded');

      try {
        this.forEach(model => model.setupModel?.());
        Adapt$1.trigger('app:dataLoaded');
      } catch (e) {
        logging$1.error('Error during app:dataLoading trigger', e);
      }

      await wait$1.queue();
    }

    async triggerDataReady(newLanguage) {
      if (newLanguage) {
        Adapt$1.trigger('app:languageChanged', newLanguage);
        await wait$1.queue();
      }

      logging$1.debug('Firing app:dataReady');

      try {
        Adapt$1.trigger('app:dataReady');
      } catch (e) {
        logging$1.error('Error during app:dataReady trigger', e);
      }

      await wait$1.queue();
    }

    triggerInit() {
      this.isReady = true;
      this.trigger('ready');
    }

    whenReady() {
      if (this.isReady) return Promise.resolve();
      return new Promise(resolve => {
        this.once('ready', resolve);
      });
    }

    hasId(id) {
      return Boolean(this._byAdaptID[id]);
    }

    findById(id) {
      const model = this._byAdaptID[id];

      if (!model) {
        console.warn(`data.findById() unable to find id: ${id}`);
        return;
      }

      return model;
    }

    findViewByModelId(id) {
      const model = this.findById(id);
      if (!model) return;
      if (model === Adapt$1.parentView.model) return Adapt$1.parentView;
      const idPathToView = [id];
      const currentLocationId = location$2._currentId;
      const currentLocationModel = model.getAncestorModels().find(model => {
        const modelId = model.get('_id');
        if (modelId === currentLocationId) return true;
        idPathToView.unshift(modelId);
        return false;
      });

      if (!currentLocationModel) {
        return console.warn(`data.findViewByModelId() unable to find view for model id: ${id}`);
      }

      const foundView = idPathToView.reduce((view, currentId) => {
        if (!view) return null;
        const childViews = view.getChildViews();
        return childViews?.find(view => view.model.get('_id') === currentId);
      }, Adapt$1.parentView);
      return foundView;
    }

    findByTrackingPosition(trackingPosition) {
      const [trackingId, indexInTrackingIdDescendants] = trackingPosition;
      const trackingIdModel = this.find(model => model.get('_trackingId') === trackingId);

      if (!trackingIdModel) {
        console.warn(`data.findByTrackingPosition() unable to find trackingPosition: ${trackingPosition}`);
        return;
      }

      if (indexInTrackingIdDescendants >= 0) {
        let trackingIdDescendants = [trackingIdModel].concat(trackingIdModel.getAllDescendantModels(true));
        trackingIdDescendants = trackingIdDescendants.filter(model => !(model.isTypeGroup('component') && model.get('_isTrackable') === false));
        return trackingIdDescendants[indexInTrackingIdDescendants];
      }

      const trackingIdAncestors = trackingIdModel.getAncestorModels();
      const ancestorDistance = Math.abs(indexInTrackingIdDescendants) - 1;
      return trackingIdAncestors[ancestorDistance];
    }

    logReadyError(view) {
      const notReadyDescendants = view.model.getAllDescendantModels(true).filter(model => !model.get('_isReady'));
      logging$1.error(`View ${notReadyDescendants.map(model => `${model.get('_id')} (${model.get('_component') ?? model.get('_type')})`).join(', ')} failed to become ready, forcing ready status.`);
      notReadyDescendants.reverse().forEach(model => model.set('_isReady', true));
    }

    checkData() {
      this.checkIds();
      this.checkTrackingIds();
    }

    checkIds() {
      const items = this.toJSON();

      const idIndex = ___default["default"].indexBy(items, '_id');

      const idGroups = ___default["default"].groupBy(items, '_id');

      const parentIdGroups = ___default["default"].groupBy(items, '_parentId');

      let orphanedIds = {};
      let emptyIds = {};
      let duplicateIds = {};
      let missingIds = {};
      items.forEach(o => {
        const isCourseType = o._type === 'course';
        const isComponentType = o._type === 'component';

        if (idGroups[o._id].length > 1) {
          duplicateIds[o._id] = true;
        }

        if (!isComponentType && !parentIdGroups[o._id]) {
          emptyIds[o._id] = true;
        }

        if (!isCourseType && (!o._parentId || !idIndex[o._parentId])) {
          orphanedIds[o._id] = true;
        }

        if (!isCourseType && o._parentId && !idIndex[o._parentId]) {
          missingIds[o._parentId] = true;
        }
      });
      orphanedIds = Object.keys(orphanedIds);
      emptyIds = Object.keys(emptyIds);
      duplicateIds = Object.keys(duplicateIds);
      missingIds = Object.keys(missingIds);
      const hasErrored = orphanedIds.length || emptyIds.length || duplicateIds.length || missingIds.length;

      if (orphanedIds.length) {
        logging$1.error(`Orphaned _ids: ${orphanedIds.join(', ')}`);
      }

      if (missingIds.length) {
        logging$1.error(`Missing _ids: ${missingIds.join(', ')}`);
      }

      if (emptyIds.length) {
        logging$1.error(`Empty _ids: ${emptyIds.join(', ')}`);
      }

      if (duplicateIds.length) {
        logging$1.error(`Duplicate _ids: ${duplicateIds.join(', ')}`);
      }

      if (hasErrored) {
        const err = new Error('Oops, looks like you have some json errors.');
        err.number = 10011;
        throw err;
      }
    }

    checkTrackingIds() {
      const items = this.toJSON();
      const trackingIdType = Adapt$1.build.get('trackingIdType') || 'block';

      const trackingIdCounts = ___default["default"].groupBy(items.filter(item => item._type === trackingIdType), '_trackingId');

      const missingTrackingIds = items.filter(item => item._type === trackingIdType && item._trackingId === undefined).map(item => item._id);

      if (missingTrackingIds.length) {
        logging$1.error(`Missing _trackingIds: ${missingTrackingIds.join(', ')}`);
      }

      const duplicateTrackingIds = Object.entries(trackingIdCounts).filter(_ref => {
        let [id, group] = _ref;
        return group.length > 1;
      }).map(_ref2 => {
        let [id, group] = _ref2;
        return `${id}:[${group.map(item => item._id).join(', ')}]`;
      });

      if (duplicateTrackingIds.length) {
        logging$1.error(`Duplicate _trackingIds: ${duplicateTrackingIds.join(', ')}`);
      }

      const hasErrored = missingTrackingIds.length || duplicateTrackingIds.length;

      if (hasErrored) {
        const err = new Error('Oops, looks like you have some json errors with trackingIds.');
        err.number = 10011;
        throw err;
      }
    }

  }

  const data = new Data();
  var data$1 = __AMD("core/js/data", data);

  class A11y extends Backbone.Controller {
    defaults() {
      return {
        _isFocusOutlineKeyboardOnlyEnabled: true,
        _isFocusOutlineDisabled: false,
        _isFocusAssignmentEnabled: true,
        _isFocusOnClickEnabled: true,
        _isFocusNextOnDisabled: true,
        _isScrollDisableEnabled: true,
        _isAriaHiddenManagementEnabled: true,
        _isPopupManagementEnabled: true,
        _isPopupWrapFocusEnabled: true,
        _isPopupAriaHiddenManagementEnabled: true,
        _isPopupTabIndexManagementEnabled: true,
        _ariaHiddenExcludes: ':not(#wrapper):not(body)',
        _tabbableElements: 'a,button,input,select,textarea,[tabindex]:not([data-a11y-force-focus])',
        _focusOutlineKeyboardOnlyIgnore: 'input,textarea',
        _tabbableElementsExcludes: ':not(.a11y-ignore):not([data-a11y-force-focus])',
        _focusableElements: 'a,button,input,select,textarea,[tabindex],label',
        _readableElements: '[role=heading],[aria-label],[aria-labelledby],[alt]',
        _focusForwardElementsExcludes: ':not([aria-labelledby][role=dialog],[aria-labelledby][role=main],[aria-labelledby][role=region],[aria-labelledby][role=radiogroup],[aria-labelledby][role=group],[aria-labelledby][role=tablist],[aria-labelledby][role=list],[aria-labelledby][role=tree],[aria-labelledby][role=treegrid],[aria-labelledby][role=table],[aria-labelledby][role=grid][aria-labelledby],[role=menu],[aria-labelledby][role=rowgroup])',
        _focusguard: '.a11y-focusguard',
        _wrapStyleElements: 'b,i,abbr,strong,em,small,sub,sup,ins,del,mark,zw,nb',
        _warnFirstOnly: true,
        _warn: true
      };
    }

    initialize() {
      this.isFocusable = this.isFocusable.bind(this);
      this.isReadable = this.isReadable.bind(this);
      this.isTabbable = this.isTabbable.bind(this);
      this.$html = $('html');
      this._htmlCharRegex = /&.*;/g;
      this.config = null;
      this._browserFocus = new BrowserFocus({
        a11y: this
      });
      this._keyboardFocusOutline = new KeyboardFocusOutline({
        a11y: this
      });
      this._wrapFocus = new WrapFocus({
        a11y: this
      });
      this._popup = new Popup({
        a11y: this
      });
      this._scroll = new Scroll({
        a11y: this
      });
      this.log = new Log({
        a11y: this
      });
      deprecated(this);

      this._removeLegacyElements();

      this.listenToOnce(Adapt$1, {
        'configModel:dataLoaded': this._onConfigDataLoaded,
        'navigationView:postRender': this._removeLegacyElements
      }, this);
      Adapt$1.on('device:changed', this._setupNoSelect);
      this.listenTo(Adapt$1, {
        'router:location': this._onNavigationStart,
        'contentObjectView:ready router:plugin': this._onNavigationEnd
      });
    }

    _onConfigDataLoaded() {
      this.config = Adapt$1.config.get('_accessibility');
      this.config._isActive = false;
      this.config._options = _.defaults(this.config._options || {}, this.defaults());
      offlineStorage$3.set('a11y', false);
      this.$html.toggleClass('has-accessibility', this.isEnabled());

      this._setupNoSelect();

      this._addFocuserDiv();

      if (this._isReady) {
        return;
      }

      this._isReady = true;
      Adapt$1.trigger('accessibility:ready');
    }

    _setupNoSelect() {
      if (!this.config?._disableTextSelectOnClasses) {
        return;
      }

      const classes = this.config._disableTextSelectOnClasses.split(' ');

      const isMatch = classes.some(className => this.$html.is(className));
      this.$html.toggleClass('u-no-select', isMatch);
    }

    _addFocuserDiv() {
      if ($('#a11y-focuser').length) {
        return;
      }

      $('body').append($('<div id="a11y-focuser" class="a11y-ignore" tabindex="-1">&nbsp;</div>'));
    }

    _removeLegacyElements() {
      const $legacyElements = $('body').children('#accessibility-toggle, #accessibility-instructions');
      const $navigationElements = $('.nav').find('#accessibility-toggle, #accessibility-instructions');

      if (!$legacyElements.length && !$navigationElements.length) {
        return;
      }

      logging$1.warn('REMOVED: #accessibility-toggle and #accessibility-instructions have been removed. Please remove them from all of your .html files.');
      $legacyElements.remove();
      $navigationElements.remove();
    }

    _onNavigationStart() {
      if (!this.isEnabled()) {
        return;
      }

      _.defer(() => this.toggleHidden('.contentobject', true));
    }

    _onNavigationEnd(view) {
      if (view?.model?.get('_id') !== location$2._currentId || !this.isEnabled()) {
        return;
      }

      this.toggleHidden('.contentobject', false);
    }

    isActive() {
      this.log.removed('Accessibility is now always active when enabled. Please unify your user experiences.');
      return false;
    }

    isEnabled() {
      return this.config?._isEnabled;
    }

    ariaLevel() {
      let {
        id = null,
        level = "1",
        override = null
      } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (arguments.length === 2) {
        level = arguments[0];
        override = arguments[1];
        id = null;
      }

      const ariaLevels = Adapt$1.config.get('_accessibility')?._ariaLevels ?? defaultAriaLevels;

      function calculateLevel() {
        let id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        let level = arguments.length > 1 ? arguments[1] : undefined;
        let offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        const isNumber = !isNaN(level);
        const isTypeName = /[a-zA-z]/.test(level);

        if (!isTypeName && isNumber) {
          return parseInt(level) + offset;
        }

        const relativeDescriptor = Adapt$1.parseRelativeString(level);
        const nextLevel = ariaLevels?.['_' + relativeDescriptor.type];
        const hasModelId = Boolean(id);

        if (!hasModelId) {
          logging$1.warnOnce('Cannot calculate appropriate heading level, no model id was specified');
          return calculateLevel(id, nextLevel, offset + relativeDescriptor.offset);
        }

        const nextModel = data$1.findById(id)?.findAncestor(relativeDescriptor.type?.toLowerCase()) ?? data$1.findById(id);
        const nextModelId = nextModel?.get('_id') ?? id;
        const hasNextTitle = Boolean(nextModel.get('displayTitle'));
        const nextModelOverride = nextModel.get('_ariaLevel');
        const accumulatedOffset = offset + (hasNextTitle ? relativeDescriptor.offset : 0);
        const resolvedLevel = nextModelOverride ?? nextLevel;
        return calculateLevel(nextModelId, resolvedLevel, accumulatedOffset);
      }

      return calculateLevel(id, override ?? level);
    }

    toggleHidden($elements) {
      let isHidden = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      $elements = $($elements);
      const config = this.config;

      if (!config._isEnabled || !config._options._isAriaHiddenManagementEnabled) {
        return this;
      }

      if (isHidden === true) {
        $elements.attr('aria-hidden', true);
      } else {
        $elements.removeAttr('aria-hidden');
      }

      return this;
    }

    toggleAccessibleEnabled($elements, isAccessibleEnabled) {
      this.toggleAccessible($elements, isAccessibleEnabled);
      this.toggleEnabled($elements, isAccessibleEnabled);
      return this;
    }

    toggleAccessible($elements) {
      let isReadable = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      $elements = $($elements);
      const config = this.config;

      if (!config._isEnabled || !config._options._isAriaHiddenManagementEnabled || $elements.length === 0) {
        return this;
      }

      if (!isReadable) {
        $elements.attr({
          tabindex: '-1',
          'aria-hidden': 'true'
        }).addClass('aria-hidden');
      } else {
        $elements.removeAttr('aria-hidden tabindex').removeClass('aria-hidden');
        $elements.parents(config._options._ariaHiddenExcludes).removeAttr('aria-hidden').removeClass('aria-hidden');
      }

      return this;
    }

    toggleEnabled($elements) {
      let isEnabled = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      $elements = $($elements);

      if ($elements.length === 0) {
        return this;
      }

      if (!isEnabled) {
        $elements.attr({
          'aria-disabled': 'true'
        }).addClass('is-disabled');
      } else {
        $elements.removeAttr('aria-disabled').removeClass('is-disabled');
      }

      return this;
    }

    toggleTabbableDescendants($element) {
      let isTabbable = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      const $tabbable = this.findTabbable($element);

      if (!isTabbable) {
        $tabbable.each((index, element) => {
          if (element.isAdaptTabHidden) return;
          const $element = $(element);
          element.isAdaptTabHidden = true;
          element.adaptPreviousTabIndex = $element.attr('tabindex') ?? null;
          $element.attr('tabindex', -1);
        });
        return this;
      }

      $tabbable.each((index, element) => {
        if (!element.isAdaptTabHidden) return;
        const $element = $(element);
        if (element.adaptPreviousTabIndex === null) $element.removeAttr('tabindex');else $element.attr('tabindex', element.adaptPreviousTabIndex);
        delete element.isAdaptTabHidden;
        delete element.adaptPreviousTabIndex;
      });
      return this;
    }

    findFirstTabbable($element) {
      $element = $($element).first();
      return this._findFirstForward($element, this.isTabbable);
    }

    findFirstReadable($element) {
      $element = $($element).first();
      return this._findFirstForward($element, this.isReadable);
    }

    findFirstFocusable($element) {
      $element = $($element).first();
      return this._findFirstForward($element, this.isFocusable);
    }

    findTabbable($element) {
      const config = this.config;
      return $($element).find(config._options._tabbableElements).filter(config._options._tabbableElementsExcludes);
    }

    findReadable($element) {
      return $($element).find('*').filter((index, element) => this.isReadable(element));
    }

    findFocusable($element) {
      return $($element).find('*').filter((index, element) => this.isFocusable(element));
    }

    isTabbable($element) {
      const config = this.config;
      const value = $($element).is(config._options._tabbableElements).is(config._options._tabbableElementsExcludes);

      if (!value) {
        return null;
      }

      return value;
    }

    isReadable($element) {
      let checkParents = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      const config = this.config;
      $element = $($element).first();
      const $branch = checkParents ? $element.add($element.parents()) : $element;
      const isNotVisible = $branch.toArray().some(item => {
        const $item = $(item);
        return $item.css('display') === 'none' || $item.css('visibility') === 'hidden' || $item.attr('aria-hidden') === 'true';
      });

      if (isNotVisible) {
        return false;
      }

      const hasReadableContent = !/^\s*$/.test($element.text()) || !/^\s*$/.test($element.attr('aria-label') ?? '') || !/^\s*$/.test($element.attr('aria-labelledby') ?? '');
      const hasNativeFocusOrIsScreenReadable = ($element.is(config._options._focusableElements) || $element.is(config._options._readableElements)) && hasReadableContent;

      if (hasNativeFocusOrIsScreenReadable) {
        return true;
      }

      const childNodes = $element[0].childNodes;

      for (let c = 0, cl = childNodes.length; c < cl; c++) {
        const childNode = childNodes[c];
        const isTextNode = childNode.nodeType === 3;

        if (!isTextNode) {
          continue;
        }

        const isOnlyWhiteSpace = /^\s*$/.test(childNode.nodeValue);

        if (isOnlyWhiteSpace) {
          continue;
        }

        return true;
      }

      return null;
    }

    isFocusable($element) {
      let checkParents = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      const config = this.config;
      $element = $($element).first();
      if (!$element.is(config._options._focusForwardElementsExcludes)) return null;
      return this.isReadable($element, checkParents);
    }

    _findFirstForward($element, selector) {
      $element = $($element).first();
      let iterator;

      switch (typeof selector) {
        case 'string':
          iterator = function ($tag) {
            return $tag.is(selector) || undefined;
          };

          break;

        case 'function':
          iterator = selector;
          break;

        case 'undefined':
          iterator = Boolean;
      }

      if ($element.length === 0) {
        return $element.not('*');
      }

      let $found = this._findFirstForwardDescendant($element, iterator);

      if ($found.length) {
        return $found;
      }

      $element.nextAll().toArray().some(sibling => {
        const $sibling = $(sibling);
        const value = iterator($sibling);

        if (value === false) {
          return false;
        }

        if (value) {
          $found = $sibling;
          return true;
        }

        $found = this._findFirstForwardDescendant($sibling, iterator);
        return Boolean($found.length);
      });

      if ($found.length) {
        return $found;
      }

      $element.add($element.parents()).toArray().reverse().some(parent => {
        const $parent = $(parent);

        if (iterator($parent) === false) {
          return false;
        }

        return $parent.nextAll().toArray().some(sibling => {
          const $sibling = $(sibling);
          const value = iterator($sibling);

          if (value === false) {
            return false;
          }

          if (value) {
            $found = $sibling;
            return true;
          }

          $found = this._findFirstForwardDescendant($sibling, iterator);
          return Boolean($found.length);
        });
      });

      if (!$found.length) {
        return $element.not('*');
      }

      return $found;
    }

    _findFirstForwardDescendant($element, selector) {
      $element = $($element).first();
      let iterator;

      switch (typeof selector) {
        case 'string':
          iterator = function ($tag) {
            return $tag.is(selector) || undefined;
          };

          break;

        case 'function':
          iterator = selector;
          break;

        case 'undefined':
          iterator = Boolean;
      }

      const $notFound = $element.not('*');

      if ($element.length === 0) {
        return $notFound;
      }

      const stack = [{
        item: $element[0],
        value: undefined
      }];
      let stackIndexPosition = 0;
      let childIndexPosition = stackIndexPosition + 1;

      do {
        const stackEntry = stack[stackIndexPosition];
        const $stackItem = $(stackEntry.item);

        switch (stackEntry.value) {
          case true:
            return $stackItem;

          case false:
            return $notFound;
        }

        $stackItem.children().toArray().forEach(item => {
          const $item = $(item);
          const value = iterator($item);

          if (value === false) {
            return;
          }

          stack.splice(childIndexPosition++, 0, {
            item: item,
            value: value
          });
        });
        stackIndexPosition++;
        childIndexPosition = stackIndexPosition + 1;
      } while (stackIndexPosition < stack.length);

      return $notFound;
    }

    focusNext($element, options) {
      options = new FocusOptions(options);
      $element = $($element).first();
      $element = this.findFirstFocusable($element);
      this.focus($element, options);
      return this;
    }

    focusFirst($element, options) {
      options = new FocusOptions(options);
      $element = $($element).first();

      if (this.isReadable($element)) {
        this.focus($element, options);
        return $element;
      }

      $element = this.findFirstFocusable($element);
      this.focus($element, options);
      return $element;
    }

    focus($element, options) {
      options = new FocusOptions(options);
      $element = $($element).first();
      const config = this.config;

      if (!config._isEnabled || !config._options._isFocusAssignmentEnabled || $element.length === 0) {
        return this;
      }

      function perform() {
        if ($element.attr('tabindex') === undefined) {
          $element.attr({
            tabindex: '0',
            'data-a11y-force-focus': 'true'
          });
        }

        if (options.preventScroll) {
          const y = $(window).scrollTop();

          try {
            $element[0].focus({
              preventScroll: true
            });
          } catch (e) {}

          switch (device$1.browser) {
            case 'internet explorer':
            case 'microsoft edge':
            case 'safari':
              window.scrollTo(null, y);
          }
        } else {
          $element[0].focus();
        }
      }

      if (options.defer) {
        _.defer(perform);
      } else {
        perform();
      }

      return this;
    }

    normalize(htmls) {
      htmls = [...arguments].filter(Boolean).filter(_.isString).join(' ');
      const text = $('<div>' + htmls + '</div>').text();
      return text.replace(this._htmlCharRegex, '');
    }

    removeBreaks(htmls) {
      htmls = [...arguments].filter(Boolean).filter(_.isString).join(' ');
      const $div = $('<div>' + htmls + '</div>');
      const stack = [$div[0]];
      let stackIndex = 0;
      const outputs = [];

      do {
        if (stack[stackIndex].childNodes.length) {
          const nodes = stack[stackIndex].childNodes;
          const usable = nodes.filter(node => {
            const isTextNode = node.nodeType === 3;

            if (isTextNode) {
              return true;
            }

            const isStyleElement = $(node).is(this.config._options._wrapStyleElements);

            if (isStyleElement) {
              return true;
            }

            return false;
          });
          outputs.push.apply(outputs, usable);
          stack.push.apply(stack, nodes);
        }

        stackIndex++;
      } while (stackIndex < stack.length);

      let rtnText = '';
      outputs.forEach(function (item) {
        rtnText += item.outerHTML || item.textContent;
      });
      return rtnText;
    }

    scrollEnable($elements) {
      this._scroll.enable($elements);

      return this;
    }

    scrollDisable($elements) {
      this._scroll.disable($elements);

      return this;
    }

    popupOpened($popupElement) {
      this._popup.opened($popupElement);

      return this;
    }

    popupClosed($focusElement) {
      this._popup.closed($focusElement);

      return this;
    }

    setPopupCloseTo($focusElement) {
      return this._popup.setCloseTo($focusElement);
    }

  }

  const a11y = new A11y();
  var a11y$1 = __AMD("core/js/a11y", a11y);

  class DrawerItemView extends Backbone.View {
    className() {
      return 'drawer__menu drawer__item';
    }

    attributes() {
      return {
        role: 'listitem'
      };
    }

    initialize() {
      this.listenTo(Adapt$1, 'drawer:empty', this.remove);
      this.render();
    }

    events() {
      return {
        'click .drawer__item-btn': 'onDrawerItemClicked'
      };
    }

    render() {
      const data = this.model.toJSON();
      const template = Handlebars.templates['drawerItem'];
      $(this.el).html(template(data)).appendTo('.drawer__holder');
      return this;
    }

    onDrawerItemClicked(event) {
      event.preventDefault();
      const eventCallback = this.model.get('eventCallback');
      Adapt$1.trigger(eventCallback);
    }

  }

  DrawerItemView.type = 'drawerItem';
  var DrawerItemView$1 = __AMD("core/js/views/drawerItemView", DrawerItemView);

  class DrawerView extends Backbone.View {
    className() {
      return 'drawer u-display-none';
    }

    attributes() {
      return {
        role: 'dialog',
        'aria-modal': 'true',
        'aria-labelledby': 'drawer-heading',
        'aria-hidden': 'true'
      };
    }

    initialize() {
      this._isVisible = false;
      this.disableAnimation = Adapt$1.config.has('_disableAnimation') ? Adapt$1.config.get('_disableAnimation') : false;
      this.drawerDir = Adapt$1.config.get('_defaultDirection') === 'rtl' ? 'left' : 'right';
      this.drawerDuration = Adapt$1.config.get('_drawer')?._duration ?? 400;
      this.setupEventListeners();
      this.render();
    }

    setupEventListeners() {
      this.listenTo(Adapt$1, {
        'navigation:toggleDrawer': this.toggleDrawer,
        'drawer:triggerCustomView': this.openCustomView,
        'drawer:closeDrawer': this.onCloseDrawer,
        remove: this.onRemove,
        'drawer:remove': this.remove
      });
      this.onKeyUp = this.onKeyUp.bind(this);
      this.setupEscapeKey();
    }

    setupEscapeKey() {
      $(window).on('keyup', this.onKeyUp);
    }

    onKeyUp(event) {
      if (event.which !== 27) return;
      event.preventDefault();
      this.onCloseDrawer();
    }

    events() {
      return {
        'click .drawer__back': 'onBackButtonClicked',
        'click .drawer__close': 'onCloseClicked'
      };
    }

    render() {
      const template = Handlebars.templates.drawer;
      $(this.el).html(template({
        _globals: Adapt$1.course.get('_globals')
      })).prependTo('body');
      const shadowTemplate = Handlebars.templates.shadow;
      $(shadowTemplate()).prependTo('body');

      _.defer(this.postRender.bind(this));

      return this;
    }

    postRender() {
      this.$('a, button, input, select, textarea').attr('tabindex', -1);
      this.checkIfDrawerIsAvailable();
    }

    openCustomView(view, hasBackButton) {
      this.$('.js-drawer-holder').removeAttr('role');
      this._hasBackButton = hasBackButton;
      this._isCustomViewVisible = true;
      Adapt$1.trigger('drawer:empty');
      this.showDrawer();
      this.$('.drawer__holder').html(view);
    }

    checkIfDrawerIsAvailable() {
      const isEmptyDrawer = this.collection.length === 0;
      $('.js-nav-drawer-btn').toggleClass('u-display-none', isEmptyDrawer);

      if (isEmptyDrawer) {
        Adapt$1.trigger('drawer:noItems');
      }
    }

    onBackButtonClicked(event) {
      event.preventDefault();
      this.showDrawer(true);
    }

    onCloseClicked(event) {
      event.preventDefault();
      this.hideDrawer();
    }

    onCloseDrawer($toElement) {
      this.hideDrawer($toElement);
    }

    onRemove() {
      this.hideDrawer();
    }

    toggleDrawer() {
      if (this._isVisible && this._isCustomViewVisible === false) {
        this.hideDrawer();
        return;
      }

      this.showDrawer(true);
    }

    showDrawer(emptyDrawer) {
      this.$el.removeClass('u-display-none').removeAttr('aria-hidden');

      if (!this._isVisible) {
        a11y$1.popupOpened(this.$el);
        a11y$1.scrollDisable('body');
        this._isVisible = true;
      }

      this.$('a, button, input, select, textarea').attr('tabindex', 0);

      if (emptyDrawer) {
        this.$('.drawer__back').addClass('u-display-none');
        this._isCustomViewVisible = false;
        this.emptyDrawer();

        if (this.collection.models.length === 1) {
          Adapt$1.trigger(this.collection.models[0].get('eventCallback'));
          this._isCustomViewVisible = false;
        } else {
          this.renderItems();
          Adapt$1.trigger('drawer:openedItemView');
        }
      } else {
        const hideDrawerBackButton = !this._hasBackButton || this.collection.models.length <= 1;
        this.$('.drawer__back').toggleClass('u-display-none', hideDrawerBackButton);
        Adapt$1.trigger('drawer:openedCustomView');
      }

      const complete = () => {
        this.addShadowEvent();
        Adapt$1.trigger('drawer:opened');
        a11y$1.focusFirst(this.$el, {
          defer: true
        });
      };

      const direction = {};

      if (this.disableAnimation) {
        $('.js-shadow').removeClass('u-display-none');
        $('.js-drawer-holder').scrollTop(0);
        direction[this.drawerDir] = 0;
        this.$el.css(direction);
        complete();
      } else {
        $('.js-shadow').velocity({
          opacity: 1
        }, {
          duration: this.drawerDuration,
          begin: () => {
            $('.js-shadow').removeClass('u-display-none');
            $('.js-drawer-holder').scrollTop(0);
            complete();
          }
        });
        const easing = Adapt$1.config.get('_drawer')?._showEasing || 'easeOutQuart';
        direction[this.drawerDir] = 0;
        this.$el.velocity(direction, this.drawerDuration, easing);
      }
    }

    emptyDrawer() {
      this.$('.drawer__holder').empty();
    }

    renderItems() {
      Adapt$1.trigger('drawer:empty');
      this.emptyDrawer();
      const isList = this.collection.length > 1;
      if (isList) this.$('.js-drawer-holder').attr('role', 'list');else this.$('.js-drawer-holder').removeAttr('role');
      this.collection.forEach(model => new DrawerItemView$1({
        model
      }));
    }

    hideDrawer($toElement) {
      if (!this._isVisible) return;
      const direction = {};
      a11y$1.popupClosed($toElement);
      this._isVisible = false;
      a11y$1.scrollEnable('body');

      if (this.disableAnimation) {
        direction[this.drawerDir] = -this.$el.width();
        this.$el.css(direction).addClass('u-display-none').attr('aria-hidden', 'true');
        $('.js-shadow').addClass('u-display-none');
        this.$('.js-drawer-holder').removeAttr('role');
        Adapt$1.trigger('drawer:closed');
      } else {
        const easing = Adapt$1.config.get('_drawer')?._hideEasing || 'easeInQuart';
        direction[this.drawerDir] = -this.$el.width();
        this.$el.velocity(direction, this.drawerDuration, easing, () => {
          this.$el.addClass('u-display-none').attr('aria-hidden', 'true');
          this.$('.js-drawer-holder').removeAttr('role');
          Adapt$1.trigger('drawer:closed');
        });
        $('.js-shadow').velocity({
          opacity: 0
        }, {
          duration: this.drawerDuration,

          complete() {
            $('.js-shadow').addClass('u-display-none');
          }

        });
      }

      this._isCustomViewVisible = false;
      this.removeShadowEvent();
    }

    addShadowEvent() {
      $('.js-shadow').one('click touchstart', () => this.onCloseDrawer());
    }

    removeShadowEvent() {
      $('.js-shadow').off('click touchstart');
    }

    remove() {
      super.remove();
      $(window).off('keyup', this.onKeyUp);
      Adapt$1.trigger('drawer:empty');
      this.collection.reset();
      $('.js-shadow').remove();
    }

  }

  Object.assign(DrawerView, {
    childContainer: '.js-drawer-holder',
    childView: DrawerItemView$1
  });
  var DrawerView$1 = __AMD("core/js/views/drawerView", DrawerView);

  const DrawerCollection = new Backbone.Collection(null, {
    comparator: 'drawerOrder'
  });
  const Drawer = {};

  Drawer.addItem = function (drawerObject, eventCallback) {
    drawerObject.eventCallback = eventCallback;
    DrawerCollection.add(drawerObject);
  };

  Drawer.triggerCustomView = function (view, hasBackButton) {
    if (hasBackButton !== false) {
      hasBackButton = true;
    }

    Adapt$1.trigger('drawer:triggerCustomView', view, hasBackButton);
  };

  Adapt$1.on({
    'adapt:start'() {
      new DrawerView$1({
        collection: DrawerCollection
      });
    },

    'app:languageChanged'() {
      Adapt$1.trigger('drawer:remove');
    }

  });
  var drawer = __AMD("core/js/drawer", Drawer);

  var AdaptSubsetCollection = __AMD("core/js/collections/adaptSubsetCollection", class AdaptSubsetCollection extends AdaptCollection {
    initialize(models, options) {
      super.initialize(models, options);
      this.parent = options.parent;
      this.listenTo(this.parent, 'reset', this.loadSubset);
    }

    loadSubset() {
      this.set(this.parent.filter(model => model instanceof this.model));
      this._byAdaptID = this.groupBy('_id');
    }

  });

  var ModelEvent = __AMD("core/js/modelEvent", class ModelEvent extends Backbone.Controller {
    initialize(type, target, value) {
      this.type = type;
      this.target = target;
      this.value = value;
      this.canBubble = true;
      this.deepPath = [target];
      this.timeStamp = null;
    }

    stopPropagation() {
      this.canBubble = false;
    }

    addPath(target) {
      this.deepPath.unshift(target);
    }

  });

  var AdaptModel = __AMD("core/js/models/adaptModel", class AdaptModel extends LockingModel {
    toJSON() {
      const json = { ...this.attributes
      };
      delete json._children;
      delete json._parent;
      return $.extend(true, {}, json);
    }

    get(name) {
      switch (name) {
        case '_parent':
        case '_children':
          logging$1.deprecated('Use model.getChildren() or model.getParent() instead of model.get(\'_children\') or model.get(\'_parent\')');
      }

      return super.get(name);
    }

    defaults() {
      return {
        _canShowFeedback: true,
        _classes: '',
        _canReset: true,
        _canRequestChild: false,
        _isComplete: false,
        _isInteractionComplete: false,
        _isA11yRegionEnabled: false,
        _isA11yCompletionDescriptionEnabled: true,
        _requireCompletionOf: -1,
        _isEnabled: true,
        _isResetOnRevisit: false,
        _isAvailable: true,
        _isOptional: false,
        _isRendered: false,
        _isReady: false,
        _isVisible: true,
        _isVisited: false,
        _isLocked: false,
        _isHidden: false
      };
    }

    get trackingPosition() {
      const firstDescendant = this.getAllDescendantModels(false).concat([this])[0];
      const nearestTrackingIdModel = [firstDescendant].concat(firstDescendant.getAncestorModels()).find(model => model.has('_trackingId'));
      if (!nearestTrackingIdModel) return;
      const trackingId = nearestTrackingIdModel.get('_trackingId');
      let trackingIdDescendants = [nearestTrackingIdModel].concat(nearestTrackingIdModel.getAllDescendantModels(true));
      trackingIdDescendants = trackingIdDescendants.filter(model => !(model.isTypeGroup('component') && model.get('_isTrackable') === false));
      const indexInTrackingIdDescendants = trackingIdDescendants.findIndex(descendant => descendant === this);

      if (indexInTrackingIdDescendants >= 0) {
        return [trackingId, indexInTrackingIdDescendants];
      }

      const trackingIdAncestors = nearestTrackingIdModel.getAncestorModels();
      const ancestorDistance = trackingIdAncestors.findIndex(ancestor => ancestor === this);
      return [trackingId, -(ancestorDistance + 1)];
    }

    parse(data) {
      if (data._isResetOnRevisit === 'false') {
        data._isResetOnRevisit = false;
      }

      return data;
    }

    trackable() {
      return ['_id', '_isComplete', '_isInteractionComplete', '_isVisited'];
    }

    trackableType() {
      return [String, Boolean, Boolean, Boolean];
    }

    bubblingEvents() {
      return ['change:_isComplete', 'change:_isInteractionComplete', 'change:_isActive', 'change:_isVisited'];
    }

    setupModel() {
      if (this.hasManagedChildren) {
        this.setupChildListeners();
      }

      this.init();

      _.defer(() => {
        if (this.hasManagedChildren) {
          this.checkCompletionStatus();
          this.checkInteractionCompletionStatus();
          this.checkLocking();
          this.checkVisitedStatus();
        }

        this.setupTrackables();
      });
    }

    setupTrackables() {
      const originalTrackableStateFunction = this.triggerTrackableState;
      this.triggerTrackableState = _.compose(() => {
        this.triggerTrackableState.isQueued = true;
      }, _.debounce(() => {
        originalTrackableStateFunction.apply(this);
        this.triggerTrackableState.isQueued = false;
      }, 17));
      this.listenTo(this, 'change', _ref => {
        let {
          changed
        } = _ref;

        if (this.triggerTrackableState.isQueued || !Adapt$1.attributes._isStarted) {
          return;
        }

        const trackablePropertyNames = _.result(this, 'trackable', []);

        const changedPropertyNames = Object.keys(changed);
        const isTrackable = changedPropertyNames.find(item => {
          return trackablePropertyNames.includes(item);
        });

        if (isTrackable) {
          this.triggerTrackableState();
        }
      });
    }

    setupChildListeners() {
      const children = this.getChildren();

      if (!children.length) {
        return;
      }

      this.listenTo(children, {
        all: this.onAll,
        bubble: this.bubble,
        'change:_isVisited': this.checkVisitedStatus,
        'change:_isReady': this.checkReadyStatus,
        'change:_isComplete': this.onIsComplete,
        'change:_isInteractionComplete': this.checkInteractionCompletionStatus
      });
    }

    init() {}

    getTrackableState() {
      const trackable = this.resultExtend('trackable', []);
      const json = this.toJSON();
      const args = trackable;
      args.unshift(json);
      return _.pick(...args);
    }

    setTrackableState(state) {
      const trackable = this.resultExtend('trackable', []);
      const args = trackable;
      args.unshift(state);
      state = _.pick(...args);
      this.set(state);
      return this;
    }

    triggerTrackableState() {
      Adapt$1.trigger('state:change', this, this.getTrackableState());
    }

    reset() {
      let type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'hard';
      let canReset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.get('_canReset');
      if (!canReset) return false;

      switch (type) {
        case 'hard':
        case true:
          this.set({
            _isEnabled: true,
            _isComplete: false,
            _isInteractionComplete: false
          });
          return true;

        case 'soft':
          this.set({
            _isEnabled: true,
            _isInteractionComplete: false
          });
          return true;
      }

      return false;
    }

    checkReadyStatus(model, value) {
      if (value === false) {
        return false;
      }

      const children = this.getAvailableChildModels();

      if (children.find(child => child.get('_isReady') === false && child.get('_isRendered'))) {
        return false;
      }

      this.set('_isReady', true);
      return true;
    }

    setReadyStatus() {
      this.set('_isReady', true);
    }

    checkVisitedStatus() {
      const children = this.getAvailableChildModels();
      const isVisited = children.some(child => child.get('_isVisited') || child.get('_isComplete') || child.get('_isInteractionComplete'));
      if (isVisited) this.set('_isVisited', true);
      return isVisited;
    }

    setVisitedStatus() {
      if (!this.get('_isReady') || !this.get('_isRendered')) return;
      this.set('_isVisited', true);
    }

    setCompletionStatus() {
      if (!this.get('_isVisible')) return;
      this.set({
        _isComplete: true,
        _isInteractionComplete: true,
        _isVisited: true
      });
    }

    checkCompletionStatus() {
      Adapt$1.checkingCompletion();

      _.defer(this.checkCompletionStatusFor.bind(this), '_isComplete');
    }

    checkInteractionCompletionStatus() {
      Adapt$1.checkingCompletion();

      _.defer(this.checkCompletionStatusFor.bind(this), '_isInteractionComplete');
    }

    checkCompletionStatusFor() {
      let completionAttribute = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '_isComplete';
      let completed = false;
      const children = this.getAvailableChildModels();
      const requireCompletionOf = this.get('_requireCompletionOf');

      if (requireCompletionOf === -1) {
        completed = children.every(child => {
          return child.get(completionAttribute) || child.get('_isOptional');
        });
      } else {
        completed = children.filter(child => {
          return child.get(completionAttribute) && !child.get('_isOptional');
        }).length >= requireCompletionOf;
      }

      this.set(completionAttribute, completed);
      Adapt$1.checkedCompletion();
    }

    getTypeGroup() {}

    isTypeGroup(typeGroup) {
      const hasUpperCase = /[A-Z]+/.test(typeGroup);
      const isPluralized = typeGroup.slice(-1) === 's';
      const lowerCased = typeGroup.toLowerCase();
      const singular = isPluralized && lowerCased.slice(0, -1);
      const singularLowerCased = (singular || lowerCased).toLowerCase();

      if (isPluralized || hasUpperCase) {
        logging$1.deprecated(`'${typeGroup}' appears pluralized or contains uppercase characters, suggest using the singular, lowercase type group '${singularLowerCased}'.`);
      }

      const pluralizedLowerCaseTypes = [singularLowerCased, !isPluralized && `${lowerCased}s`].filter(Boolean);
      const typeGroups = this.getTypeGroups();

      if (_.intersection(pluralizedLowerCaseTypes, typeGroups).length) {
        return true;
      }

      return false;
    }

    getTypeGroups() {
      if (this._typeGroups) return this._typeGroups;
      const typeGroups = [this.get('_type')];
      let parentClass = this;

      while (parentClass = Object.getPrototypeOf(parentClass)) {
        if (!Object.prototype.hasOwnProperty.call(parentClass, 'getTypeGroup')) continue;
        typeGroups.push(parentClass.getTypeGroup.call(this));
      }

      return this._typeGroups = _.uniq(typeGroups.filter(Boolean).map(s => s.toLowerCase()));
    }

    findAncestor(ancestorType) {
      const parent = this.getParent();
      if (!parent) return;

      if (!ancestorType || parent.isTypeGroup(ancestorType)) {
        return parent;
      }

      return parent.findAncestor(ancestorType);
    }

    findDescendantModels(descendants, options) {
      const allDescendantsModels = this.getAllDescendantModels();
      const returnedDescendants = allDescendantsModels.filter(model => {
        return model.isTypeGroup(descendants);
      });

      if (!options) {
        return returnedDescendants;
      }

      if (options.where) {
        return returnedDescendants.filter(descendant => {
          for (const property in options.where) {
            const value = options.where[property];

            if (descendant.get(property) !== value) {
              return false;
            }
          }

          return true;
        });
      }
    }

    getAllDescendantModels(isParentFirst) {
      const descendants = [];

      if (!this.hasManagedChildren) {
        return descendants;
      }

      const children = this.getChildren();
      children.models.forEach(child => {
        if (!child.hasManagedChildren) {
          descendants.push(child);
          return;
        }

        const subDescendants = child.getAllDescendantModels(isParentFirst);

        if (isParentFirst === true) {
          descendants.push(child);
        }

        descendants.push(...subDescendants);

        if (isParentFirst !== true) {
          descendants.push(child);
        }
      });
      return descendants;
    }

    findRelativeModel(relativeString) {
      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      if (!relativeString) return this;
      let relativeDescriptorObjects = Adapt$1.parseRelativeString(relativeString);
      if (!Array.isArray(relativeDescriptorObjects)) relativeDescriptorObjects = [relativeDescriptorObjects];

      const find = _ref2 => {
        let {
          type,
          offset,
          inset
        } = _ref2;
        const isInset = inset !== null;
        const isOffset = offset !== null;
        const rootModel = options.limitParentId ? data$1.findById(options.limitParentId) : isInset ? this : Adapt$1.course;
        const increment = isOffset ? offset : inset;
        const searchBackwards = increment < 0;
        let moveBy = Math.abs(increment);
        let movementCount = 0;
        const hasDescendantsOfType = Boolean(this.findDescendantModels(type).length);
        if (isInset && !hasDescendantsOfType) return undefined;

        if (isOffset && hasDescendantsOfType) {
          moveBy--;
        }

        if (isInset && searchBackwards) {
          moveBy--;
        }

        const searchDescendants = searchBackwards ? [rootModel, ...rootModel.getAllDescendantModels(true)].reverse() : [...rootModel.getAllDescendantModels(false), rootModel];
        const modelId = this.get('_id');
        const searchFromIndex = isInset ? 0 : searchDescendants.findIndex(searchDescendant => searchDescendant.get('_id') === modelId);
        const hasFilterFunction = typeof options.filter === 'function';

        if (options.loop) {
          const totalOfType = searchDescendants.reduce((count, model) => {
            if (!model.isTypeGroup(type)) return count;
            return ++count;
          }, 0);
          moveBy = moveBy % totalOfType;
          searchDescendants.push(...searchDescendants.slice(0));
        }

        for (let i = searchFromIndex, l = searchDescendants.length; i < l; i++) {
          const descendant = searchDescendants[i];
          if (!descendant.isTypeGroup(type)) continue;
          const isSelf = i === searchFromIndex;
          if (!isSelf && hasFilterFunction && !options.filter(descendant)) continue;

          if (movementCount > moveBy) {
            break;
          }

          if (movementCount === moveBy) {
            return descendant;
          }

          movementCount++;
        }
      };

      const nextDescriptor = relativeDescriptorObjects.slice(1).reduce((output, _ref3) => {
        let {
          type,
          offset,
          inset
        } = _ref3;
        const isInset = inset !== null;
        const isOffset = offset !== null;
        if (isOffset) return `${output}@${type}${offset < 0 ? offset : `+${offset}`}`;
        if (isInset) return `${output}@${type}=${inset}`;
        return `${output}@${type}`;
      }, '');
      const foundModel = find(relativeDescriptorObjects[0]);

      if (nextDescriptor) {
        return foundModel?.findRelativeModel(nextDescriptor);
      }

      return foundModel;
    }

    get hasManagedChildren() {
      return true;
    }

    getChildren() {
      if (this._childrenCollection) {
        return this._childrenCollection;
      }

      let childrenCollection;

      if (!this.hasManagedChildren) {
        childrenCollection = new Backbone.Collection();
      } else {
        const id = this.get('_id');
        const children = data$1.filter(model => model.get('_parentId') === id);
        childrenCollection = new Backbone.Collection(children);
      }

      if (this.get('_type') === 'block' && childrenCollection.length === 2 && childrenCollection.models[0].get('_layout') !== 'left') {
        childrenCollection.comparator = '_layout';
        childrenCollection.sort();
      }

      this.setChildren(childrenCollection);
      return this._childrenCollection;
    }

    setChildren(children) {
      this._childrenCollection = children;
      this.set('_children', children);
    }

    getAvailableChildModels() {
      return this.getChildren().where({
        _isAvailable: true
      });
    }

    getParent() {
      if (this._parentModel) {
        return this._parentModel;
      }

      const parentId = this.get('_parentId');
      if (!parentId) return;
      this.setParent(data$1.findById(parentId));
      return this._parentModel;
    }

    setParent(parent) {
      this._parentModel = parent;
      this.set('_parentId', this._parentModel.get('_id'));
      this.set('_parent', this._parentModel);
    }

    getAncestorModels(shouldIncludeChild) {
      const parents = [];
      let context = this;
      if (shouldIncludeChild) parents.push(context);

      while (context.has('_parentId')) {
        context = context.getParent();
        parents.push(context);
      }

      return parents.length ? parents : null;
    }

    getSiblings(passSiblingsAndIncludeSelf) {
      const id = this.get('_id');
      const parentId = this.get('_parentId');
      let siblings;

      if (!passSiblingsAndIncludeSelf) {
        if (this._hasSiblingsAndSelf === false) {
          return this.get('_siblings');
        }

        siblings = data$1.filter(model => {
          return model.get('_parentId') === parentId && model.get('_id') !== id;
        });
        this._hasSiblingsAndSelf = false;
      } else {
        if (this._hasSiblingsAndSelf) {
          return this.get('_siblings');
        }

        siblings = data$1.filter(model => {
          return model.get('_parentId') === parentId;
        });
        this._hasSiblingsAndSelf = true;
      }

      const siblingsCollection = new Backbone.Collection(siblings);
      this.set('_siblings', siblingsCollection);
      return siblingsCollection;
    }

    setOnChildren() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      this.set(...args);
      if (!this.hasManagedChildren) return;
      const children = this.getChildren();
      children.models.forEach(child => child.setOnChildren(...args));
    }

    setOptional(value) {
      logging$1.deprecated('Use model.set(\'_isOptional\', value) as setOptional() may be removed in the future');
      this.set({
        _isOptional: value
      });
    }

    checkLocking() {
      const lockType = this.get('_lockType');
      if (!lockType) return;

      switch (lockType) {
        case 'sequential':
          this.setSequentialLocking();
          break;

        case 'unlockFirst':
          this.setUnlockFirstLocking();
          break;

        case 'lockLast':
          this.setLockLastLocking();
          break;

        case 'custom':
          this.setCustomLocking();
          break;

        default:
          console.warn(`AdaptModel.checkLocking: unknown _lockType '${lockType}' found on ${this.get('_id')}`);
      }
    }

    setSequentialLocking() {
      const children = this.getAvailableChildModels();
      children.slice(1).forEach((child, index) => {
        const previousChild = children[index];
        const isLockedByPreviousChild = previousChild.get('_isLocked') || !previousChild.get('_isComplete') && !previousChild.get('_isOptional');
        child.set('_isLocked', isLockedByPreviousChild);
      }, false);
    }

    setUnlockFirstLocking() {
      const children = this.getAvailableChildModels();
      const firstChild = children.shift();
      const isLockedByFirstChild = !firstChild.get('_isComplete') && !firstChild.get('_isOptional');
      children.forEach(child => child.set('_isLocked', isLockedByFirstChild));
    }

    setLockLastLocking() {
      const children = this.getAvailableChildModels();
      const lastChild = children.pop();
      const isLockedByChildren = children.some(child => !child.get('_isComplete') && !child.get('_isOptional'));
      lastChild.set('_isLocked', isLockedByChildren);
    }

    setCustomLocking() {
      const children = this.getAvailableChildModels();
      children.forEach(child => child.set('_isLocked', this.shouldLock(child)));
    }

    shouldLock(child) {
      const lockedBy = child.get('_lockedBy');
      if (!lockedBy) return false;
      return lockedBy.some(id => {
        try {
          const anotherModel = data$1.findById(id);
          return anotherModel.get('_isAvailable') && (anotherModel.get('_isLocked') || !anotherModel.get('_isComplete') && !anotherModel.get('_isOptional'));
        } catch (e) {
          console.warn(`AdaptModel.shouldLock: unknown _lockedBy ID '${id}' found on ${child.get('_id')}`);
          return false;
        }
      });
    }

    onIsComplete() {
      this.checkCompletionStatus();
      this.checkLocking();
    }

    checkIfResetOnRevisit() {
      const isResetOnRevisit = this.get('_isResetOnRevisit');
      this.reset(isResetOnRevisit);
    }

    deepClone() {
      let modifier = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      const ModelClass = this.constructor;
      const clonedModel = new ModelClass(this.toJSON());

      if (modifier) {
        modifier(clonedModel, this);
      }

      let clonedId = clonedModel.get('_id');
      const hasId = Boolean(clonedId);
      const shouldAssignUniqueId = this.get('_id') === clonedId;

      if (hasId && shouldAssignUniqueId) {
        const cid = _.uniqueId(ModelClass.prototype.cidPrefix || 'c');

        clonedId = `${clonedId}_${cid}`;
        clonedModel.set('_id', clonedId);
      }

      if (hasId) {
        data$1.add(clonedModel);
      }

      if (this.hasManagedChildren) {
        this.getChildren().each(child => {
          if (!child.deepClone) {
            throw new Error('Cannot deepClone child.');
          }

          child.deepClone((clone, child) => {
            if (hasId) {
              clone.set('_parentId', clonedId);
            }

            if (modifier) {
              modifier(clone, child);
            }
          });
        });
      }

      clonedModel.getParent().getChildren().add(clonedModel);
      clonedModel.setupModel();
      return clonedModel;
    }

    onAll(type, model, value) {
      if (!_.result(this, 'bubblingEvents').includes(type)) return;
      const event = new ModelEvent(type, model, value);
      this.bubble(event);
    }

    bubble(event) {
      if (!event.canBubble) return;
      event.addPath(this);
      this.trigger(`bubble:${event.type} bubble`, event);
    }

  });

  var ContentObjectModel = __AMD("core/js/models/contentObjectModel", class ContentObjectModel extends AdaptModel {
    get _parent() {
      logging$1.deprecated('contentObjectModel._parent, use contentObjectModel.getParent() instead, parent models are defined by the JSON');
      const isParentCourse = this.get('_parentId') === Adapt$1.course.get('_id');

      if (isParentCourse) {
        return 'course';
      }

      return 'contentObjects';
    }

    get _siblings() {
      logging$1.deprecated('contentObjectModel._siblings, use contentObjectModel.getSiblings() instead, sibling models are defined by the JSON');
      return 'contentObjects';
    }

    get _children() {
      logging$1.deprecated('contentObjectModel._children, use contentObjectModel.hasManagedChildren instead, child models are defined by the JSON');
      return null;
    }

    getTypeGroup() {
      return 'contentobject';
    }

  });

  class ArticleModel extends AdaptModel {
    get _parent() {
      logging$1.deprecated('articleModel._parent, use articleModel.getParent() instead, parent models are defined by the JSON');
      return 'contentObjects';
    }

    get _siblings() {
      logging$1.deprecated('articleModel._siblings, use articleModel.getSiblings() instead, sibling models are defined by the JSON');
      return 'articles';
    }

    get _children() {
      logging$1.deprecated('articleModel._children, use articleModel.hasManagedChildren instead, child models are defined by the JSON');
      return 'blocks';
    }

    getTypeGroup() {
      return 'article';
    }

  }

  components$1.register('article', {
    model: ArticleModel
  });
  var ArticleModel$1 = __AMD("core/js/models/articleModel", ArticleModel);

  class BlockModel extends AdaptModel {
    get _parent() {
      logging$1.deprecated('blockModel._parent, use blockModel.getParent() instead, parent models are defined by the JSON');
      return 'articles';
    }

    get _siblings() {
      logging$1.deprecated('blockModel._siblings, use blockModel.getSiblings() instead, sibling models are defined by the JSON');
      return 'blocks';
    }

    get _children() {
      logging$1.deprecated('blockModel._children, use blockModel.hasManagedChildren instead, child models are defined by the JSON');
      return 'components';
    }

    getTypeGroup() {
      return 'block';
    }

  }

  components$1.register('block', {
    model: BlockModel
  });
  var BlockModel$1 = __AMD("core/js/models/blockModel", BlockModel);

  class ComponentModel extends AdaptModel {
    get _parent() {
      logging$1.deprecated('componentModel._parent, use componentModel.getParent() instead, parent models are defined by the JSON');
      return 'blocks';
    }

    get _siblings() {
      logging$1.deprecated('componentModel._siblings, use componentModel.getSiblings() instead, sibling models are defined by the JSON');
      return 'components';
    }

    getTypeGroup() {
      return 'component';
    }

    defaults() {
      return AdaptModel.resultExtend('defaults', {
        _isA11yComponentDescriptionEnabled: true,
        _shouldStoreAttempts: true,
        _userAnswer: null,
        _attemptStates: null
      });
    }

    trackable() {
      return AdaptModel.resultExtend('trackable', ['_userAnswer', '_attemptStates']);
    }

    trackableType() {
      return AdaptModel.resultExtend('trackableType', [Array, Array]);
    }

    get hasManagedChildren() {
      return false;
    }

    init() {
      if (Adapt$1.get('_isStarted')) {
        this.onAdaptInitialize();
        return;
      }

      this.listenToOnce(Adapt$1, 'adapt:initialize', this.onAdaptInitialize);
    }

    onAdaptInitialize() {
      this.restoreUserAnswers();
    }

    restoreUserAnswers() {}

    storeUserAnswer() {}

    resetUserAnswer() {
      this.set('_userAnswer', null);
    }

    reset() {
      let type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'hard';
      let canReset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.get('_canReset');
      const wasReset = super.reset(type, canReset);
      if (!wasReset) return false;
      this.resetUserAnswer();
      return true;
    }

    getAttemptState() {
      let object = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.toJSON();
      const trackables = this.trackable();
      const types = this.trackableType();
      trackables.find((name, index) => {
        if (name !== '_attemptStates') return false;
        trackables.splice(index, 1);
        types.splice(index, 1);
        return true;
      });
      const values = trackables.map(n => object[n]);
      const booleans = values.filter((v, i) => types[i] === Boolean).map(Boolean);
      const numbers = values.filter((v, i) => types[i] === Number).map(v => Number(v) || 0);
      const arrays = values.filter((v, i) => types[i] === Array);
      return [numbers, booleans, arrays];
    }

    getAttemptObject() {
      let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getAttemptState();
      const trackables = this.trackable();
      const types = this.trackableType();
      trackables.find((name, index) => {
        if (name !== '_attemptStates') return false;
        trackables.splice(index, 1);
        types.splice(index, 1);
        return true;
      });
      const numbers = (state[0] || []).slice(0);
      const booleans = (state[1] || []).slice(0);
      const arrays = (state[2] || []).slice(0);
      const object = {};
      trackables.forEach((n, i) => {
        if (n === '_id') return;

        switch (types[i]) {
          case Number:
            object[n] = numbers.shift();
            break;

          case Boolean:
            object[n] = booleans.shift();
            break;

          case Array:
            object[n] = arrays.shift();
            break;
        }
      });
      return object;
    }

    setAttemptObject(object) {
      let silent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      this.set(object, {
        silent
      });
    }

    addAttemptObject() {
      let object = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getAttemptObject();
      const attemptStates = this.get('_attemptStates') || [];
      const state = this.getAttemptState(object);
      attemptStates.push(state);
      this.set('_attemptStates', attemptStates);
    }

    getAttemptObjects() {
      const states = this.get('_attemptStates') || [];
      return states.map(state => this.getAttemptObject(state));
    }

  }

  components$1.register('component', {
    model: ComponentModel
  });
  var ComponentModel$1 = __AMD("core/js/models/componentModel", ComponentModel);

  class MenuModel extends ContentObjectModel {
    get _children() {
      logging$1.deprecated('menuModel._children, use menuModel.hasManagedChildren instead, child models are defined by the JSON');
      return 'contentObjects';
    }

    getTypeGroup() {
      return 'menu';
    }

    setCustomLocking() {
      const children = this.getAvailableChildModels();
      children.forEach(child => {
        child.set('_isLocked', this.shouldLock(child));
        if (!(child instanceof MenuModel)) return;
        child.checkLocking();
      });
    }

  }

  components$1.register('menu', {
    model: MenuModel
  });
  var MenuModel$1 = __AMD("core/js/models/menuModel", MenuModel);

  class CourseModel extends MenuModel$1 {
    get _parent() {
      logging$1.deprecated('courseModel._parent, use courseModel.getParent() instead, parent models are defined by the JSON');
      return null;
    }

    get _siblings() {
      logging$1.deprecated('courseModel._siblings, use courseModel.getSiblings() instead, sibling models are defined by the JSON');
      return null;
    }

    getTypeGroup() {
      return 'course';
    }

  }

  components$1.register('course', {
    model: CourseModel
  });
  var CourseModel$1 = __AMD("core/js/models/courseModel", CourseModel);

  class PageModel extends ContentObjectModel {
    get _children() {
      logging$1.deprecated('pageModel._children, use menuModel.hasManagedChildren instead, child models are defined by the JSON');
      return 'articles';
    }

    getTypeGroup() {
      return 'page';
    }

  }

  components$1.register('page', {
    model: PageModel
  });
  __AMD("core/js/models/pageModel", PageModel);

  var ChildEvent = __AMD("core/js/childEvent", class ChildEvent extends Backbone.Controller {
    initialize(type, target, model) {
      this.type = type;
      this.target = target;
      this.isForced = false;
      this.isStoppedImmediate = false;
      this.isStoppedNext = false;
      this.hasRequestChild = false;
      this._model = model;
    }

    get model() {
      return this._model;
    }

    set model(model) {
      if (this.type !== 'requestChild') {
        logging$1.warn(`Cannot change model in ${this.type} event.`);
        return;
      }

      if (this._model) {
        logging$1.warn(`Cannot inject two models in one sitting. ${model.get('_id')} attempts to overwrite ${this._model.get('_id')}`);
        return;
      }

      this._model = model;
      this.hasRequestChild = true;
    }

    reset() {
      this.isStoppedImmediate = false;
      this.isStoppedNext = false;
    }

    force() {
      this.isForced = true;
    }

    stop() {
      let immediate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      if (!immediate) {
        return this.stopNext();
      }

      this.isStoppedImmediate = true;
    }

    stopNext() {
      this.isStoppedNext = true;
    }

    close() {
      this.trigger('closed');
    }

  });

  var TemplateRenderEvent = __AMD("core/js/templateRenderEvent", class TemplateRenderEvent extends Backbone.Controller {
    initialize(type, name, mode, value, args) {
      this.type = type;
      this.name = name;
      this.mode = mode;
      this.value = value;
      this.args = args;
    }

  });

  var register = __AMD("core/js/reactHelpers", function register(name, component) {
    templates[name] = function () {
      const mode = 'reactTemplate';

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      const preRenderEvent = new TemplateRenderEvent(`${mode}:preRender`, name, mode, null, args);
      Adapt$1.trigger(preRenderEvent.type, preRenderEvent);
      const value = component(...preRenderEvent.args);
      const postRenderEvent = new TemplateRenderEvent(`${mode}:postRender`, name, mode, value, preRenderEvent.args);
      Adapt$1.trigger(postRenderEvent.type, postRenderEvent);
      return postRenderEvent.value;
    };
  });

  (function () {
    const original = React__default["default"].createElement;

    React__default["default"].createElement = function () {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      const name = args[0];
      const mode = 'reactElement';
      const preRenderEvent = new TemplateRenderEvent(`${mode}:preRender`, name, mode, null, args);
      Adapt$1.trigger(preRenderEvent.type, preRenderEvent);
      const value = original(...preRenderEvent.args);
      const postRenderEvent = new TemplateRenderEvent(`${mode}:postRender`, name, mode, value, preRenderEvent.args);
      Adapt$1.trigger(postRenderEvent.type, postRenderEvent);
      return postRenderEvent.value;
    };
  })();

  const templates = {};
  function html(html) {
    if (!html) return;
    logging$1.deprecated('reactHelpers.html please use react dangerouslySetInnerHTML instead: https://reactjs.org/docs/dom-elements.html#dangerouslysetinnerhtml');
    return {
      __html: html
    };
  }
  function compile(template) {
    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
      args[_key3 - 1] = arguments[_key3];
    }

    const output = Handlebars.compile(template)(...args);
    return output;
  }
  function classes() {
    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      args[_key5] = arguments[_key5];
    }

    return _.uniq(_.flatten(args).filter(Boolean).join(' ').split(' ')).join(' ');
  }
  function prefixClasses(prefixes) {
    for (var _len6 = arguments.length, args = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {
      args[_key6 - 1] = arguments[_key6];
    }

    const classes = _.flatten(args).filter(Boolean);

    const prefixed = _.flatten(prefixes.map(prefix => classes.map(className => `${prefix}${className}`)));

    return _.uniq(prefixed.join(' ').split(' ')).join(' ');
  }

  class AdaptView extends Backbone.View {
    attributes() {
      return {
        'data-adapt-id': this.model.get('_id')
      };
    }

    initialize() {
      this.listenTo(this.model, {
        'change:_isVisible': this.toggleVisibility,
        'change:_isHidden': this.toggleHidden,
        'change:_isComplete': this.onIsCompleteChange
      });
      this.isJSX = (this.constructor.template || '').includes('.jsx');

      if (this.isJSX) {
        this._classSet = new Set(_.result(this, 'className').trim().split(/\s+/));
        this.listenTo(this.model, 'all', this.changed);
        const children = this.model?.getChildren?.();
        children && this.listenTo(children, 'all', this.changed);
        this.listenTo(Adapt$1, 'device:changed', this.changed);
      }

      this.model.set({
        _globals: Adapt$1.course.get('_globals'),
        _isReady: false
      });
      this._isRemoved = false;

      if (location$2._currentId === this.model.get('_id')) {
        Adapt$1.parentView = this;
      }

      this.preRender();
      this.render();
      this.setupOnScreenHandler();
    }

    preRender() {}

    async postRender() {
      await this.addChildren();
    }

    render() {
      const type = this.constructor.type;
      Adapt$1.trigger(`${type}View:preRender view:preRender`, this);

      if (this.isJSX) {
        this.changed();
      } else {
        const data = this.model.toJSON();
        data.view = this;
        const template = Handlebars.templates[this.constructor.template];
        this.$el.html(template(data));
      }

      Adapt$1.trigger(`${type}View:render view:render`, this);

      _.defer(async () => {
        if (this._isRemoved) return;
        await this.postRender();
        Adapt$1.trigger(`${type}View:postRender view:postRender`, this);
      });

      return this;
    }

    changed() {
      let eventName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      if (!this.isJSX) {
        throw new Error('Cannot call changed on a non-react view');
      }

      if (typeof eventName === 'string' && eventName.startsWith('bubble')) {
        return;
      }

      const props = { ...this,
        ...this.model.toJSON(),
        _globals: Adapt$1.course.get('_globals')
      };
      const Template = templates[this.constructor.template.replace('.jsx', '')];
      this.updateViewProperties();
      ReactDOM__default["default"].render(React__default["default"].createElement(Template, props), this.el);
    }

    updateViewProperties() {
      const classesToAdd = _.result(this, 'className').trim().split(/\s+/);

      classesToAdd.forEach(i => this._classSet.add(i));
      const classesToRemove = [...this._classSet].filter(i => !classesToAdd.includes(i));
      classesToRemove.forEach(i => this._classSet.delete(i));

      this._setAttributes({ ..._.result(this, 'attributes'),
        id: _.result(this, 'id')
      });

      this.$el.removeClass(classesToRemove).addClass(classesToAdd);
    }

    setupOnScreenHandler() {
      const onscreen = this.model.get('_onScreen');
      if (!onscreen?._isEnabled) return;
      this.$el.addClass(`has-animation ${onscreen._classes}-before`);
      this.$el.on('onscreen.adaptView', (e, m) => {
        if (!m.onscreen) return;
        const minVerticalInview = onscreen._percentInviewVertical || 33;
        if (m.percentInviewVertical < minVerticalInview) return;
        this.$el.addClass(`${onscreen._classes}-after`).off('onscreen.adaptView');
      });
    }

    async addChildren() {
      this.nthChild = this.nthChild || 0;
      let addedCount = await this.addDescendants(false);

      while (true) {
        const models = this.model.getAvailableChildModels();

        const event = this._getAddChildEvent(models[this.nthChild]);

        if (!event) {
          break;
        }

        if (event.isForced) {
          event.reset();
        }

        if (event.isStoppedImmediate || !event.model) {
          const subsequentModels = models.slice(this.nthChild);
          subsequentModels.forEach(model => model.setOnChildren('_isRendered', false));
          break;
        }

        const model = event.model;
        model.set({
          _isRendered: true,
          _nthChild: ++this.nthChild
        });
        const ChildView = this.constructor.childView || components$1.getViewClass(model);

        if (!ChildView) {
          throw new Error(`The component '${model.attributes._id}' ('${model.attributes._component}') has not been installed, and so is not available in your project.`);
        }

        const childView = new ChildView({
          model
        });
        this.addChildView(childView);
        addedCount++;

        if (event.isStoppedNext) {
          break;
        }
      }

      if (!addedCount) {
        return addedCount;
      }

      this.model.set('_isReady', false);
      return addedCount;
    }

    addChildView(childView) {
      const childViews = this.getChildViews() || [];
      childViews.push(childView);
      this.setChildViews(childViews);
      const $parentContainer = this.$(this.constructor.childContainer);

      switch (childView.model.get('_renderPosition')) {
        case 'outer-append':
          this.$el.append(childView.$el);
          break;

        case 'inner-append':
        default:
          $parentContainer.append(childView.$el);
          break;
      }

      Adapt$1.trigger('view:childAdded', this, childView);
      return childView;
    }

    async addDescendants() {
      let addedDescendantCount = 0;
      const childViews = this.getChildViews();

      if (!childViews) {
        return addedDescendantCount;
      }

      for (let i = 0, l = childViews.length; i < l; i++) {
        const view = childViews[i];
        addedDescendantCount = view.addChildren ? await view.addChildren() : 0;

        if (addedDescendantCount) {
          break;
        }
      }

      if (!addedDescendantCount) {
        this.model.checkReadyStatus();
        return addedDescendantCount;
      }

      this.model.set('_isReady', false);
      return addedDescendantCount;
    }

    async whenReady() {
      if (this.model.get('_isReady')) return;
      return new Promise(resolve => {
        const onReadyChange = (model, value) => {
          if (!value) return;
          this.stopListening(this.model, 'change:_isReady', onReadyChange);
          resolve();
        };

        this.listenTo(this.model, 'change:_isReady', onReadyChange);
        this.model.checkReadyStatus();
      });
    }

    _getAddChildEvent(model) {
      const isRequestChild = !model;
      const event = new ChildEvent(null, this, model);

      if (isRequestChild) {
        const canRequestChild = this.model.get('_canRequestChild');

        if (!canRequestChild) {
          return;
        }

        event.type = 'requestChild';
        Adapt$1.trigger('view:requestChild', event);

        if (!event.hasRequestChild) {
          event.close();
          return;
        }
      }

      event.type = 'addChild';
      Adapt$1.trigger('view:addChild', event);
      event.close();
      return event;
    }

    findDescendantViews(isParentFirst) {
      const descendants = [];
      const childViews = this.getChildViews();
      childViews?.forEach(view => {
        if (isParentFirst) descendants.push(view);
        const children = view.findDescendantViews?.(isParentFirst);
        if (children) descendants.push(...children);
        if (!isParentFirst) descendants.push(view);
      });
      return descendants;
    }

    setReadyStatus() {
      this.model.setReadyStatus();
    }

    setCompletionStatus() {
      this.model.setCompletionStatus();
    }

    resetCompletionStatus(type) {
      if (!this.model.get('_canReset')) return;
      const descendantComponents = this.model.findDescendantModels('component');

      if (descendantComponents.length === 0) {
        this.model.reset(type);
      } else {
        descendantComponents.forEach(model => model.reset(type));
      }
    }

    preRemove() {
      const type = this.constructor.type;
      Adapt$1.trigger(`${type}View:preRemove view:preRemove`, this);
    }

    remove() {
      const type = this.constructor.type;
      this.preRemove();
      Adapt$1.trigger(`${type}View:remove view:remove`, this);
      this._isRemoved = true;
      this.stopListening();
      wait$1.for(end => {
        if (this.isJSX) {
          ReactDOM__default["default"].unmountComponentAtNode(this.el);
        }

        this.$el.off('onscreen.adaptView');
        super.remove();

        _.defer(() => {
          Adapt$1.trigger(`${type}View:postRemove view:postRemove`, this);
        });

        end();
      });
      return this;
    }

    setVisibility() {
      return this.model.get('_isVisible') ? '' : 'u-visibility-hidden';
    }

    toggleVisibility() {
      this.$el.toggleClass('u-visibility-hidden', !this.model.get('_isVisible'));
    }

    setHidden() {
      return this.model.get('_isHidden') ? 'u-display-none' : '';
    }

    toggleHidden() {
      this.$el.toggleClass('u-display-none', this.model.get('_isHidden'));
    }

    onIsCompleteChange(model, isComplete) {
      this.$el.toggleClass('is-complete', isComplete);
    }

    getChildViews() {
      if (!this._childViews) return this._childViews;
      return Object.entries(this._childViews).map(_ref => {
        let [key, value] = _ref;
        return value;
      });
    }

    setChildViews(value) {
      this._childViews = value;
    }

    get childViews() {
      logging$1.deprecated('view.childViews use view.getChildViews() and view.setChildViews([])');

      if (Array.isArray(this._childViews)) {
        return _.indexBy(this._childViews, view => view.model.get('_id'));
      }

      return this._childViews;
    }

    set childViews(value) {
      logging$1.deprecated('view.childViews use view.getChildViews() and view.setChildViews([])');
      this.setChildViews(value);
    }

  }

  AdaptView.className = '';
  var AdaptView$1 = __AMD("core/js/views/adaptView", AdaptView);

  var ContentObjectView = __AMD("core/js/views/contentObjectView", class ContentObjectView extends AdaptView$1 {
    attributes() {
      return AdaptView$1.resultExtend('attributes', {
        role: 'main'
      }, this);
    }

    className() {
      return [this.constructor.type, 'contentobject', this.constructor.className, this.model.get('_id'), this.model.get('_classes'), this.setVisibility(), this.model.get('_isComplete') ? 'is-complete' : '', this.model.get('_isOptional') ? 'is-optional' : ''].filter(Boolean).join(' ');
    }

    preRender() {
      $.inview.lock(this.constructor.type + 'View');
      this.disableAnimation = Adapt$1.config.has('_disableAnimation') ? Adapt$1.config.get('_disableAnimation') : false;
      this.$el.css('opacity', 0);
      this.listenTo(this.model, 'change:_isReady', this.isReady);
      this._loadingErrorTimeout = setTimeout(() => data$1.logReadyError(this), 10000);
    }

    render() {
      const type = this.constructor.type;
      Adapt$1.trigger(`${type}View:preRender contentObjectView:preRender view:preRender`, this);

      if (this.isReact) {
        this.changed();
      } else {
        const data = this.model.toJSON();
        data.view = this;
        const template = Handlebars.templates[this.constructor.template];
        this.$el.html(template(data));
      }

      Adapt$1.trigger(`${type}View:render contentObjectView:render view:render`, this);

      _.defer(() => {
        if (this._isRemoved) return;
        this.postRender();
        Adapt$1.trigger(`${type}View:postRender contentObjectView:postRender view:postRender`, this);
      });

      return this;
    }

    async isReady() {
      if (!this.model.get('_isReady') || this._isTriggeredReady) return;
      this._isTriggeredReady = true;
      clearTimeout(this._loadingErrorTimeout);
      delete this._loadingErrorTimeout;
      const type = this.constructor.type;

      const performIsReady = async () => {
        Adapt$1.trigger(`${type}View:preReady contentObjectView:preReady view:preReady`, this);
        await wait$1.queue();
        $('.js-loading').hide();

        if (Adapt$1.get('_shouldContentObjectScrollTop') !== false) {
          $(window).scrollTop(0);
        }

        Adapt$1.trigger(`${type}View:ready contentObjectView:ready view:ready`, this);
        $.inview.unlock(`${type}View`);
        const styleOptions = {
          opacity: 1
        };

        if (this.disableAnimation) {
          this.$el.css(styleOptions);
          $.inview();

          _.defer(() => {
            Adapt$1.trigger(`${type}View:postReady contentObjectView:postReady view:postReady`, this);
          });
        } else {
          this.$el.velocity(styleOptions, {
            duration: 'fast',
            complete: () => {
              $.inview();
              Adapt$1.trigger(`${type}View:postReady contentObjectView:postReady view:postReady`, this);
            }
          });
        }

        $(window).scroll();
      };

      _.defer(performIsReady);
    }

    async renderTo(id) {
      const isRenderToSelf = id === this.model.get('_id');
      if (isRenderToSelf) return;
      let models = this.model.getAllDescendantModels(true).filter(model => model.get('_isAvailable'));
      const index = models.findIndex(model => model.get('_id') === id);

      if (index === -1) {
        throw new Error(`Cannot renderTo "${id}" as it isn't a descendant.`);
      }

      const model = models[index];

      if (model.get('_isRendered') && model.get('_isReady')) {
        return;
      }

      models = models.slice(0, index + 1);
      const isLocked = models.some(model => model.get('_isLocked'));
      if (isLocked) throw new Error(`Cannot renderTo ${id} as it is preceded by locked content`);

      const ids = _.indexBy(models, model => model.get('_id'));

      const forceUntilId = event => {
        const addingId = event.model.get('_id');
        if (!ids[addingId]) return;
        event.force();
        if (addingId !== id) return;
        Adapt$1.off('view:addChild', forceUntilId);
      };

      Adapt$1.on('view:addChild', forceUntilId);
      await this.addChildren();
      await this.whenReady();

      if (!model.get('_isRendered') || !model.get('_isReady')) {
        throw new Error(`Cannot renderTo "${id}".`);
      }
    }

    preRemove() {
      const type = this.constructor.type;
      Adapt$1.trigger(`${type}View:preRemove contentObjectView:preRemove view:preRemove`, this);
    }

    remove() {
      const type = this.constructor.type;
      this.preRemove();
      Adapt$1.trigger(`${type}View:remove contentObjectView:remove view:remove`, this);
      this._isRemoved = true;
      wait$1.for(end => {
        if (this.isReact) {
          ReactDOM__default["default"].unmountComponentAtNode(this.el);
        }

        this.$el.off('onscreen.adaptView');
        this.findDescendantViews().reverse().forEach(view => {
          view.remove();
        });
        this.setChildViews(null);
        super.remove();

        _.defer(() => {
          Adapt$1.trigger(`${type}View:postRemove contentObjectView:postRemove view:postRemove`, this);
          this.trigger('postRemove');
        });

        end();
      });
      return this;
    }

    destroy() {
      this.remove();

      if (Adapt$1.parentView === this) {
        Adapt$1.parentView = null;
      }
    }

  });

  class PageView extends ContentObjectView {
    remove() {
      if (this.$pageLabel) {
        this.$pageLabel.remove();
      }

      super.remove();
    }

  }

  Object.assign(PageView, {
    childContainer: '.article__container',
    type: 'page',
    template: 'page'
  });
  components$1.register('page', {
    view: PageView
  });
  __AMD("core/js/views/pageView", PageView);

  class ArticleView extends AdaptView$1 {
    className() {
      return ['article', this.model.get('_id'), this.model.get('_classes'), this.setVisibility(), this.setHidden(), this.model.get('_isComplete') ? 'is-complete' : '', this.model.get('_isOptional') ? 'is-optional' : ''].join(' ');
    }

  }

  Object.assign(ArticleView, {
    childContainer: '.block__container',
    type: 'article',
    template: 'article'
  });
  components$1.register('article', {
    view: ArticleView
  });
  var ArticleView$1 = __AMD("core/js/views/articleView", ArticleView);

  class BlockView extends AdaptView$1 {
    className() {
      return ['block', this.model.get('_id'), this.model.get('_classes'), this.setVisibility(), this.setHidden(), this.model.get('_isComplete') ? 'is-complete' : '', this.model.get('_isOptional') ? 'is-optional' : ''].join(' ');
    }

  }

  Object.assign(BlockView, {
    childContainer: '.component__container',
    type: 'block',
    template: 'block'
  });
  components$1.register('block', {
    view: BlockView
  });
  __AMD("core/js/views/blockView", BlockView);

  class MPABC extends Backbone.Controller {
    initialize() {
      this.listenTo(data$1, {
        loading: this.waitForDataLoaded,
        loaded: this.onDataLoaded
      });
      this.setupSubsetCollections();
    }

    waitForDataLoaded() {
      wait$1.begin();
    }

    onDataLoaded() {
      wait$1.end();
    }

    setupSubsetCollections() {
      Adapt$1.contentObjects = new AdaptSubsetCollection(null, {
        parent: data$1,
        model: ContentObjectModel
      });
      Adapt$1.articles = new AdaptSubsetCollection(null, {
        parent: data$1,
        model: ArticleModel$1
      });
      Adapt$1.blocks = new AdaptSubsetCollection(null, {
        parent: data$1,
        model: BlockModel$1
      });
      Adapt$1.components = new AdaptSubsetCollection(null, {
        parent: data$1,
        model: ComponentModel$1
      });
    }

  }

  const mpabc = new MPABC();
  var mpabc$1 = __AMD("core/js/mpabc", mpabc);

  var NotifyPushView = __AMD("core/js/views/notifyPushView", class NotifyPushView extends Backbone.View {
    className() {
      let classes = 'notify-push ';
      classes += this.model.get('_classes') || '';
      return classes;
    }

    attributes() {
      return {
        role: 'dialog',
        'aria-labelledby': 'notify-push-heading',
        'aria-modal': 'false'
      };
    }

    initialize() {
      this.listenTo(Adapt$1, {
        'notify:pushShown notify:pushRemoved': this.updateIndexPosition,
        remove: this.remove
      });
      this.listenTo(this.model.collection, {
        remove: this.updateIndexPosition,
        'change:_index': this.updatePushPosition
      });
      this.preRender();
      this.render();
    }

    events() {
      return {
        'click .js-notify-push-close-btn': 'closePush',
        'click .js-notify-push-inner': 'triggerEvent'
      };
    }

    preRender() {
      this.hasBeenRemoved = false;
    }

    render() {
      const data = this.model.toJSON();
      const template = Handlebars.templates.notifyPush;
      this.$el.html(template(data)).appendTo('.notify__push-container');

      _.defer(this.postRender.bind(this));

      return this;
    }

    postRender() {
      this.$el.addClass('is-active');

      _.delay(this.closePush.bind(this), this.model.get('_timeout'));

      Adapt$1.trigger('notify:pushShown');
    }

    closePush(event) {
      if (event) {
        event.preventDefault();
      }

      if (this.hasBeenRemoved === false) {
        this.hasBeenRemoved = true;
        this.$el.removeClass('is-active');

        _.delay(() => {
          this.model.collection.remove(this.model);
          Adapt$1.trigger('notify:pushRemoved', this);
          this.remove();
        }, 600);
      }
    }

    triggerEvent(event) {
      Adapt$1.trigger(this.model.get('_callbackEvent'));
      this.closePush();
    }

    updateIndexPosition() {
      if (this.hasBeenRemoved) return;
      const models = this.model.collection.models;
      models.forEach((model, index) => {
        if (!model.get('_isActive')) return;
        model.set('_index', index);
        this.updatePushPosition();
      });
    }

    updatePushPosition() {
      if (this.hasBeenRemoved) {
        return;
      }

      if (typeof this.model.get('_index') !== 'undefined') {
        const elementHeight = this.$el.height();
        const offset = 20;
        const navigationHeight = $('.nav').height();
        const currentIndex = this.model.get('_index');
        let flippedIndex = currentIndex === 0 ? 1 : 0;

        if (this.model.collection.where({
          _isActive: true
        }).length === 1) {
          flippedIndex = 0;
        }

        const positionLowerPush = (elementHeight + offset) * flippedIndex + navigationHeight + offset;
        this.$el.css('top', positionLowerPush);
      }
    }

  });

  var NotifyModel = __AMD("core/js/models/notifyModel", class NotifyModel extends LockingModel {
    defaults() {
      return {
        _isActive: false,
        _showIcon: false,
        _timeout: 3000
      };
    }

  });

  var NotifyPushCollection = __AMD("core/js/collections/notifyPushCollection", class NotifyPushCollection extends Backbone.Collection {
    initialize() {
      this.model = NotifyModel;
      this.listenTo(this, 'add', this.onPushAdded);
      this.listenTo(Adapt$1, 'notify:pushRemoved', this.onRemovePush);
    }

    onPushAdded(model) {
      this.checkPushCanShow(model);
    }

    checkPushCanShow(model) {
      if (!this.canShowPush()) return;
      model.set('_isActive', true);
      this.showPush(model);
    }

    canShowPush() {
      const availablePushNotifications = this.where({
        _isActive: true
      });
      return availablePushNotifications.length < 2;
    }

    showPush(model) {
      new NotifyPushView({
        model: model
      });
    }

    onRemovePush(view) {
      const inactivePushNotifications = this.where({
        _isActive: false
      });

      if (inactivePushNotifications.length > 0) {
        this.checkPushCanShow(inactivePushNotifications[0]);
      }
    }

  });

  var NotifyPopupView = __AMD("core/js/views/notifyPopupView", class NotifyPopupView extends Backbone__default["default"].View {
    className() {
      return `notify ${this.model.get('_classes') || ''}`;
    }

    attributes() {
      return Object.assign({
        role: 'dialog',
        'aria-labelledby': 'notify-heading',
        'aria-modal': 'true'
      }, this.model.get('_attributes'));
    }

    events() {
      return {
        'click .js-notify-btn-alert': 'onAlertButtonClicked',
        'click .js-notify-btn-prompt': 'onPromptButtonClicked',
        'click .js-notify-close-btn': 'onCloseButtonClicked',
        'click .js-notify-shadow-click': 'onShadowClicked'
      };
    }

    initialize(_ref) {
      let {
        notify
      } = _ref;
      this.notify = notify;

      _.bindAll(this, 'resetNotifySize', 'onKeyUp');

      this.disableAnimation = Adapt$1.config.get('_disableAnimation') || false;
      this.isOpen = false;
      this.hasOpened = false;
      this.setupEventListeners();
      this.render();
    }

    setupEventListeners() {
      this.listenTo(Adapt$1, {
        remove: this.closeNotify,
        'notify:resize': this.resetNotifySize,
        'notify:cancel': this.cancelNotify,
        'notify:close': this.closeNotify,
        'device:resize': this.resetNotifySize
      });
      this.setupEscapeKey();
    }

    setupEscapeKey() {
      $(window).on('keyup', this.onKeyUp);
    }

    onKeyUp(event) {
      if (event.which !== 27) return;
      event.preventDefault();
      this.cancelNotify();
    }

    render() {
      const data = this.model.toJSON();
      const template = Handlebars.templates.notifyPopup;
      this.$el.css('visibility', 'hidden');
      this.$el.html(template(data)).appendTo('.notify__popup-container');
      this.$('.notify__popup').css('visibility', 'hidden');
      this.$el.css('visibility', 'visible');
      this.showNotify();
      return this;
    }

    onAlertButtonClicked(event) {
      event.preventDefault();
      this.closeNotify();
      Adapt$1.trigger(this.model.get('_callbackEvent'), this);
    }

    onPromptButtonClicked(event) {
      event.preventDefault();
      this.closeNotify();
      Adapt$1.trigger($(event.currentTarget).attr('data-event'), this);
    }

    onCloseButtonClicked(event) {
      event.preventDefault();
      this.cancelNotify();
    }

    onShadowClicked(event) {
      event.preventDefault();
      if (this.model.get('_closeOnShadowClick') === false) return;
      this.cancelNotify();
    }

    cancelNotify() {
      if (this.model.get('_isCancellable') === false) return;
      this.closeNotify();
      Adapt$1.trigger('notify:cancelled', this);
    }

    resetNotifySize() {
      if (!this.hasOpened) return;
      this.resizeNotify();
    }

    resizeNotify() {
      const windowHeight = $(window).height();
      const notifyHeight = this.$('.notify__popup-inner').outerHeight();
      const isFullWindow = notifyHeight >= windowHeight;
      this.$('.notify__popup').css({
        height: isFullWindow ? '100%' : 'auto',
        top: isFullWindow ? 0 : '',
        'margin-top': isFullWindow ? '' : -(notifyHeight / 2),
        'overflow-y': isFullWindow ? 'scroll' : '',
        '-webkit-overflow-scrolling': isFullWindow ? 'touch' : ''
      });
    }

    async showNotify() {
      this.isOpen = true;
      await this.addSubView();
      this.notify.stack.push(this);
      this.$previousActiveElement = $(document.activeElement);
      Adapt$1.trigger('notify:opened', this);
      this.$el.imageready(this.onLoaded.bind(this));
    }

    onLoaded() {
      if (this.disableAnimation) {
        this.$('.notify__shadow').css('display', 'block');
      } else {
        this.$('.notify__shadow').velocity({
          opacity: 0
        }, {
          duration: 0
        }).velocity({
          opacity: 1
        }, {
          duration: 400,
          begin: () => {
            this.$('.notify__shadow').css('display', 'block');
          }
        });
      }

      this.resizeNotify();

      if (this.disableAnimation) {
        this.$('.notify__popup').css('visibility', 'visible');
        this.onOpened();
      } else {
        this.$('.notify__popup').velocity({
          opacity: 0
        }, {
          duration: 0
        }).velocity({
          opacity: 1
        }, {
          duration: 400,
          begin: () => {
            this.$('.notify__popup').css('visibility', 'visible');
            this.onOpened();
          }
        });
      }
    }

    onOpened() {
      $.inview();
      this.hasOpened = true;
      a11y$1.popupOpened(this.$el);
      a11y$1.scrollDisable('body');
      $('html').addClass('notify');
      a11y$1.focusFirst(this.$('.notify__popup'), {
        defer: false
      });
    }

    async addSubView() {
      this.subView = this.model.get('_view');

      if (this.model.get('_shouldRenderId') && this.model.get('_id')) {
        const model = data$1.findById(this.model.get('_id'));
        const View = components$1.getViewClass(model);
        this.subView = new View({
          model
        });
      }

      if (!this.subView) return;
      this.subView.$el.on('resize', this.resetNotifySize);
      this.$('.notify__content-inner').append(this.subView.$el);
      if (!(this.subView instanceof AdaptView$1) || this.subView.model.get('_isReady')) return;
      return new Promise(resolve => {
        const check = (model, value) => {
          if (!value) return;
          this.subView.model.off('change:_isReady', check);
          resolve();
        };

        this.subView.model.on('change:_isReady', check);
      });
    }

    closeNotify() {
      const stackItem = this.notify.stack[this.notify.stack.length - 1];
      if (this !== stackItem) return;
      this.notify.stack.pop();
      if (!this.isOpen) return;
      this.isOpen = false;

      if (this.hasOpened) {
        this.onCloseReady();
        return;
      }

      this.listenToOnce(Adapt$1, 'popup:opened', () => {
        _.defer(this.onCloseReady.bind(this));
      });
    }

    onCloseReady() {
      if (this.disableAnimation) {
        this.$('.notify__popup').css('visibility', 'hidden');
        this.$el.css('visibility', 'hidden');
        this.remove();
      } else {
        this.$('.notify__popup').velocity({
          opacity: 0
        }, {
          duration: 400,
          complete: () => {
            this.$('.notify__popup').css('visibility', 'hidden');
          }
        });
        this.$('.notify__shadow').velocity({
          opacity: 0
        }, {
          duration: 400,
          complete: () => {
            this.$el.css('visibility', 'hidden');
            this.remove();
          }
        });
      }

      a11y$1.scrollEnable('body');
      $('html').removeClass('notify');
      a11y$1.popupClosed(this.$previousActiveElement);
      Adapt$1.trigger('notify:closed', this);
    }

    remove() {
      this.removeSubView();
      $(window).off('keyup', this.onKeyUp);
      super.remove(...arguments);
    }

    removeSubView() {
      if (!this.subView) return;
      this.subView.$el.off('resize', this.resetNotifySize);

      if (this.subView instanceof AdaptView$1) {
        const views = [...this.subView.findDescendantViews(), this.subView];
        views.forEach(view => {
          view.model.set('_isReady', false);
          view.remove();
        });
      } else {
        this.subView.remove();
      }

      this.subView = null;
    }

  });

  var NotifyView = __AMD("core/js/views/notifyView", class NotifyView extends Backbone.View {
    className() {
      return 'notify__container';
    }

    initialize() {
      this._stack = [];
      this.notifyPushes = new NotifyPushCollection();
      this.listenTo(Adapt$1, {
        'notify:popup': this._deprecated.bind(this, 'popup'),
        'notify:alert': this._deprecated.bind(this, 'alert'),
        'notify:prompt': this._deprecated.bind(this, 'prompt'),
        'notify:push': this._deprecated.bind(this, 'push')
      });
      this.render();
    }

    get stack() {
      return this._stack;
    }

    get isOpen() {
      return this.stack.length > 0;
    }

    _deprecated(type, notifyObject) {
      logging$1.deprecated(`NOTIFY DEPRECATED: Adapt.trigger('notify:${type}', notifyObject); is no longer supported, please use notify.${type}(notifyObject);`);
      return this.create(notifyObject, {
        _type: type
      });
    }

    render() {
      const notifyTemplate = Handlebars.templates.notify;
      this.$el.html(notifyTemplate());
      this.$el.appendTo('body');
    }

    create(notifyObject, defaults) {
      notifyObject = _.defaults({}, notifyObject, defaults, {
        _type: 'popup',
        _shouldRenderId: false,
        _isCancellable: true,
        _showCloseButton: true,
        _closeOnShadowClick: true
      });

      if (notifyObject._type === 'push') {
        this.notifyPushes.push(notifyObject);
        return;
      }

      return new NotifyPopupView({
        model: new NotifyModel(notifyObject),
        notify: this
      });
    }

    popup(notifyObject) {
      return this.create(notifyObject, {
        _type: 'popup'
      });
    }

    alert(notifyObject) {
      return this.create(notifyObject, {
        _type: 'alert'
      });
    }

    prompt(notifyObject) {
      return this.create(notifyObject, {
        _type: 'prompt'
      });
    }

    push(notifyObject) {
      return this.create(notifyObject, {
        _type: 'push'
      });
    }

  });

  const notify = new NotifyView();
  var notify$1 = __AMD("core/js/notify", notify);

  var RouterModel = __AMD("core/js/models/routerModel", class RouterModel extends LockingModel {
    defaults() {
      return {
        _canNavigate: true,
        _shouldNavigateFocus: true
      };
    }

    lockedAttributes() {
      return {
        _canNavigate: false,
        _shouldNavigateFocus: false
      };
    }

  });

  class Router extends Backbone.Router {
    routes() {
      return {
        '': 'handleRoute',
        'id/:id': 'handleRoute',
        ':pluginName(/*location)(/*action)': 'handleRoute'
      };
    }

    initialize(_ref) {
      let {
        model
      } = _ref;
      this.navigateToElement = this.navigateToElement.bind(this);
      this._isBackward = false;
      this.model = model;
      this._navigationRoot = null;
      this._isCircularNavigationInProgress = false;
      this.showLoading();
      this.$wrapper = $('#wrapper');
      this.$html = $('html');
      this.listenToOnce(Adapt$1, 'app:dataReady', this.setDocumentTitle);
      this.listenTo(Adapt$1, 'router:navigateTo', this.navigateToArguments);
    }

    get rootModel() {
      return this._navigationRoot || Adapt$1.course;
    }

    set rootModel(model) {
      this._navigationRoot = model;
    }

    showLoading() {
      $('.js-loading').show();
    }

    hideLoading() {
      $('.js-loading').hide();
    }

    setDocumentTitle() {
      const currentModel = location$2._currentModel;
      const hasSubTitle = currentModel && currentModel !== router.rootModel && currentModel.get('title');
      const title = [this.rootModel.get('title'), hasSubTitle && currentModel.get('title')].filter(Boolean).join(' | ');
      this.listenToOnce(Adapt$1, 'contentObjectView:preRender', () => {
        const escapedTitle = $(`<div>${title}</div>`).text();
        document.title = escapedTitle;
      });
    }

    navigateToArguments(args) {
      args = args.filter(v => v !== null);
      const options = {
        trigger: false,
        replace: false
      };

      if (args.length === 1 && data$1.findById(args[0])) {
        this.navigate('#/id/' + args[0], options);
        return;
      }

      if (args.length <= 3) {
        this.navigate('#/' + args.join('/'), options);
        return;
      }

      logging$1.deprecated('Use Backbone.history.navigate or window.location.href instead of Adapt.trigger(\'router:navigateTo\')');
      this.handleRoute(...args);
    }

    handleRoute() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      args = args.filter(v => v !== null);

      if (this.model.get('_canNavigate')) {
        this._isCircularNavigationInProgress = false;
      }

      if (this._isCircularNavigationInProgress === false) {
        Adapt$1.trigger('router:navigate', args);
      }

      if (this.model.get('_canNavigate')) {
        this.model.set('_canNavigate', false, {
          pluginName: 'adapt'
        });
        this._isBackward = false;

        if (args.length <= 1) {
          return this.handleId(...args);
        }

        return this.handlePluginRouter(...args);
      }

      if (this._isCircularNavigationInProgress) {
        this._isCircularNavigationInProgress = false;
        return;
      }

      this._isCircularNavigationInProgress = true;
      Adapt$1.trigger('router:navigationCancelled', args);
      Backbone.history.history[this._isBackward ? 'forward' : 'back']();
      this._isBackward = false;
    }

    async handlePluginRouter(pluginName, location, action) {
      const pluginLocation = [pluginName, location && `-${location}`, action && `-${action}`].filter(Boolean).join('');
      await this.updateLocation(pluginLocation, null, null, null);
      Adapt$1.trigger('router:plugin:' + pluginName, pluginName, location, action);
      Adapt$1.trigger('router:plugin', pluginName, location, action);
      this.model.set('_canNavigate', true, {
        pluginName: 'adapt'
      });
    }

    async handleId(id) {
      const rootModel = router.rootModel;
      let model = !id ? rootModel : data$1.findById(id);

      if (!model) {
        this.model.set('_canNavigate', true, {
          pluginName: 'adapt'
        });
        return;
      }

      const isContentObject = model.isTypeGroup?.('contentobject');
      const navigateToId = model.get('_id');
      model = isContentObject ? model : model.findAncestor('contentobject');
      id = model.get('_id');
      const isRoot = model === rootModel;

      if (isRoot && Adapt$1.course.has('_start')) {
        const startController = Adapt$1.course.get('_start');

        if (startController._isEnabled === true && startController._isMenuDisabled === true) {
          return;
        }
      }

      if (model.get('_isLocked') && Adapt$1.config.get('_forceRouteLocking')) {
        logging$1.warn('Unable to navigate to locked id: ' + id);
        this.model.set('_canNavigate', true, {
          pluginName: 'adapt'
        });

        if (location$2._previousId === undefined) {
          return this.navigate('#/', {
            trigger: true,
            replace: true
          });
        }

        return this.navigateBack();
      }

      this.showLoading();
      await Adapt$1.remove();
      const isCourse = model.isTypeGroup?.('course');
      const type = isCourse ? 'menu' : model.get('_type');
      const newLocation = isCourse ? 'course' : `${type}-${id}`;
      model.set('_isVisited', true);
      await this.updateLocation(newLocation, type, id, model);
      Adapt$1.once('contentObjectView:ready', () => {
        this.model.set('_canNavigate', true, {
          pluginName: 'adapt'
        });
        this.handleNavigationFocus();
      });
      Adapt$1.trigger(`router:${type} router:contentObject`, model);
      const ViewClass = components$1.getViewClass(model);
      const isMenu = model.isTypeGroup?.('menu');

      if (!ViewClass && isMenu) {
        logging$1.deprecated(`Using event based menu view instantiation for '${components$1.getViewName(model)}'`);
        return;
      }

      if (!isMenu) {
        _.invoke(model.getAllDescendantModels(), 'checkIfResetOnRevisit');

        await Adapt$1.deferUntilCompletionChecked();
      }

      this.$wrapper.append(new ViewClass({
        model
      }).$el);

      if (!isContentObject && !this.isScrolling) {
        await this.navigateToElement('.' + navigateToId, {
          replace: true,
          duration: 400
        });
      }
    }

    async updateLocation(currentLocation, type, id, currentModel) {
      location$2._previousModel = location$2._currentModel;
      location$2._previousId = location$2._currentId;
      location$2._previousContentType = location$2._contentType;
      location$2._currentModel = currentModel;
      location$2._currentId = id;
      location$2._contentType = type;
      location$2._currentLocation = currentLocation;

      if (type === 'menu') {
        location$2._lastVisitedType = 'menu';
        location$2._lastVisitedMenu = id;
      } else if (type === 'page') {
        location$2._lastVisitedType = 'page';
        location$2._lastVisitedPage = id;
      }

      this.setDocumentTitle();
      this.setGlobalClasses();
      Adapt$1.trigger('router:location', location$2);
      await wait$1.queue();
    }

    setGlobalClasses() {
      const currentModel = location$2._currentModel;
      const htmlClasses = currentModel?.get('_htmlClasses') || '';
      const classes = location$2._currentId ? `location-${location$2._contentType} location-id-${location$2._currentId}` : `location-${location$2._currentLocation}`;
      const currentClasses = `${classes} ${htmlClasses}`;
      this.$html.removeClass(location$2._previousClasses).addClass(currentClasses).attr('data-location', location$2._currentLocation);
      this.$wrapper.removeClass().addClass(classes).attr('data-location', location$2._currentLocation);
      location$2._previousClasses = currentClasses;
    }

    handleNavigationFocus() {
      if (!this.model.get('_shouldNavigateFocus')) return;
      a11y$1.focus('body');
    }

    navigateBack() {
      this._isBackward = true;
      Backbone.history.history.back();
    }

    navigateToCurrentRoute(force) {
      if (!this.model.get('_canNavigate') && !force) {
        return;
      }

      if (!location$2._currentId) {
        return;
      }

      const currentId = location$2._currentModel.get('_id');

      const isRoot = location$2._currentModel === this.rootModel;
      const route = isRoot ? '#/' : '#/id/' + currentId;
      this.navigate(route, {
        trigger: true,
        replace: true
      });
    }

    navigateToPreviousRoute(force) {
      if (!this.model.get('_canNavigate') && !force) {
        return;
      }

      const currentModel = location$2._currentModel;
      const previousModel = location$2._previousModel;

      if (!currentModel) {
        return this.navigateBack();
      }

      if (location$2._currentModel?.isTypeGroup('menu')) {
        return this.navigateToParent();
      }

      if (previousModel) {
        return this.navigateBack();
      }

      this.navigateToParent();
    }

    navigateToParent(force) {
      if (!this.model.get('_canNavigate') && !force) {
        return;
      }

      const parentId = location$2._currentModel.get('_parentId');

      const parentModel = data$1.findById(parentId);
      const isRoot = parentModel === this.rootModel;
      const route = isRoot ? '#/' : '#/id/' + parentId;
      this.navigate(route, {
        trigger: true
      });
    }

    navigateToHomeRoute(force) {
      if (!this.model.get('_canNavigate') && !force) {
        return;
      }

      this.navigate('#/', {
        trigger: true
      });
    }

    async navigateToElement(selector) {
      let settings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      const currentModelId = typeof selector === 'string' && selector.replace(/\./g, '').split(' ')[0];
      const isSelectorAnId = data$1.hasId(currentModelId);

      if (isSelectorAnId) {
        const currentModel = data$1.findById(currentModelId);
        const contentObject = currentModel.isTypeGroup?.('contentobject') ? currentModel : currentModel.findAncestor('contentobject');
        const contentObjectId = contentObject.get('_id');
        const isNotInCurrentContentObject = contentObjectId !== location$2._currentId;

        if (currentModel && (!currentModel.get('_isRendered') || !currentModel.get('_isReady') || isNotInCurrentContentObject)) {
          const shouldReplace = settings.replace || false;

          if (isNotInCurrentContentObject) {
            this.isScrolling = true;
            this.navigate(`#/id/${currentModelId}`, {
              trigger: true,
              replace: shouldReplace
            });
            this.model.set('_shouldNavigateFocus', false, {
              pluginName: 'adapt'
            });
            await new Promise(resolve => Adapt$1.once('contentObjectView:ready', _.debounce(() => {
              this.model.set('_shouldNavigateFocus', true, {
                pluginName: 'adapt'
              });
              resolve();
            }, 1)));
            this.isScrolling = false;
          }

          await Adapt$1.parentView.renderTo(currentModelId);
        }

        if (currentModel && selector === currentModel.get('_id')) {
          selector = `.${selector}`;
        }
      }

      const isElementUnavailable = !$(selector).length;

      if (isElementUnavailable) {
        logging$1.warn(`router.navigateToElement, selector not found in document: ${selector}`);
        return;
      }

      const newLocation = location$2._contentType ? location$2._contentType : location$2._currentLocation;
      Adapt$1.trigger(`${newLocation}:scrollTo`, selector);
      const disableScrollToAnimation = Adapt$1.config.has('_disableAnimation') ? Adapt$1.config.get('_disableAnimation') : false;

      if (disableScrollToAnimation) {
        settings.duration = 0;
      } else if (!settings.duration) {
        settings.duration = $.scrollTo.defaults.duration;
      }

      const $wrapper = $('#wrapper');
      let offsetTop = -parseInt($wrapper.css('padding-top'));

      if ($(selector).hasClass('component')) {
        offsetTop -= $(selector).find('.aria-label').height() || 0;
      }

      if (!settings.offset) settings.offset = {
        top: offsetTop,
        left: 0
      };
      if (settings.offset.top === undefined) settings.offset.top = offsetTop;
      if (settings.offset.left === undefined) settings.offset.left = 0;
      if (settings.offset.left === 0) settings.axis = 'y';

      if (Adapt$1.get('_canScroll') !== false) {
        $.scrollTo(selector, settings);
      }

      await new Promise(resolve => {
        _.delay(() => {
          a11y$1.focusNext(selector);
          Adapt$1.trigger(`${location$2}:scrolledTo`, selector);
          resolve();
        }, settings.duration + 300);
      });
    }

    get() {
      logging$1.deprecated('router.get, please use router.model.get');
      return this.model.get(...arguments);
    }

    set() {
      logging$1.deprecated('router.set, please use router.model.set');
      return this.model.set(...arguments);
    }

  }

  const router = new Router({
    model: new RouterModel(null, {
      reset: true
    })
  });
  var router$1 = __AMD("core/js/router", router);

  class Scrolling extends Backbone.Controller {
    initialize() {
      this.scrollTo = this.scrollTo.bind(this);
      this.$html = $('html');
      this.isLegacyScrolling = true;
      Adapt$1.once('configModel:dataLoaded', this._loadConfig.bind(this));
    }

    _loadConfig() {
      const config = Adapt$1.config.get('_scrollingContainer');
      if (!config?._isEnabled) return;
      const limitTo = config._limitToSelector;
      const isIncluded = !limitTo || this.$html.is(limitTo) || this.$html.hasClass(limitTo);
      if (!isIncluded) return;
      this.isLegacyScrolling = false;

      this._windowScrollFix();

      this._addStyling();

      this._updateScrollbarWidth();

      this.listenTo(Adapt$1, 'device:resize', this._updateScrollbarWidth);
    }

    _addStyling() {
      this.$html.addClass('adapt-scrolling');
    }

    _updateScrollbarWidth() {
      const $tester = $('<div class="outer" style="overflow:scroll; visibility: hidden; position:fixed; top: 0; left: 0;"><div class="inner"> </div></div>"');
      $('body').append($tester);
      const scrollBarWidth = $tester.outerWidth() - $tester.find('.inner').outerWidth();
      $tester.remove();
      const documentStyle = document.documentElement.style;
      documentStyle.setProperty('--adapt-scrollbar-width', `${scrollBarWidth}px`);
    }

    _windowScrollFix() {
      const body = document.body;
      const html = Adapt$1.scrolling.$html[0];
      const scrollY = {
        get: () => body.scrollTop,
        set: value => body.scrollTop = value
      };
      const scrollX = {
        get: () => body.scrollLeft,
        set: value => body.scrollLeft = value
      };
      const scrollHeight = {
        get: () => body.scrollHeight,
        set: value => body.scrollHeight = value
      };
      const scrollWidth = {
        get: () => body.scrollWidth,
        set: value => body.scrollWidth = value
      };
      Object.defineProperties(window, {
        scrollY,
        scrollX,
        pageYOffset: scrollY,
        pageXOffset: scrollX
      });
      Object.defineProperties(html, {
        scrollHeight,
        scrollWidth
      });

      window.scrollTo = function () {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        const isObject = args.length === 1 && typeof args[0] === 'object' && args[0] !== null;
        const left = (isObject ? args[0].left : args[0]) ?? null;
        const top = (isObject ? args[0].top : args[1]) ?? null;
        left !== null && (body.scrollLeft = left);
        top !== null && (body.scrollTop = top);
      };

      const MouseEvent = window.MouseEvent;
      Object.defineProperties(MouseEvent.prototype, {
        pageX: {
          get: function () {
            return this.clientX + scrollX.get();
          }
        },
        pageY: {
          get: function () {
            return this.clientY + scrollY.get();
          }
        }
      });
      const $window = $(window);
      $(document.body).on('scroll', () => $window.scroll());
    }

    async scrollTo(selector) {
      let settings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      logging$1.deprecated('Adapt.scrollTo and Adapt.scrolling.scrollTo, use router.navigateToElement instead.');
      return router$1.navigateToElement(selector, settings);
    }

  }

  const scrolling = new Scrolling();
  var scrolling$1 = __AMD("core/js/scrolling", scrolling);

  class StartController extends Backbone.Controller {
    initialize() {
      super.initialize(...arguments);
      this.model = null;
    }

    loadCourseData() {
      this.model = new LockingModel(Adapt$1.course.get('_start'));
    }

    setStartLocation() {
      if (!this.isEnabled()) return;
      window.history.replaceState('', '', this.getStartHash());
    }

    returnToStartLocation() {
      const startIds = this.model.get('_startIds');

      if (startIds) {
        startIds.forEach(startId => startId._skipIfComplete = false);
      }

      window.location.hash = this.getStartHash(true);
    }

    getStartHash(alwaysForce) {
      const startId = this.getStartId();
      const isRouteSpecified = window.location.href.indexOf('#') > -1;
      const shouldForceStartId = alwaysForce || this.model.get('_force');
      const shouldNavigateToStartId = startId && (!isRouteSpecified || shouldForceStartId);

      if (shouldNavigateToStartId && startId !== Adapt$1.course.get('_id')) {
        return '#/id/' + startId;
      }

      return window.location.hash || '#/';
    }

    isEnabled() {
      return Boolean(this.model?.get('_isEnabled'));
    }

    getStartId() {
      let startId = this.model.get('_id');
      const startIds = this.model.get('_startIds');
      if (!startIds?.length) return startId;
      const $html = $('html');

      for (let i = 0, l = startIds.length; i < l; i++) {
        const item = startIds[i];
        const className = item._className;
        const skipIfComplete = item._skipIfComplete;
        const model = data$1.findById(item._id);

        if (!model) {
          console.log('startController: cannot find id', item._id);
          continue;
        }

        if (skipIfComplete) {
          if (model.get('_isComplete')) continue;
        }

        if (!className || $html.is(className) || $html.hasClass(className)) {
          startId = item._id;
          break;
        }
      }

      return startId;
    }

  }

  Adapt$1.once('adapt:start', () => {
    startController.loadCourseData();
    startController.setStartLocation();
  });
  Adapt$1.on('navigation:returnToStart', () => {
    startController.returnToStartLocation();
  });
  Adapt$1.on('app:languageChanged', () => {
    wait$1.for(done => {
      startController.loadCourseData();
      const hash = startController.isEnabled() ? startController.getStartHash(false) : '#/';
      router$1.navigate(hash, {
        trigger: true,
        replace: true
      });
      done();
    });
  });
  const startController = new StartController();
  var startController$1 = __AMD("core/js/startController", startController);

  const COMPLETION_STATE = ENUM(['INCOMPLETE', 'COMPLETED', 'PASSED', 'FAILED']);
  var COMPLETION_STATE$1 = __AMD("core/js/enums/completionStateEnum", COMPLETION_STATE);

  class Tracking extends Backbone.Controller {
    initialize() {
      this._config = {
        _requireContentCompleted: true,
        _requireAssessmentCompleted: false,
        _shouldSubmitScore: false
      };
      this._assessmentState = null;
      Adapt$1.once('configModel:dataLoaded', this.loadConfig.bind(this));
      Adapt$1.on('app:dataReady', this.setupEventListeners.bind(this));
    }

    setupEventListeners() {
      this.listenTo(Adapt$1, {
        'assessment:complete': this.onAssessmentComplete,
        'assessment:restored': this.onAssessmentRestored
      });

      if (this._config._requireContentCompleted) {
        this.listenTo(Adapt$1.course, 'change:_isComplete', this.checkCompletion);
      }
    }

    onAssessmentComplete(assessmentState) {
      this._assessmentState = assessmentState;
      this.submitScore();

      if (this._config._requireAssessmentCompleted) {
        this.checkCompletion();
      }
    }

    submitScore() {
      if (!this._config._shouldSubmitScore) return;

      if (this._assessmentState.isPercentageBased) {
        offlineStorage$3.set('score', this._assessmentState.scoreAsPercent, 0, 100);
        return;
      }

      offlineStorage$3.set('score', this._assessmentState.score, this._assessmentState.minScore, this._assessmentState.maxScore);
    }

    onAssessmentRestored(assessmentState) {
      this._assessmentState = assessmentState;
    }

    checkCompletion() {
      const completionData = this.getCompletionData();

      if (completionData.status === COMPLETION_STATE$1.INCOMPLETE) {
        return;
      }

      const canRetry = completionData.assessment?.canRetry === true;

      if (completionData.status === COMPLETION_STATE$1.FAILED && canRetry) {
        return;
      }

      Adapt$1.trigger('tracking:complete', completionData);
      logging$1.debug('tracking:complete', completionData);
    }

    getCompletionData() {
      const completionData = {
        status: COMPLETION_STATE$1.INCOMPLETE,
        assessment: null
      };

      if (this._config._requireContentCompleted && !Adapt$1.course.get('_isComplete')) {
        return completionData;
      }

      if (this._config._requireAssessmentCompleted) {
        if (!this._assessmentState) {
          return completionData;
        }

        completionData.status = this._assessmentState.isPass ? COMPLETION_STATE$1.PASSED : COMPLETION_STATE$1.FAILED;
        completionData.assessment = this._assessmentState;
        return completionData;
      }

      completionData.status = COMPLETION_STATE$1.COMPLETED;
      return completionData;
    }

    loadConfig() {
      this._config = Adapt$1.config.get('_completionCriteria') ?? this._config;
      const newShouldSubmitScore = this._config._shouldSubmitScore;
      const legacyShouldSubmitScore = Adapt$1.config.get('_spoor')?._tracking?._shouldSubmitScore;
      if (legacyShouldSubmitScore !== undefined) logging$1.deprecated('config.json:_spoor._tracking._shouldSubmitScore, please use only config.json:_completionCriteria._shouldSubmitScore');
      this._config._shouldSubmitScore = legacyShouldSubmitScore ?? newShouldSubmitScore ?? true;
    }

  }

  const tracking = new Tracking();
  var tracking$1 = __AMD("core/js/tracking", tracking);

  const beginWait = () => {
    logging$1.deprecated('Use wait.begin() as Adapt.trigger(\'plugin:beginWait\') will be removed in the future');
    wait$1.begin();
  };

  const endWait = () => {
    logging$1.deprecated('Use wait.end() as Adapt.trigger(\'plugin:endWait\') will be removed in the future');
    wait$1.end();
  };

  const ready = () => {
    if (wait$1.isWaiting()) {
      return;
    }

    const isEventListening = Adapt$1._events['plugins:ready'];

    if (!isEventListening) {
      return;
    }

    logging$1.deprecated("Use wait.queue(callback) as Adapt.on('plugins:ready', callback) will be removed in the future");
    Adapt$1.trigger('plugins:ready');
  };

  Adapt$1.listenTo(wait$1, 'ready', ready);
  Adapt$1.on({
    'plugin:beginWait': beginWait,
    'plugin:endWait': endWait
  });
  Object.defineProperties(Adapt$1, {
    accessibility: {
      get() {
        a11y$1.log.deprecated('Adapt.accessibility has moved to a11y');
        return a11y$1;
      }

    },
    a11y: {
      get() {
        logging$1.deprecated('Adapt.a11y, please use core/js/a11y directly');
        return a11y$1;
      }

    },
    componentStore: {
      get() {
        logging$1.deprecated('Adapt.componentStore, please use core/js/components directly');
        return components$1._register;
      }

    },
    data: {
      get() {
        logging$1.deprecated('Adapt.data, please use core/js/data directly');
        return data$1;
      }

    },
    device: {
      get() {
        logging$1.deprecated('device, please use core/js/device directly');
        return device$1;
      }

    },
    drawer: {
      get() {
        logging$1.deprecated('Adapt.drawer, please use core/js/drawer directly');
        return drawer;
      }

    },
    findById: {
      get() {
        logging$1.deprecated('Adapt.findById, please use data.findById directly');
        return data$1.findById;
      }

    },
    findViewByModelId: {
      get() {
        logging$1.deprecated('Adapt.findViewByModelId, please use data.findViewByModelId directly');
        return data$1.findViewByModelId;
      }

    },
    findByTrackingPosition: {
      get() {
        logging$1.deprecated('Adapt.findByTrackingPosition, please use data.findByTrackingPosition directly');
        return data$1.findByTrackingPosition;
      }

    },
    getViewName: {
      get() {
        logging$1.deprecated('Adapt.getViewName, please use components.getViewName instead');
        return components$1.getViewName;
      }

    },
    getViewClass: {
      get() {
        logging$1.deprecated('Adapt.getViewClass, please use components.getViewClass instead');
        return components$1.getViewClass;
      }

    },
    getModelName: {
      get() {
        logging$1.deprecated('Adapt.getModelName, please use components.getModelName instead');
        return components$1.getModelName;
      }

    },
    getModelClass: {
      get() {
        logging$1.deprecated('Adapt.getModelClass, please use components.getModelClass instead');
        return components$1.getModelClass;
      }

    },
    location: {
      get() {
        logging$1.deprecated('Adapt.location, please use core/js/location directly');
        return location$2;
      }

    },
    log: {
      get() {
        logging$1.deprecated('Adapt.log, please use core/js/logging directly');
        return logging$1;
      }

    },
    mpabc: {
      get() {
        logging$1.deprecated('Adapt.mpabc, please use core/js/mpabc directly');
        return mpabc$1;
      }

    },
    notify: {
      get() {
        logging$1.deprecated('Adapt.notify, please use core/js/notify directly');
        return notify$1;
      }

    },
    offlineStorage: {
      get() {
        logging$1.deprecated('offlineStorage, please use src/core/offlineStorage instead');
        return offlineStorage$3;
      }

    },
    navigateToElement: {
      get() {
        logging$1.deprecated('Adapt.navigateToElement, please use router.navigateToElement');
        return router$1.navigateToElement;
      }

    },
    register: {
      get() {
        logging$1.deprecated('Adapt.register, please use components.register instead');
        return components$1.register;
      }

    },
    router: {
      get() {
        logging$1.deprecated('Adapt.router, please use core/js/router directly');
        return router$1;
      }

    },
    scrolling: {
      get() {
        logging$1.deprecated('Adapt.scrolling, please use core/js/scrolling directly');
        return scrolling$1;
      }

    },
    scrollTo: {
      get() {
        logging$1.deprecated('Adapt.scrollTo, please use router.navigateToElement');
        return scrolling$1.scrollTo;
      }

    },
    startController: {
      get() {
        logging$1.deprecated('Adapt.startController, please use core/js/startController directly');
        return startController$1;
      }

    },
    store: {
      get() {
        logging$1.deprecated('Adapt.store, please use core/js/components directly');
        return components$1._register;
      }

    },
    tracking: {
      get() {
        logging$1.deprecated('Adapt.tracking, please use core/js/tracking directly');
        return tracking$1;
      }

    },
    wait: {
      get() {
        logging$1.deprecated('Adapt.wait, please use src/core/wait instead');
        return wait$1;
      }

    }
  });

  function onRender(cb) {
    const intercept = (object, name, mode, cb) => {
      return object[name] = cb.bind(object, object[name], name, mode);
    };

    Object.keys(Handlebars.templates).forEach(name => {
      intercept(Handlebars.templates, name, 'template', cb);
    });
    Object.keys(Handlebars.partials).forEach(name => {
      intercept(Handlebars.partials, name, 'partial', cb);
    });
  }

  onRender(function (template, name, mode) {
    for (var _len = arguments.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
      args[_key - 3] = arguments[_key];
    }

    const preRenderEvent = new TemplateRenderEvent(`${mode}:preRender`, name, mode, null, args);
    Adapt$1.trigger(preRenderEvent.type, preRenderEvent);
    const value = template(...preRenderEvent.args);
    const postRenderEvent = new TemplateRenderEvent(`${mode}:postRender`, name, mode, value, preRenderEvent.args);
    Adapt$1.trigger(postRenderEvent.type, postRenderEvent);
    return postRenderEvent.value;
  });

  Adapt$1.on('app:dataReady', () => {
    const config = Adapt$1.config.get('_fixes');
    if (config?._imgLazyLoad === false) return;
    applyImgLoadingFix();
  });

  function applyImgLoadingFix() {
    const findImgTag = /<img([^>]*)>/gi;
    const hasLoadingAttr = / loading=/gi;
    Adapt$1.on('template:postRender partial:postRender', event => {
      const imgTagsFound = event.value.match(findImgTag);

      if (!imgTagsFound) {
        return;
      }

      event.value = imgTagsFound.reduce((value, img) => {
        if (hasLoadingAttr.test(img)) {
          return value;
        }

        return value.replace(img, img.replace(findImgTag, '<img loading="eager"$1>'));
      }, event.value);
    });
    Adapt$1.on('reactElement:preRender', event => {
      if (event.name !== 'img') return;
      const options = event.args[1] = event.args[1] || {};
      if (options && options.hasOwnProperty('loading')) return;
      options.loading = 'eager';
    });
  }

  Adapt$1.on('app:dataReady', () => {
    const config = Adapt$1.config.get('_fixes');
    if (config?._jsxReactHelpersHTML === false) return;
    applyReactHelpersHTML();
  });

  function applyReactHelpersHTML() {
    Adapt$1.on('reactElement:preRender', event => {
      let [tagName, props, ...children] = event.args;
      if (!children) return;
      if (!Array.isArray(children)) children = [children];
      children = children.filter(Boolean);
      const hasSomeUnsafeConversions = children.some(c => c?.__html);
      if (!hasSomeUnsafeConversions) return;
      const hasManyChildren = children.length > 1;

      if (hasManyChildren) {
        event.args = event.args.map(child => {
          if (!child || !child.__html) return child;
          const attributes = Object.entries(props).map(_ref => {
            let [name, value] = _ref;
            return `${name}="${value}"`;
          }).join(' ');
          logging$1.warnOnce(`html() call should be the only child in its parent <${tagName} ${attributes}>`);
          return child.__html ? HTMLReactParser__default["default"](child.__html) : undefined;
        });
        return;
      }

      props = event.args[1] = event.args[1] || {};
      props.dangerouslySetInnerHTML = children[0];
      event.args.length = 2;
    });
  }

  const helpers = {
    lowercase(text) {
      return text.toLowerCase();
    },

    capitalise(text) {
      return text.charAt(0).toUpperCase() + text.slice(1);
    },

    inc(index) {
      return index + 1;
    },

    dec(index) {
      return index - 1;
    },

    odd(index) {
      return (index + 1) % 2 === 0 ? 'even' : 'odd';
    },

    equals(value, text, block) {
      return helpers.compare.call(this, value, '==', text, block);
    },

    compare(value, operator, text, block) {
      switch (operator) {
        case '===':
          if (value === text) return block.fn(this);
          break;

        case '=':
        case '==':
          if (value == text) return block.fn(this);
          break;

        case '>=':
          if (value >= text) return block.fn(this);
          break;

        case '<=':
          if (value <= text) return block.fn(this);
          break;

        case '>':
          if (value > text) return block.fn(this);
          break;

        case '<':
          if (value < text) return block.fn(this);
          break;
      }

      return block.inverse(this);
    },

    math(lvalue, operator, rvalue, options) {
      lvalue = parseFloat(lvalue);
      rvalue = parseFloat(rvalue);

      switch (operator) {
        case '+':
          return lvalue + rvalue;

        case '-':
          return lvalue - rvalue;

        case '*':
          return lvalue * rvalue;

        case '/':
          return lvalue / rvalue;

        case '%':
          return lvalue % rvalue;
      }
    },

    any() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      const specified = args.slice(0, -1);
      const block = args.slice(-1)[0];
      return specified.some(Boolean) ? block.fn ? block.fn(this) : true : block.inverse ? block.inverse(this) : false;
    },

    all() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      const specified = args.slice(0, -1);
      const block = args.slice(-1)[0];
      return specified.every(Boolean) ? block.fn ? block.fn(this) : true : block.inverse ? block.inverse(this) : false;
    },

    none() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      const specified = args.slice(0, -1);
      const block = args.slice(-1)[0];
      return !specified.some(Boolean) ? block.fn ? block.fn(this) : true : block.inverse ? block.inverse(this) : false;
    },

    compile(template, context) {
      if (!template) return '';
      if (template instanceof Object) template = template.toString();
      const data = context?.data?.root ? this : context;
      return Handlebars.compile(template)(data);
    },

    compile_a11y_text(template, context) {
      logging$1.deprecated('a11y_text is no longer required. https://tink.uk/understanding-screen-reader-interaction-modes/');
      return helpers.compile.call(this, template, context);
    },

    compile_a11y_normalize(template, context) {
      if (!template) {
        return '';
      }

      if (template instanceof Object) template = template.toString();
      return Handlebars.helpers.a11y_normalize.call(this, helpers.compile.call(this, template, context));
    },

    compile_a11y_remove_breaks(template, context) {
      if (!template) {
        return '';
      }

      return Handlebars.helpers.a11y_remove_breaks.call(this, helpers.compile.call(this, template, context));
    },

    import_globals(context) {
      if (context.data.root._globals) {
        return '';
      }

      context.data.root._globals = Adapt$1.course.get('_globals');
      return '';
    },

    import_adapt(context) {
      if (context.data.root.Adapt) {
        return;
      }

      const adapt = context.data.root.Adapt = {};
      let i, l, name;
      const directImport = ['config', 'course'];

      for (i = 0, l = directImport.length; i < l; i++) {
        name = directImport[i];
        adapt[name] = Adapt$1[name].toJSON();
      }

      const indexedImport = ['contentObjects', 'articles', 'blocks', 'components'];

      for (i = 0, l = indexedImport.length; i < l; i++) {
        name = indexedImport[i];
        const importArray = Adapt$1[name].toJSON();
        const importIndex = {};

        for (let i1 = 0, l1 = importArray.length; i1 < l1; i1++) {
          const item = importArray[i1];
          importIndex[item._id] = item;
        }

        adapt[name] = importIndex;
      }

      return '';
    },

    component_description(override, context) {
      if (!this._isA11yComponentDescriptionEnabled) {
        return;
      }

      const isNotDefined = !this._globals._components?.['_' + this._component];

      if (isNotDefined) {
        return;
      }

      const hasOverride = arguments.length > 1;
      let description;

      if (hasOverride) {
        description = override;
        description = helpers.compile(description, context);
      } else {
        description = this._globals._components['_' + this._component].ariaRegion;
        description = helpers.compile(description, override);
      }

      if (!description) {
        return;
      }

      return new Handlebars.SafeString('<div class="aria-label">' + description + '</div>');
    },

    a11y_text(text) {
      logging$1.deprecated('a11y_text is no longer required. https://tink.uk/understanding-screen-reader-interaction-modes/');
      return text;
    },

    a11y_normalize(htmls) {
      return a11y$1.normalize.apply(a11y$1, arguments);
    },

    a11y_remove_breaks(htmls) {
      return a11y$1.removeBreaks.apply(a11y$1, arguments);
    },

    a11y_aria_label(htmls) {
      let values = Array.prototype.slice.call(arguments, 0, -1);
      values = values.filter(Boolean);
      return new Handlebars.SafeString('<div class="aria-label">' + values.join(' ') + '</div>');
    },

    a11y_aria_label_relative(htmls) {
      let values = Array.prototype.slice.call(arguments, 0, -1);
      values = values.filter(Boolean);
      return new Handlebars.SafeString('<div class="aria-label relative">' + values.join(' ') + '</div>');
    },

    a11y_aria_image(texts) {
      let values = Array.prototype.slice.call(arguments, 0, -1);
      values = values.filter(Boolean);
      return new Handlebars.SafeString('<div class="aria-label" role="img" aria-label="' + values.join(' ') + '"></div>');
    },

    a11y_wrap_focus() {
      const cfg = Adapt$1.config.get('_accessibility');
      if (cfg._isPopupWrapFocusEnabled === false) return '';
      return new Handlebars.SafeString('<a class="a11y-focusguard a11y-ignore a11y-ignore-focus" tabindex="0" role="presentation">&nbsp;</a>');
    },

    a11y_attrs_heading(level) {
      logging$1.deprecated('a11y_attrs_heading, please use a11y_aria_level or a11y.ariaLevel');
      a11y$1.ariaLevel({
        id: this._id ?? Array.from(arguments).lastItem?.data?.root?._id,
        level,
        override: this._ariaLevel
      });
      return new Handlebars.SafeString(' role="heading" aria-level="${resolvedLevel}" ');
    },

    a11y_aria_level(id, level) {
      let override = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      const resolvedLevel = a11y$1.ariaLevel({
        id,
        level,
        override
      });
      return resolvedLevel;
    },

    a11y_attrs_tabbable() {
      logging$1.deprecated('a11y_attrs_tabbable should not be used. tabbable elements should be natively tabbable.');
      return new Handlebars.SafeString(' role="region" tabindex="0" ');
    },

    a11y_alt_text(visible, alternatives) {
      let values = Array.prototype.slice.call(arguments, 1, -1);
      values = values.filter(Boolean);
      return new Handlebars.SafeString('<span aria-hidden="true">' + visible + '</span><span class="aria-label">' + values.join(' ') + '</span>');
    }

  };
  Object.assign(helpers, {
    if_value_equals() {
      logging$1.deprecated('if_value_equals, use equals instead.');
      return helpers.equals.apply(this, arguments);
    },

    numbers() {
      logging$1.deprecated('numbers, use inc instead.');
      return helpers.inc.apply(this, arguments);
    },

    lowerCase() {
      logging$1.deprecated('lowerCase, use lowercase instead.');
      return helpers.lowercase.apply(this, arguments);
    }

  });

  for (const name in helpers) {
    Handlebars.registerHelper(name, helpers[name]);
  }

  __AMD("core/js/helpers", helpers);

  class HeadingView extends Backbone.View {
    initialize() {
      this.listenTo(Adapt$1.parentView, 'postRemove', this.remove);
      this.listenTo(this.model, 'change:_isComplete', this.updateAria);
      this.render();
    }

    render() {
      const template = Handlebars.templates[this.constructor.template];
      const data = this.model.toJSON();
      const customHeadingType = this.$el.attr('data-a11y-heading-type');
      if (customHeadingType) data._type = customHeadingType;
      if (data._type === 'course') data._type = 'menu';
      this.$el.html(template(data));
      this.checkCompletion();
    }

    updateAria() {
      const template = Handlebars.templates[this.constructor.template];
      const data = this.model.toJSON();
      const $rendered = $(`<div>${template(data)}</div>`);
      this.$('.aria-label').html($rendered.find('.aria-label').html());
      this.checkCompletion();
    }

    checkCompletion() {
      const isComplete = this.model.get('_isComplete');
      this.$el.toggleClass('is-complete', isComplete).toggleClass('is-incomplete', !isComplete);
    }

  }

  HeadingView.template = 'heading';
  var HeadingView$1 = __AMD("core/js/views/headingView", HeadingView);

  class Headings extends Backbone.Controller {
    initialize() {
      this.listenTo(Adapt$1, 'view:render', this.onViewRender);
    }

    onViewRender(view) {
      const $headingSeats = view.$('.js-heading');
      $headingSeats.each((index, el) => new HeadingView$1({
        el,
        model: view.model
      }));
    }

  }

  __AMD("core/js/headings", new Headings());

  class NavigationView extends Backbone.View {
    className() {
      return 'nav';
    }

    events() {
      return {
        'click [data-event]': 'triggerEvent'
      };
    }

    attributes() {
      return {
        role: 'navigation'
      };
    }

    initialize() {
      this.sortNavigationButtons = _.debounce(this.sortNavigationButtons.bind(this), 1);
      this.listenToOnce(Adapt$1, {
        'courseModel:dataLoading': this.remove
      });
      this.listenTo(Adapt$1, 'router:menu router:page', this.onNavigate);
      this.preRender();
    }

    preRender() {
      Adapt$1.trigger('navigationView:preRender', this);
      this.render();
    }

    render() {
      const template = Handlebars.templates[this.constructor.template];
      this.$el.html(template({
        _globals: Adapt$1.course.get('_globals'),
        _accessibility: Adapt$1.config.get('_accessibility')
      })).insertBefore('#app');

      _.defer(() => {
        Adapt$1.trigger('navigationView:postRender', this);
      });

      return this;
    }

    triggerEvent(event) {
      event.preventDefault();
      const currentEvent = $(event.currentTarget).attr('data-event');
      Adapt$1.trigger('navigation:' + currentEvent);

      switch (currentEvent) {
        case 'backButton':
          router$1.navigateToPreviousRoute();
          break;

        case 'homeButton':
          router$1.navigateToHomeRoute();
          break;

        case 'parentButton':
          router$1.navigateToParent();
          break;

        case 'skipNavigation':
          this.skipNavigation();
          break;

        case 'returnToStart':
          startController$1.returnToStartLocation();
          break;
      }
    }

    skipNavigation() {
      a11y$1.focusFirst('.' + location$2._contentType);
    }

    onNavigate(model) {
      this.hideNavigationButton(model);
      this.sortNavigationButtons();
    }

    hideNavigationButton(model) {
      const shouldHide = model.get('_type') === 'course';
      this.$('.nav__back-btn, .nav__home-btn').toggleClass('u-display-none', shouldHide);
    }

    sortNavigationButtons() {
      const container = this.$('.nav__inner')[0];
      const items = [...container.children];
      items.sort((a, b) => parseFloat($(a).attr('data-order') || 0) - parseFloat($(b).attr('data-order') || 0)).forEach(item => container.appendChild(item));
    }

    showNavigationButton() {
      this.$('.nav__back-btn, .nav__home-btn').removeClass('u-display-none');
    }

  }

  NavigationView.template = 'nav';
  var NavigationView$1 = __AMD("core/js/views/navigationView", NavigationView);

  class NavigationController extends Backbone.Controller {
    initialize() {
      this.listenTo(Adapt$1, 'adapt:preInitialize', this.addNavigationBar);
    }

    addNavigationBar() {
      const adaptConfig = Adapt$1.course.get('_navigation');

      if (adaptConfig?._isDefaultNavigationDisabled) {
        Adapt$1.trigger('navigation:initialize');
        return;
      }

      Adapt$1.navigation = new NavigationView$1();
    }

  }

  __AMD("core/js/navigation", new NavigationController());

  class ComponentView extends AdaptView$1 {
    attributes() {
      if (!this.model.get('_isA11yRegionEnabled')) {
        return AdaptView$1.resultExtend('attributes', {}, this);
      }

      return AdaptView$1.resultExtend('attributes', {
        'aria-labelledby': this.model.get('_id') + '-heading',
        role: 'region'
      }, this);
    }

    className() {
      return ['component', this.model.get('_component').toLowerCase(), this.model.get('_id'), this.model.get('_classes'), this.setVisibility(), this.setHidden(), 'is-' + this.model.get('_layout'), this.model.get('_isComplete') ? 'is-complete' : '', this.model.get('_isOptional') ? 'is-optional' : ''].join(' ');
    }

    renderState() {
      logging$1.removed('renderState is removed and moved to item title');
    }

    setupInviewCompletion() {
      let inviewElementSelector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '.component__inner';
      let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.setCompletionStatus;
      this.$inviewElement = this.$(inviewElementSelector);
      this.inviewCallback = callback;
      this.$inviewElement.on('inview.componentView', this.onInview.bind(this));
    }

    removeInviewListener() {
      if (!this.$inviewElement) return;
      this.$inviewElement.off('inview.componentView');
      this.$inviewElement = null;
    }

    onInview(event, visible, visiblePartX, visiblePartY) {
      if (!visible) return;

      switch (visiblePartY) {
        case 'top':
          this.hasSeenTop = true;
          break;

        case 'bottom':
          this.hasSeenBottom = true;
          break;

        case 'both':
          this.hasSeenTop = this.hasSeenBottom = true;
      }

      if (!this.hasSeenTop || !this.hasSeenBottom) return;
      this.inviewCallback();

      if (this.model.get('_isComplete')) {
        this.removeInviewListener();
      }
    }

    postRender() {}

    remove() {
      this.removeInviewListener();
      super.remove();
    }

  }

  ComponentView.type = 'component';
  var ComponentView$1 = __AMD("core/js/views/componentView", ComponentView);

  var ChartJSView = __AMD("components/adapt-chartjs/js/chartjsView", class ChartJSView extends ComponentView$1 {
    preRender() {
      this.listenTo(this.model, 'change:data', this.onDataChanged);
    }

    postRender() {
      this.setupChart();
      this.setupInview();
    }

    setupInview() {
      const selector = this.getInviewElementSelector();
      if (!selector) return this.setCompletionStatus();
      this.setupInviewCompletion(selector);
    }

    getInviewElementSelector() {
      if (this.model.get('body')) return '.component__body';
      if (this.model.get('instruction')) return '.component__instruction';
      if (this.model.get('displayTitle')) return '.component__title';
      return null;
    }

    async dynamicInsert(dataURL) {
      const fetchJson = async () => {
        const response = await fetch(dataURL);
        const json = await response.json();
        return json;
      };

      return await fetchJson();
    }

    async setupChart() {
      var ctx = $("#myChart" + this.model.get('_id'));
      await Promise.all(this.model.get('data').datasets.map(async dataset => {
        if (dataset.dataURL) {
          dataset.data = await this.dynamicInsert(dataset.dataURL);
        }
      }));
      var chart = new Chart__default["default"](ctx, {
        type: this.model.get('_chartType'),
        data: await this.model.get('data'),
        options: this.model.get('_options')
      });
      this.setReadyStatus();
      this.model.set("_chart", chart);
    }

    onDataChanged() {
      var chart = this.model.get("_chart");
      console.log(chart);

      if (chart) {
        chart.update();
      }
    }

  });

  var ChartJSModel = __AMD("components/adapt-chartjs/js/chartjsModel", class ChartJSModel extends ComponentModel$1 {
    updateDataset(datasetData, datasetIndex) {
      datasetIndex = datasetIndex || 0;
      var data = this.get("data");

      if (!data) {
        throw new Error("This chart instance has no data; it may be improperly configured");
      }

      if (!data.datasets || datasetIndex >= data.datasets.length) {
        throw new RangeError("Cannot update a nonexistent dataset");
      }

      data.datasets[datasetIndex].data = datasetData;
      this.trigger("change:data");
    }

  });

  __AMD("components/adapt-chartjs/js/adapt-chartjs", Adapt$1.register("chartjs", {
    view: ChartJSView,
    model: ChartJSModel
  }));

  class GraphicView extends ComponentView$1 {
    className() {
      return [super.className(), this.model.get('_isScrollable') && 'is-scrollable'].filter(Boolean).join(' ');
    }

    events() {
      return {
        'click .js-graphic-link': 'onClick',
        'keydown .js-graphic-scrollbar': 'onKeyDown'
      };
    }

    postRender() {
      this.$('.graphic__widget').imageready(() => {
        this.setReadyStatus();
        this.setupInviewCompletion('.graphic__widget');
        this.setupScrollable();
      });
    }

    setupScrollable() {
      if (!this.model.get('_isScrollable')) return;
      this.onScroll = _.debounce(this.onScroll.bind(this), 17);
      const $scrollbar = this.$('.js-graphic-scrollbar');
      const $scrollContainer = this.$(`#${$scrollbar.attr('aria-controls')}`);
      $scrollContainer.on('scroll', this.onScroll);
      this.onKeyDown();
    }

    onScroll(event) {
      if (!this.model.get('_isScrollable')) return;
      const $scrollbar = this.$('.js-graphic-scrollbar');
      const $scrollContainer = this.$(`#${$scrollbar.attr('aria-controls')}`);
      const {
        clientWidth,
        scrollWidth
      } = $scrollContainer[0];
      const scrollableWidth = scrollWidth - clientWidth;
      const left = $scrollContainer.scrollLeft();
      const calculatedScrollPercent = parseInt(left / scrollableWidth * 100);
      this.model.set('_scrollPercent', calculatedScrollPercent);
    }

    onKeyDown(event) {
      if (!this.model.get('_isScrollable')) return;
      const $scrollbar = this.$('.js-graphic-scrollbar');
      const $scrollContainer = this.$(`#${$scrollbar.attr('aria-controls')}`);
      const {
        clientWidth,
        scrollWidth
      } = $scrollContainer[0];
      const scrollableWidth = scrollWidth - clientWidth;
      const step = clientWidth * 0.1;
      let left = $scrollContainer.scrollLeft();
      const calculatedScrollPercent = parseInt(left / scrollableWidth * 100);
      const definedScrollPercent = this.model.get('_scrollPercent') ?? 0;

      if (definedScrollPercent !== calculatedScrollPercent) {
        left = definedScrollPercent / 100 * scrollableWidth;
      }

      switch (event?.which) {
        case 37:
          left -= step;
          break;

        case 39:
          left += step;
          break;
      }

      left = _.max([0, _.min([scrollableWidth, left])]);
      $scrollContainer.scrollLeft(left);
    }

    onClick(event) {
      if (event) event.preventDefault();
      const item = this.model.get('_graphic');
      const {
        _url: url,
        _target: target = '_blank'
      } = item;
      const isNewWindow = target !== '_self';
      if (isNewWindow) return window.open(url, target);
      const isRouterNavigation = url.substr(0, 1) === '#';
      if (isRouterNavigation) return Backbone.history.navigate(url, {
        trigger: true
      });
      window.location.href = url;
    }

    preRemove() {
      if (!this.model.get('_isScrollable')) return;
      const $scrollbar = this.$('.js-graphic-scrollbar');
      const $scrollContainer = this.$(`#${$scrollbar.attr('aria-controls')}`);
      $scrollContainer.off('scroll', this.onScroll);
    }

  }

  GraphicView.template = 'graphic.jsx';
  var GraphicView$1 = __AMD("components/adapt-contrib-graphic/js/GraphicView", GraphicView);

  var GraphicModel = __AMD("components/adapt-contrib-graphic/js/GraphicModel", class GraphicModel extends ComponentModel$1 {
    init() {
      this.set('_scrollPercent', this.get('_defaultScrollPercent'));
    }

  });

  __AMD("components/adapt-contrib-graphic/js/adapt-contrib-graphic", components$1.register('graphic', {
    model: GraphicModel,
    view: GraphicView$1
  }));

  const BUTTON_STATE = ENUM(['SUBMIT', 'CORRECT', 'INCORRECT', 'SHOW_CORRECT_ANSWER', 'HIDE_CORRECT_ANSWER', 'SHOW_FEEDBACK', 'RESET']);
  var BUTTON_STATE$1 = __AMD("core/js/enums/buttonStateEnum", BUTTON_STATE);

  const textPropertyName = {
    SUBMIT: 'submit',
    CORRECT: 'correct',
    INCORRECT: 'incorrect',
    SHOW_CORRECT_ANSWER: 'showCorrectAnswer',
    HIDE_CORRECT_ANSWER: 'hideCorrectAnswer',
    SHOW_FEEDBACK: 'showFeedback',
    RESET: 'reset'
  };
  var ButtonsView = __AMD("core/js/views/buttonsView", class ButtonsView extends Backbone.View {
    initialize(options) {
      this.parent = options.parent;
      this.listenTo(Adapt$1.parentView, 'postRemove', this.remove);
      this.listenTo(this.model, {
        'change:_buttonState': this.onButtonStateChanged,
        'change:feedbackMessage': this.onFeedbackMessageChanged,
        'change:_attemptsLeft': this.onAttemptsChanged,
        'change:_canSubmit': this.onCanSubmitChange
      });
      this.render();
    }

    events() {
      return {
        'click .js-btn-action': 'onActionClicked',
        'click .js-btn-feedback': 'onFeedbackClicked'
      };
    }

    render() {
      const data = this.model.toJSON();
      const template = Handlebars.templates.buttons;

      _.defer(() => {
        this.postRender();
        Adapt$1.trigger('buttonsView:postRender', this);
      });

      this.$el.html(template(data));
    }

    postRender() {
      this.refresh();
    }

    checkResetSubmittedState() {
      const isSubmitted = this.model.get('_isSubmitted');

      if (isSubmitted) {
        this.$el.addClass('is-submitted');
        return;
      }

      this.$('.js-btn-marking, .js-btn-marking-label').removeClass('is-incorrect is-correct').addClass('u-display-none');
      this.$el.removeClass('is-submitted');
      this.model.set('feedbackMessage', undefined);
      a11y$1.toggleEnabled(this.$('.js-btn-feedback'), false);
    }

    onActionClicked() {
      const buttonState = BUTTON_STATE$1(this.model.get('_buttonState'));
      this.trigger('buttons:stateUpdate', buttonState);
      this.checkResetSubmittedState();

      if (buttonState === BUTTON_STATE$1.SHOW_CORRECT_ANSWER) {
        const correctAnswer = this.model.getCorrectAnswerAsText?.();
        this.updateAnswerLiveRegion(correctAnswer);
      }

      if (buttonState === BUTTON_STATE$1.HIDE_CORRECT_ANSWER) {
        const userAnswer = this.model.getUserAnswerAsText?.();
        this.updateAnswerLiveRegion(userAnswer);
      }
    }

    onFeedbackClicked() {
      this.trigger('buttons:stateUpdate', BUTTON_STATE$1.SHOW_FEEDBACK);
    }

    onFeedbackMessageChanged(model, changedAttribute) {
      if (changedAttribute && this.model.get('_canShowFeedback')) {
        a11y$1.toggleEnabled(this.$('.js-btn-feedback'), true);
        return;
      }

      a11y$1.toggleEnabled(this.$('.js-btn-feedback'), false);
    }

    onCanSubmitChange() {
      this.onButtonStateChanged(this.model, this.model.get('_buttonState'));
    }

    onButtonStateChanged(model, changedAttribute) {
      this.updateAttemptsCount();
      const $buttonsAction = this.$('.js-btn-action');
      const buttonState = BUTTON_STATE$1(changedAttribute);

      if (changedAttribute === BUTTON_STATE$1.CORRECT || changedAttribute === BUTTON_STATE$1.INCORRECT) {
        a11y$1.toggleEnabled($buttonsAction, false);
        return;
      }

      const propertyName = textPropertyName[buttonState.asString];
      const ariaLabel = this.model.get('_buttons')['_' + propertyName].ariaLabel;
      const buttonText = this.model.get('_buttons')['_' + propertyName].buttonText;
      a11y$1.toggleEnabled($buttonsAction, this.model.get('_canSubmit'));
      $buttonsAction.html(buttonText).attr('aria-label', ariaLabel);
    }

    checkFeedbackState() {
      const canShowFeedback = this.model.get('_canShowFeedback');
      this.$('.js-btn-action').toggleClass('is-full-width', !canShowFeedback);
      this.$('.js-btn-feedback').toggleClass('u-display-none', !canShowFeedback);
      this.$('.js-btn-marking, .js-btn-marking-label').toggleClass('is-full-width u-display-none', !canShowFeedback);
    }

    updateAttemptsCount() {
      const isInteractionComplete = this.model.get('_isInteractionComplete');
      const attemptsLeft = this.model.get('_attemptsLeft') ? this.model.get('_attemptsLeft') : this.model.get('_attempts');
      const shouldDisplayAttempts = this.model.get('_shouldDisplayAttempts');
      let attemptsString;
      this.checkResetSubmittedState();

      if (!isInteractionComplete && attemptsLeft >= 0) {
        attemptsString = attemptsLeft + ' ';
        attemptsString += attemptsLeft === 1 ? this.model.get('_buttons').remainingAttemptText : this.model.get('_buttons').remainingAttemptsText;
      } else {
        this.$('.js-display-attempts').addClass('u-visibility-hidden');
        this.showMarking();
      }

      if (shouldDisplayAttempts) {
        this.$('.js-insert-attempts-string').html(attemptsString);
      }
    }

    updateAnswerLiveRegion(answer) {
      if (!answer) return;
      this.$('.js-answer-live-region').html(answer);
    }

    showMarking() {
      if (!this.model.shouldShowMarking) return;
      const isCorrect = this.model.get('_isCorrect');

      const ariaLabels = Adapt$1.course.get('_globals')._accessibility._ariaLabels;

      const $marking = this.$('.js-btn-marking, .js-btn-marking-label').removeClass('u-display-none').addClass(isCorrect ? 'is-correct' : 'is-incorrect');
      const $ariaLabel = this.$('.js-btn-marking-label');
      const hasSpanAriaLabel = Boolean($ariaLabel.length);

      if (!hasSpanAriaLabel) {
        $marking.attr('aria-label', isCorrect ? ariaLabels.answeredCorrectly : ariaLabels.answeredIncorrectly);
        return;
      }

      $ariaLabel.html(isCorrect ? ariaLabels.answeredCorrectly : ariaLabels.answeredIncorrectly);
    }

    refresh() {
      this.updateAttemptsCount();
      this.checkResetSubmittedState();
      this.checkFeedbackState();
      this.onButtonStateChanged(null, this.model.get('_buttonState'));
      this.onFeedbackMessageChanged(null, this.model.get('feedbackMessage'));
    }

  });

  class QuestionModel extends ComponentModel$1 {
    defaults() {
      return ComponentModel$1.resultExtend('defaults', {
        _isQuestionType: true,
        _shouldDisplayAttempts: false,
        _shouldShowMarking: false,
        _canShowModelAnswer: true,
        _canShowFeedback: true,
        _canShowMarking: true,
        _canSubmit: true,
        _isSubmitted: false,
        _isCorrectAnswerShown: false,
        _questionWeight: Adapt$1.config.get('_questionWeight'),
        _hasItemScoring: false,
        _items: []
      });
    }

    trackable() {
      return ComponentModel$1.resultExtend('trackable', ['_isSubmitted', '_score', '_isCorrect', '_attemptsLeft']);
    }

    trackableType() {
      return ComponentModel$1.resultExtend('trackableType', [Boolean, Number, Boolean, Number]);
    }

    getTypeGroup() {
      return 'question';
    }

    init() {
      this.setupDefaultSettings();
      this.setLocking('_canSubmit', true);
      this.updateRawScore();
      super.init();
    }

    setupDefaultSettings() {
      this.setupWeightSettings();
      this.setupButtonSettings();
    }

    setupButtonSettings() {
      const globalButtons = Adapt$1.course.get('_buttons');

      if (!this.has('_buttons')) {
        this.set('_buttons', globalButtons);
      } else {
        const componentButtons = this.get('_buttons');

        for (const key in componentButtons) {
          if (typeof componentButtons[key] === 'object') {
            if (!componentButtons[key].buttonText && globalButtons[key].buttonText) {
              componentButtons[key].buttonText = globalButtons[key].buttonText;
            }

            if (!componentButtons[key].ariaLabel && globalButtons[key].ariaLabel) {
              componentButtons[key].ariaLabel = globalButtons[key].ariaLabel;
            }
          }

          if (!componentButtons[key] && globalButtons[key]) {
            componentButtons[key] = globalButtons[key];
          }
        }
      }
    }

    setupWeightSettings() {}

    canSubmit() {}

    checkCanSubmit() {
      this.set('_canSubmit', this.canSubmit(), {
        pluginName: 'adapt'
      });
    }

    updateAttempts() {
      const attemptsLeft = this.get('_attemptsLeft') || this.get('_attempts');
      this.set('_attemptsLeft', attemptsLeft - 1);
    }

    setQuestionAsSubmitted() {
      this.set({
        _isEnabled: false,
        _isSubmitted: true,
        _shouldShowMarking: this.shouldShowMarking
      });
    }

    markQuestion() {
      if (this.isCorrect()) {
        this.set('_isCorrect', true);
      } else {
        this.set('_isCorrect', false);
      }

      this.updateRawScore();
    }

    isCorrect() {}

    setScore() {
      const questionWeight = this.get('_questionWeight');
      const answeredCorrectly = this.get('_isCorrect');
      const score = answeredCorrectly ? questionWeight : 0;
      this.set('_score', score);
    }

    updateRawScore() {
      this.set({
        _rawScore: this.score,
        _maxScore: this.maxScore,
        _minScore: this.minScore
      });
    }

    get score() {
      return this.get('_isCorrect') ? this.maxScore : 0;
    }

    get maxScore() {
      return this.get('_questionWeight');
    }

    get minScore() {
      return 0;
    }

    checkQuestionCompletion() {
      const isComplete = this.get('_isCorrect') || this.get('_attemptsLeft') === 0;

      if (isComplete) {
        this.setCompletionStatus();
      }

      return isComplete;
    }

    updateButtons() {
      const isInteractionComplete = this.get('_isInteractionComplete');
      const isCorrect = this.get('_isCorrect');
      const isEnabled = this.get('_isEnabled');
      const buttonState = this.get('_buttonState');
      const canShowModelAnswer = this.get('_canShowModelAnswer');

      if (isInteractionComplete) {
        if (isCorrect || !canShowModelAnswer) {
          this.set('_buttonState', BUTTON_STATE$1.CORRECT);
        } else {
          switch (buttonState) {
            case BUTTON_STATE$1.SUBMIT:
            case BUTTON_STATE$1.HIDE_CORRECT_ANSWER:
              this.set('_buttonState', BUTTON_STATE$1.SHOW_CORRECT_ANSWER);
              break;

            default:
              this.set('_buttonState', BUTTON_STATE$1.HIDE_CORRECT_ANSWER);
          }
        }
      } else {
        if (isEnabled) {
          this.set('_buttonState', BUTTON_STATE$1.SUBMIT);
        } else {
          this.set('_buttonState', BUTTON_STATE$1.RESET);
        }
      }
    }

    setupFeedback() {
      if (!this.has('_feedback')) return;

      if (this.get('_isCorrect')) {
        this.setupCorrectFeedback();
      } else if (this.isPartlyCorrect()) {
        this.setupPartlyCorrectFeedback();
      } else {
        this.setupIncorrectFeedback();
      }
    }

    isPartlyCorrect() {}

    setupCorrectFeedback() {
      this.set({
        feedbackTitle: this.getFeedbackTitle(),
        feedbackMessage: Handlebars.compile(this.get('_feedback').correct)(this.toJSON())
      });
    }

    setupPartlyCorrectFeedback() {
      const feedback = this.get('_feedback')._partlyCorrect;

      if (feedback?.final) {
        this.setAttemptSpecificFeedback(feedback);
      } else {
        this.setupIncorrectFeedback();
      }
    }

    setupIncorrectFeedback() {
      this.setAttemptSpecificFeedback(this.get('_feedback')._incorrect);
    }

    setAttemptSpecificFeedback(feedback) {
      const body = this.get('_attemptsLeft') && feedback.notFinal || feedback.final;
      this.set({
        altFeedbackTitle: this.getAltFeedbackTitle(),
        feedbackTitle: this.getFeedbackTitle(),
        feedbackMessage: Handlebars.compile(body)(this.toJSON())
      });
    }

    getAltFeedbackTitle() {
      return this.get('_feedback').altTitle || Adapt$1.course.get('_globals')._accessibility.altFeedbackTitle || '';
    }

    getFeedbackTitle() {
      const title = this.get('_feedback').title || this.get('displayTitle') || this.get('title') || '';
      return Handlebars.compile(title)(this.toJSON());
    }

    isInteractive() {
      return !this.get('_isComplete') || this.get('_isEnabled') && !this.get('_isSubmitted');
    }

    checkIfResetOnRevisit() {
      super.checkIfResetOnRevisit();
      this.set('_buttonState', this.get('_isInteractionComplete') ? BUTTON_STATE$1.HIDE_CORRECT_ANSWER : BUTTON_STATE$1.SUBMIT);
    }

    reset() {
      let type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'hard';
      let canReset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.get('_canReset');
      const wasReset = super.reset(type, canReset);
      if (!wasReset) return false;
      const attempts = this.get('_attempts');
      this.set({
        _attemptsLeft: attempts,
        _isCorrect: undefined,
        _isCorrectAnswerShown: false,
        _isSubmitted: false,
        _buttonState: BUTTON_STATE$1.SUBMIT,
        _shouldShowMarking: this.shouldShowMarking
      });
      return true;
    }

    setQuestionAsReset() {
      this.set({
        _isEnabled: true,
        _isSubmitted: false,
        _shouldShowMarking: this.shouldShowMarking
      });
      this.resetQuestion();
    }

    resetQuestion() {}

    refresh() {
      this.trigger('question:refresh');
    }

    getButtonState() {
      if (this.get('_isCorrect')) {
        return BUTTON_STATE$1.CORRECT;
      }

      if (this.get('_attemptsLeft') === 0) {
        return this.get('_canShowModelAnswer') ? BUTTON_STATE$1.SHOW_CORRECT_ANSWER : BUTTON_STATE$1.INCORRECT;
      }

      return this.get('_isSubmitted') ? BUTTON_STATE$1.RESET : BUTTON_STATE$1.SUBMIT;
    }

    getInteractionObject() {
      return {};
    }

    getResponse() {}

    getResponseType() {}

    onSubmitted() {
      if (this.get('_shouldStoreAttempts')) this.addAttemptObject();
      this.set('_shouldShowMarking', this.shouldShowMarking);
    }

    get shouldShowMarking() {
      return !this.isInteractive() && this.get('_canShowMarking') && this.get('_isInteractionComplete');
    }

  }

  components$1.register('question', {
    model: QuestionModel
  });
  var QuestionModel$1 = __AMD("core/js/models/questionModel", QuestionModel);

  class QuestionView extends ComponentView$1 {
    className() {
      return ['component', 'is-question', this.model.get('_component').toLowerCase(), this.model.get('_id'), this.model.get('_classes'), this.setVisibility(), 'is-' + this.model.get('_layout'), this.model.get('_isComplete') ? 'is-complete' : '', this.model.get('_isOptional') ? 'is-optional' : '', this.model.get('_canShowModelAnswer') ? 'can-show-model-answer' : '', this.model.get('_canShowFeedback') ? 'can-show-feedback' : '', this.model.get('_canShowMarking') ? 'can-show-marking' : ''].join(' ');
    }

    initialize() {
      this.isInteractive = this.isInteractive.bind(this);
      super.initialize(...arguments);
    }

    isInteractive() {
      logging$1.deprecated('questionView.isInteractive please use this.model.isInteractive, this.model.get(\'_shouldShowMarking\') or this.model.shouldShowMarking');
      return this.model.isInteractive();
    }

    preRender() {
      this.listenTo(this.model, 'change:_isEnabled', this.onEnabledChanged);
      this.listenTo(this.model, 'question:refresh', this.refresh);

      if (this.checkIfResetOnRevisit !== QuestionView.prototype.checkIfResetOnRevisit) {
        logging$1.deprecated('QuestionView.checkIfResetOnRevisit, please use QuestionModel.checkIfResetOnRevisit');
      }

      this.checkIfResetOnRevisit();

      _.defer(() => this.ensureLegacyLifecycleState());

      this._runModelCompatibleFunction('setupDefaultSettings');

      this.setupQuestion();
    }

    onEnabledChanged(model, changedAttribute) {
      if (!changedAttribute) {
        this.$('.component__widget').addClass('is-disabled');
        this.disableQuestion();
      } else {
        this.$('.component__widget').removeClass('is-disabled');
        this.enableQuestion();
      }
    }

    disableQuestion() {}

    enableQuestion() {}

    checkIfResetOnRevisit() {
      const canReset = this.model.get('_canReset') !== false;
      const isResetOnRevisit = this.model.get('_isResetOnRevisit');
      if (!canReset || !isResetOnRevisit) return;
      if (this.resetQuestionOnRevisit === QuestionView.prototype.resetQuestionOnRevisit) return;
      logging$1.deprecated('QuestionView.resetQuestionOnRevisit, please QuestionModel.reset');

      _.defer(() => {
        this.resetQuestionOnRevisit(isResetOnRevisit);
      });
    }

    ensureLegacyLifecycleState() {
      const isInteractionComplete = this.model.get('_isInteractionComplete');

      if (isInteractionComplete) {
        this.onHideCorrectAnswerClicked();
        return;
      }

      this.onResetClicked();
    }

    resetQuestionOnRevisit(type) {}

    setupQuestion() {}

    postRender() {
      this.addButtonsView();
      this.onQuestionRendered();
    }

    addButtonsView() {
      this.buttonsView = new ButtonsView({
        model: this.model,
        el: this.$('.btn__container')
      });
      this.listenTo(this.buttonsView, 'buttons:stateUpdate', this.onButtonStateUpdate);
    }

    onButtonStateUpdate(buttonState) {
      switch (buttonState) {
        case BUTTON_STATE$1.SUBMIT:
          this.onSubmitClicked();
          break;

        case BUTTON_STATE$1.RESET:
          this.onResetClicked();
          break;

        case BUTTON_STATE$1.SHOW_CORRECT_ANSWER:
          this.onShowCorrectAnswerClicked();
          break;

        case BUTTON_STATE$1.HIDE_CORRECT_ANSWER:
          this.onHideCorrectAnswerClicked();
          break;

        case BUTTON_STATE$1.SHOW_FEEDBACK:
          this.showFeedback();
          break;
      }
    }

    onQuestionRendered() {}

    onSubmitClicked() {
      const canSubmit = this._runModelCompatibleFunction('canSubmit');

      if (!canSubmit) {
        this.showInstructionError();
        this.onCannotSubmit();
        return;
      }

      this._runModelCompatibleFunction('updateAttempts');

      this._runModelCompatibleFunction('setQuestionAsSubmitted');

      this._runModelCompatibleFunction('storeUserAnswer');

      this._runModelCompatibleFunction('markQuestion', 'isCorrect');

      this._runModelCompatibleFunction('setScore');

      this._runModelCompatibleFunction('checkQuestionCompletion');

      if (this.model.shouldShowMarking) {
        this.showMarking();
      }

      this.recordInteraction();

      this._runModelCompatibleFunction('setupFeedback');

      this.showFeedback();
      $(window).resize();

      this._runModelCompatibleFunction('updateButtons');

      this.model.onSubmitted();
      this.onSubmitted();
    }

    showInstructionError() {
      Adapt$1.trigger('questionView:showInstructionError', this);
    }

    onCannotSubmit() {}

    onSubmitted() {}

    setQuestionAsSubmitted() {
      this.model.setQuestionAsSubmitted();
      this.$('.component__widget').addClass('is-submitted');
    }

    showMarking() {}

    checkQuestionCompletion() {
      const isComplete = this.model.checkQuestionCompletion();

      if (isComplete) {
        this.$('.component__widget').addClass('is-complete show-user-answer');
      }
    }

    recordInteraction() {
      if (this.model.get('_recordInteraction') === true || !this.model.has('_recordInteraction')) {
        Adapt$1.trigger('questionView:recordInteraction', this);
      }
    }

    showFeedback() {
      if (this.model.get('_canShowFeedback')) {
        Adapt$1.trigger('questionView:showFeedback', this);
      } else {
        Adapt$1.trigger('questionView:disabledFeedback', this);
      }
    }

    onResetClicked() {
      this.setQuestionAsReset();

      this._runModelCompatibleFunction('resetUserAnswer');

      this.model.checkCanSubmit();

      this._runModelCompatibleFunction('updateButtons');

      if (!this.model.get('_isReady')) return;
      const currentModel = data$1.findById(location$2._currentId);
      if (!currentModel?.get('_isReady')) return;
      a11y$1.focusNext(this.$el, {
        preventScroll: true
      });
    }

    setQuestionAsReset() {
      this.model.setQuestionAsReset();
      this.resetQuestion();
      this.$('.component__widget').removeClass('is-submitted');
    }

    resetQuestion() {}

    refresh() {
      this.model.set('_buttonState', this.model.getButtonState());

      if (this.model.shouldShowMarking) {
        this.showMarking();
      }

      if (this.buttonsView) {
        _.defer(this.buttonsView.refresh.bind(this.buttonsView));
      }
    }

    onShowCorrectAnswerClicked() {
      this.setQuestionAsShowCorrect();

      this._runModelCompatibleFunction('updateButtons');

      this.showCorrectAnswer();
    }

    setQuestionAsShowCorrect() {
      this.$('.component__widget').addClass('is-submitted show-correct-answer').removeClass('show-user-answer');
    }

    showCorrectAnswer() {
      this.model.set('_isCorrectAnswerShown', true);
    }

    onHideCorrectAnswerClicked() {
      this.setQuestionAsHideCorrect();

      this._runModelCompatibleFunction('updateButtons');

      this.hideCorrectAnswer();
    }

    setQuestionAsHideCorrect() {
      this.$('.component__widget').addClass('is-submitted show-user-answer').removeClass('show-correct-answer');
    }

    hideCorrectAnswer() {
      this.model.set('_isCorrectAnswerShown', false);
    }

    getLatency() {
      return null;
    }

    _runModelCompatibleFunction(name, lookForViewOnlyFunction) {
      return this.model[name]();
    }

  }

  QuestionView._isQuestionType = true;

  class ViewOnlyQuestionViewCompatibilityLayer extends QuestionView {
    getInteractionObject() {
      logging$1.deprecated('QuestionView.getInteractionObject, please use QuestionModel.getInteractionObject');
      return this.model.getInteractionObject();
    }

    getResponse() {
      logging$1.deprecated('QuestionView.getInteractionObject, please use QuestionModel.getInteractionObject');
      return this.model.getResponse();
    }

    getResponseType() {
      logging$1.deprecated('QuestionView.getResponseType, please use QuestionModel.getResponseType');
      return this.model.getResponseType();
    }

    setupDefaultSettings() {
      logging$1.deprecated('QuestionView.setupDefaultSettings, please use QuestionModel.setupDefaultSettings');
      return this.model.setupDefaultSettings();
    }

    setupButtonSettings() {
      logging$1.deprecated('QuestionView.setupButtonSettings, please use QuestionModel.setupButtonSettings');
      return this.model.setupButtonSettings();
    }

    setupWeightSettings() {
      logging$1.deprecated('QuestionView.setupWeightSettings, please use QuestionModel.setupWeightSettings');
      return this.model.setupWeightSettings();
    }

    canSubmit() {
      logging$1.deprecated('QuestionView.canSubmit, please use QuestionModel.canSubmit');
      return this.model.canSubmit();
    }

    updateAttempts() {
      logging$1.deprecated('QuestionView.updateAttempts, please use QuestionModel.updateAttempts');
      return this.model.updateAttempts();
    }

    storeUserAnswer() {
      logging$1.deprecated('QuestionView.storeUserAnswer, please use QuestionModel.storeUserAnswer');
      return this.model.storeUserAnswer();
    }

    resetUserAnswer() {
      logging$1.deprecated('QuestionView.resetUserAnswer, please use QuestionModel.resetUserAnswer');
      return this.model.resetUserAnswer();
    }

    markQuestion() {
      if (this._isInViewOnlyCompatibleMode('isCorrect')) {
        if (this.isCorrect()) {
          this.model.set('_isCorrect', true);
        } else {
          this.model.set('_isCorrect', false);
        }

        this.model.set({
          _rawScore: this.model.get('_isCorrect') ? this.model.get('_questionWeight') : 0,
          _maxScore: this.model.get('_questionWeight'),
          _minScore: 0
        });
      } else {
        return this.model.markQuestion();
      }
    }

    isCorrect() {
      logging$1.deprecated('QuestionView.isCorrect, please use QuestionModel.isCorrect');
      return this.model.isCorrect();
    }

    setScore() {
      logging$1.deprecated('QuestionView.setScore, please use QuestionModel.setScore');
      return this.model.setScore();
    }

    updateButtons() {
      logging$1.deprecated('QuestionView.updateButtons, please use QuestionModel.updateButtons');
      return this.model.updateButtons();
    }

    setupFeedback() {
      if (this._isInViewOnlyCompatibleMode('isPartlyCorrect')) {
        if (this.model.get('_isCorrect')) {
          this._runModelCompatibleFunction('setupCorrectFeedback');
        } else if (this.isPartlyCorrect()) {
          this._runModelCompatibleFunction('setupPartlyCorrectFeedback');
        } else {
          this._runModelCompatibleFunction('setupIncorrectFeedback');
        }
      } else {
        this.model.setupFeedback();
      }
    }

    isPartlyCorrect() {
      logging$1.deprecated('QuestionView.isPartlyCorrect, please use QuestionModel.isPartlyCorrect');
      return this.model.isPartlyCorrect();
    }

    setupCorrectFeedback() {
      logging$1.deprecated('QuestionView.setupCorrectFeedback, please use QuestionModel.setupCorrectFeedback');
      return this.model.setupCorrectFeedback();
    }

    setupPartlyCorrectFeedback() {
      logging$1.deprecated('QuestionView.setupPartlyCorrectFeedback, please use QuestionModel.setupPartlyCorrectFeedback');
      return this.model.setupPartlyCorrectFeedback();
    }

    setupIncorrectFeedback() {
      logging$1.deprecated('QuestionView.setupIncorrectFeedback, please use QuestionModel.setupIncorrectFeedback');
      return this.model.setupIncorrectFeedback();
    }

    _runModelCompatibleFunction(name, lookForViewOnlyFunction) {
      if (this._isInViewOnlyCompatibleMode(name, lookForViewOnlyFunction)) {
        return this[name]();
      } else {
        return this.model[name]();
      }
    }

    _isInViewOnlyCompatibleMode(name, lookForViewOnlyFunction) {
      const checkForFunction = lookForViewOnlyFunction || name;
      if (!this.constructor.prototype[checkForFunction]) return false;
      const hasCompatibleVersion = Object.prototype.hasOwnProperty.call(ViewOnlyQuestionViewCompatibilityLayer.prototype, checkForFunction);
      const usingCompatibleVersion = this.constructor.prototype[checkForFunction] === ViewOnlyQuestionViewCompatibilityLayer.prototype[checkForFunction];

      if (hasCompatibleVersion && usingCompatibleVersion) {
        switch (checkForFunction) {
          case 'setupFeedback':
          case 'markQuestion':
            return true;
        }

        return false;
      }

      return true;
    }

  }
  var QuestionView$1 = __AMD("core/js/views/questionView", ViewOnlyQuestionViewCompatibilityLayer);

  class MatchingView extends QuestionView$1 {
    preinitialize() {
      var _this = this;

      this.setActiveOption = function () {
        return _this.model.setActiveOption(...arguments);
      };

      this.setHighlightedOption = function () {
        return _this.model.setHighlightedOption(...arguments);
      };
    }

    setupQuestion() {
      this.model.setupRandomisation();
      this.model.setupInitialHighlighted();
    }

    onQuestionRendered() {
      this.setReadyStatus();
    }

  }

  MatchingView.template = 'matching.jsx';
  var MatchingView$1 = __AMD("components/adapt-contrib-matching/js/MatchingView", MatchingView);

  var ItemModel = __AMD("core/js/models/itemModel", class ItemModel extends LockingModel {
    defaults() {
      return {
        _isActive: false,
        _isVisited: false,
        _score: 0
      };
    }

    reset() {
      this.set({
        _isActive: false,
        _isVisited: false
      });
    }

    toggleActive() {
      let isActive = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !this.get('_isActive');
      this.set('_isActive', isActive);
    }

    toggleVisited() {
      let isVisited = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !this.get('_isVisited');
      this.set('_isVisited', isVisited);
    }

  });

  var MatchingItemModel = __AMD("components/adapt-contrib-matching/js/MatchingItemModel", class MatchingItemModel extends ItemModel {
    defaults() {
      return ItemModel.resultExtend('defaults', {
        _isHighlighted: false
      });
    }

    toggleHighlighted() {
      let isHighlighted = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !this.get('_isHighlighted');
      this.set('_isHighlighted', isHighlighted);
    }

  });

  var ItemsComponentModel = __AMD("core/js/models/itemsComponentModel", class ItemsComponentModel extends ComponentModel$1 {
    toJSON() {
      const json = super.toJSON();
      json._items = this.getChildren().toJSON();
      return json;
    }

    init() {
      this.setUpItems();
      this.listenTo(this.getChildren(), {
        all: this.onAll,
        'change:_isActive': this.setVisitedStatus,
        'change:_isVisited': this.checkCompletionStatus
      });
      super.init();
    }

    restoreUserAnswers() {
      const booleanArray = this.get('_userAnswer');
      if (!booleanArray) return;
      this.getChildren().forEach((child, index) => child.set('_isVisited', booleanArray[index]));
    }

    storeUserAnswer() {
      const booleanArray = this.getChildren().map(child => child.get('_isVisited'));
      this.set('_userAnswer', booleanArray);
    }

    setUpItems() {
      const items = this.get('_items') || [];
      items.forEach((item, index) => item._index = index);
      this.setChildren(new Backbone.Collection(items, {
        model: ItemModel
      }));
    }

    getItem(index) {
      return this.getChildren().findWhere({
        _index: index
      });
    }

    getVisitedItems() {
      return this.getChildren().where({
        _isVisited: true
      });
    }

    getActiveItems() {
      return this.getChildren().where({
        _isActive: true
      });
    }

    getActiveItem() {
      return this.getChildren().findWhere({
        _isActive: true
      });
    }

    areAllItemsCompleted() {
      return this.getVisitedItems().length === this.getChildren().length;
    }

    checkCompletionStatus() {
      this.setVisitedStatus();
      this.storeUserAnswer();
      if (!this.areAllItemsCompleted()) return;
      this.setCompletionStatus();
    }

    reset() {
      let type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'hard';
      let canReset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.get('_canReset');
      const wasReset = super.reset(type, canReset);
      if (!wasReset) return false;
      this.getChildren().each(item => item.reset());
      return true;
    }

    resetActiveItems() {
      this.getChildren().each(item => item.toggleActive(false));
    }

    setActiveItem(index) {
      const item = this.getItem(index);
      if (!item) return;
      const activeItem = this.getActiveItem();
      if (activeItem) activeItem.toggleActive(false);
      item.toggleActive(true);
    }

  });

  class BlendedItemsComponentQuestionModel extends QuestionModel$1 {
    init() {
      ItemsComponentModel.prototype.init.call(this);
      super.init();
    }

    reset() {
      let type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'hard';
      let canReset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.get('_canReset');
      ItemsComponentModel.prototype.reset.call(this, type, canReset);
      return super.reset(type, canReset);
    }

  }

  Object.getOwnPropertyNames(ItemsComponentModel.prototype).forEach(name => {
    if (name === 'constructor' || name === 'init' || name === 'reset') return;
    Object.defineProperty(BlendedItemsComponentQuestionModel.prototype, name, {
      value: ItemsComponentModel.prototype[name]
    });
  });
  var ItemsQuestionModel$1 = __AMD("core/js/models/itemsQuestionModel", class ItemsQuestionModel extends BlendedItemsComponentQuestionModel {
    init() {
      super.init();
      this.set('_isRadio', this.isSingleSelect());
      this.listenTo(this.getChildren(), 'change:_isActive', this.checkCanSubmit);
      this.checkCanSubmit();
    }

    restoreUserAnswers() {
      if (!this.get('_isSubmitted')) return;
      const itemModels = this.getChildren();
      const userAnswer = this.get('_userAnswer');
      itemModels.each(item => {
        item.toggleActive(userAnswer[item.get('_index')]);
      });
      this.setQuestionAsSubmitted();
      this.markQuestion();
      this.setScore();
      this.setupFeedback();
    }

    setupRandomisation() {
      if (!this.get('_isRandom') || !this.get('_isEnabled')) return;
      const children = this.getChildren();
      children.set(children.shuffle());
    }

    canSubmit() {
      const activeItems = this.getActiveItems();
      return activeItems.length > 0;
    }

    storeUserAnswer() {
      const items = this.getChildren().slice(0);
      items.sort((a, b) => a.get('_index') - b.get('_index'));
      const userAnswer = items.map(itemModel => itemModel.get('_isActive'));
      this.set('_userAnswer', userAnswer);
    }

    isCorrect() {
      const allChildren = this.getChildren();
      const activeChildren = allChildren.filter(itemModel => itemModel.get('_isActive'));

      const isItemCorrect = itemModel => itemModel.get('_shouldBeSelected') && !itemModel.get('_isPartlyCorrect');

      const isItemPartlyCorrect = itemModel => itemModel.get('_isPartlyCorrect');

      const isItemIncorrect = itemModel => !itemModel.get('_shouldBeSelected') && !itemModel.get('_isPartlyCorrect');

      const sum = (list, predicate) => list.reduce((sum, item) => sum + (predicate(item) ? 1 : 0), 0);

      const props = {
        _numberOfRequiredAnswers: sum(allChildren, isItemCorrect),
        _numberOfCorrectAnswers: sum(activeChildren, isItemCorrect),
        _numberOfPartlyCorrectAnswers: sum(activeChildren, isItemPartlyCorrect),
        _numberOfIncorrectAnswers: sum(activeChildren, isItemIncorrect)
      };
      activeChildren.forEach(itemModel => itemModel.set('_isCorrect', itemModel.get('_shouldBeSelected')));
      props._isAtLeastOneCorrectSelection = props._numberOfCorrectAnswers || props._numberOfPartlyCorrectAnswers;
      const numberOfSelectableAnswers = this.get('_selectable');
      const hasSelectableCorrectAnswers = props._numberOfCorrectAnswers === numberOfSelectableAnswers;
      const hasAllCorrectAnswers = props._numberOfCorrectAnswers === props._numberOfRequiredAnswers;
      const hasCorrectAnswers = hasSelectableCorrectAnswers || hasAllCorrectAnswers;
      const hasIncorrectAnswers = props._numberOfIncorrectAnswers;
      const hasPartlyCorrectAnswers = props._numberOfPartlyCorrectAnswers;
      this.set(props);
      return hasCorrectAnswers && !hasIncorrectAnswers && !hasPartlyCorrectAnswers;
    }

    setScore() {
      const questionWeight = this.get('_questionWeight');
      const answeredCorrectly = this.get('_isCorrect');
      const score = answeredCorrectly ? questionWeight : 0;
      this.set('_score', score);
    }

    get score() {
      if (!this.get('_hasItemScoring')) return super.score;
      const children = this.getChildren()?.toArray() || [];
      return children.reduce((score, child) => score += child.get('_isActive') ? child.get('_score') || 0 : 0, 0);
    }

    get maxScore() {
      if (!this.get('_hasItemScoring')) return super.maxScore;
      const children = this.getChildren()?.toArray() || [];
      const scores = children.map(child => child.get('_score') || 0);
      scores.sort((a, b) => a - b);
      return scores.reverse().slice(0, this.get('_selectable')).filter(score => score > 0).reduce((maxScore, score) => maxScore += score, 0);
    }

    get minScore() {
      if (!this.get('_hasItemScoring')) return super.minScore;
      const children = this.getChildren()?.toArray() || [];
      const scores = children.map(child => child.get('_score') || 0);
      scores.sort((a, b) => a - b);
      return scores.slice(0, this.get('_selectable')).filter(score => score < 0).reduce((minScore, score) => minScore += score, 0);
    }

    setupFeedback() {
      if (!this.has('_feedback')) return;

      if (this.get('_isCorrect')) {
        this.setupCorrectFeedback();
        return;
      }

      if (this.isPartlyCorrect()) {
        this.setupPartlyCorrectFeedback();
        return;
      }

      const activeItem = this.getActiveItem();

      if (this.isSingleSelect() && activeItem.get('feedback')) {
        this.setupIndividualFeedback(activeItem);
        return;
      }

      this.setupIncorrectFeedback();
    }

    setupIndividualFeedback(selectedItem) {
      const json = this.toJSON();
      this.set({
        feedbackTitle: Handlebars.compile(this.getFeedbackTitle(this.get('_feedback')))(json),
        feedbackMessage: Handlebars.compile(selectedItem.get('feedback'))(json)
      });
    }

    isPartlyCorrect() {
      return this.get('_isAtLeastOneCorrectSelection');
    }

    resetUserAnswer() {
      this.set('_userAnswer', []);
    }

    isAtActiveLimit() {
      const selectedItems = this.getActiveItems();
      return selectedItems.length === this.get('_selectable');
    }

    isSingleSelect() {
      return this.get('_selectable') === 1;
    }

    getLastActiveItem() {
      const selectedItems = this.getActiveItems();
      return selectedItems[selectedItems.length - 1];
    }

    resetQuestion() {
      this.resetItems();
    }

    resetItems() {
      this.resetActiveItems();
      this.set('_isAtLeastOneCorrectSelection', false);
    }

    getInteractionObject() {
      const interactions = {
        correctResponsesPattern: [],
        choices: []
      };
      interactions.choices = this.getChildren().map(itemModel => {
        return {
          id: (itemModel.get('_index') + 1).toString(),
          description: itemModel.get('text')
        };
      });
      const correctItems = this.getChildren().filter(itemModel => {
        return itemModel.get('_shouldBeSelected');
      });
      interactions.correctResponsesPattern = [correctItems.map(itemModel => {
        return String(itemModel.get('_index') + 1);
      }).join('[,]')];
      return interactions;
    }

    getResponse() {
      const activeItems = this.getActiveItems();
      const activeIndexes = activeItems.map(itemModel => {
        return itemModel.get('_index') + 1;
      });
      return activeIndexes.join(',');
    }

    getResponseType() {
      return 'choice';
    }

    getCorrectAnswerAsText() {
      const globals = Adapt$1.course.get('_globals')._components['_' + this.get('_component')];

      const isSingleSelect = this.isSingleSelect();
      const ariaAnswer = isSingleSelect ? globals?.ariaCorrectAnswer : globals?.ariaCorrectAnswers;
      if (!ariaAnswer) return;
      const correctOptions = this.getChildren().where({
        _shouldBeSelected: true
      });
      const correctAnswer = isSingleSelect ? correctOptions[0]?.get('text') : correctOptions.map(correctOption => correctOption.get('text')).join('<br>');
      return Handlebars.compile(ariaAnswer)({
        correctAnswer
      });
    }

    getUserAnswerAsText() {
      const globals = Adapt$1.course.get('_globals')._components['_' + this.get('_component')];

      const isSingleSelect = this.isSingleSelect();
      const ariaAnswer = isSingleSelect ? globals?.ariaUserAnswer : globals?.ariaUserAnswers;
      if (!ariaAnswer) return;
      const selectedItems = this.getActiveItems();
      const userAnswer = isSingleSelect ? selectedItems[0].get('text') : selectedItems.map(selectedItem => selectedItem.get('text')).join('<br>');
      return Handlebars.compile(ariaAnswer)({
        userAnswer
      });
    }

  });

  var MatchingModel = __AMD("components/adapt-contrib-matching/js/MatchingModel", class MatchingModel extends ItemsQuestionModel$1 {
    toJSON() {
      const json = super.toJSON();
      json._items = this.get('_items');
      json._options = this.getChildren().toJSON();
      return json;
    }

    setUpItems() {
      let index = 0;
      const items = this.get('_items') || [];
      const options = items.reduce((options, item, itemIndex) => {
        item._index = itemIndex;
        const itemOptions = item._options || [];
        itemOptions.forEach((option, optionIndex) => {
          option._index = index++;
          option._optionIndex = optionIndex;
          option._itemIndex = item._index;
          option._shouldBeSelected = Boolean(option._isCorrect);
        });
        options.push(...itemOptions);
        return options;
      }, []);
      this.set({
        _items: items,
        _selectable: items.length
      });
      this.setChildren(new Backbone.Collection(options, {
        model: MatchingItemModel
      }));
    }

    setupInitialHighlighted() {
      this.get('_items')?.forEach(_ref => {
        let {
          _index
        } = _ref;
        const selectOption = this.getActiveItemOption(_index) || this.getFirstItemOption(_index);
        selectOption?.toggleHighlighted(true);
      });
    }

    resetItems() {
      super.resetItems();
      this.resetHighlightedItems();
      this.setupInitialHighlighted();
    }

    resetHighlightedItems() {
      this.getChildren().forEach(option => option.toggleHighlighted(false));
    }

    canSubmit() {
      const options = this.getChildren().models;
      const activeCount = options.reduce((count, option) => count + (option.get('_isActive') ? 1 : 0), 0);
      const canSubmit = activeCount === this.get('_selectable');
      return canSubmit;
    }

    getItemOptions(itemIndex) {
      return this.getChildren().filter(option => option.get('_itemIndex') === itemIndex);
    }

    getActiveItemOption(itemIndex) {
      return this.getItemOptions(itemIndex).find(option => option.get('_isActive'));
    }

    getFirstItemOption(itemIndex) {
      return this.getItemOptions(itemIndex)[0];
    }

    getCorrectItemOption(itemIndex) {
      const activeOption = this.getActiveItemOption(itemIndex);
      return activeOption.get('_shouldBeSelected') ? activeOption : this.getItemOptions(itemIndex).find(option => option.get('_shouldBeSelected'));
    }

    setHighlightedOption(optionIndex) {
      const itemIndex = this.getItem(optionIndex).get('_itemIndex');
      const itemOptions = this.getItemOptions(itemIndex);
      itemOptions.forEach(option => {
        const isHighlighted = option.get('_index') === optionIndex;
        option.toggleHighlighted(isHighlighted);
      });
    }

    setActiveOption(optionIndex) {
      const itemIndex = this.getItem(optionIndex).get('_itemIndex');
      const itemOptions = this.getItemOptions(itemIndex);
      itemOptions.forEach(option => {
        const isActive = option.get('_index') === optionIndex;
        option.toggleHighlighted(isActive);
        option.toggleActive(isActive);
      });
      this.unsetDuplicateOptions(optionIndex);
    }

    unsetDuplicateOptions(optionIndex) {
      const allowOnlyUniqueAnswers = this.get('_allowOnlyUniqueAnswers');
      if (!allowOnlyUniqueAnswers) return;
      const itemIndex = this.getItem(optionIndex).get('_itemIndex');
      const activeItemOption = this.getActiveItemOption(itemIndex);
      const activeItemOptionText = activeItemOption.get('text');
      const otherActiveOptions = this.getChildren().filter(option => option !== activeItemOption && option.get('_isActive'));
      otherActiveOptions.forEach(option => {
        const optionText = option.get('text');
        const hasMatchingText = activeItemOptionText === optionText;
        if (!hasMatchingText) return;
        option.toggleHighlighted(false);
        option.toggleActive(false);
      });
    }

    get maxScore() {
      if (!this.get('_hasItemScoring')) return super.maxScore;
      const items = this.get('_items') || [];
      const maxItemScores = items.map(_ref2 => {
        let {
          _index
        } = _ref2;
        const itemOptions = this.getItemOptions(_index);
        const optionScores = itemOptions.map(child => child.get('_score') || 0);
        optionScores.sort((a, b) => a - b);
        return optionScores[optionScores.length - 1] || 0;
      });
      maxItemScores.sort((a, b) => a - b);
      return maxItemScores.reverse().filter(score => score > 0).reduce((maxScore, score) => maxScore += score, 0);
    }

    get minScore() {
      if (!this.get('_hasItemScoring')) return super.minScore;
      const items = this.get('_items') || [];
      const minItemScores = items.map(_ref3 => {
        let {
          _index
        } = _ref3;
        const itemOptions = this.getItemOptions(_index);
        const optionScores = itemOptions.map(child => child.get('_score') || 0);
        optionScores.sort((a, b) => a - b);
        return optionScores[0] || 0;
      });
      minItemScores.sort((a, b) => a - b);
      return minItemScores.filter(score => score < 0).reduce((minScore, score) => minScore += score, 0);
    }

    getInteractionObject() {
      const items = this.get('_items');
      const interactions = {
        correctResponsesPattern: null,
        source: null,
        target: null
      };
      interactions.correctResponsesPattern = [items.map(item => {
        const itemPosition = item._index + 1;
        const itemOptions = this.getItemOptions(item._index).sort((a, b) => a.get('_index') - b.get('_index'));
        return [itemPosition, itemOptions.filter(option => option.get('_shouldBeSelected')).map(option => {
          const optionPosition = option.get('_optionIndex') + 1;
          return `${itemPosition}_${optionPosition}`;
        })].join('[.]');
      }).join('[,]')];
      interactions.source = items.map(item => {
        const itemPosition = item._index + 1;
        return {
          id: `${itemPosition}`,
          description: item.text
        };
      }).flat(Infinity);
      interactions.target = items.map(item => {
        const itemPosition = item._index + 1;
        const itemOptions = this.getItemOptions(item._index).sort((a, b) => a.get('_index') - b.get('_index'));
        return itemOptions.map(option => {
          const optionPosition = option.get('_optionIndex') + 1;
          return {
            id: `${itemPosition}_${optionPosition}`,
            description: option.get('text')
          };
        });
      }).flat(Infinity);
      return interactions;
    }

    getResponse() {
      const items = this.get('_items');
      const responses = items.map(_ref4 => {
        let {
          _index
        } = _ref4;
        const activeOption = this.getActiveItemOption(_index);
        const itemIndex = _index + 1;
        const optionIndex = activeOption.get('_optionIndex') + 1;
        return `${itemIndex}.${optionIndex}`;
      });
      return responses.join('#');
    }

    getResponseType() {
      return 'matching';
    }

    getCorrectAnswerAsText() {
      const correctAnswerTemplate = Adapt$1.course.get('_globals')._components._matching.ariaCorrectAnswer;

      const ariaAnswer = this.get('_items').map(item => {
        const correctOption = this.getCorrectItemOption(item._index);
        return Handlebars.compile(correctAnswerTemplate)({
          itemText: item.text,
          correctAnswer: correctOption.get('text')
        });
      }).join('<br>');
      return ariaAnswer;
    }

    getUserAnswerAsText() {
      const userAnswerTemplate = Adapt$1.course.get('_globals')._components._matching.ariaUserAnswer;

      const items = this.get('_items');
      const ariaAnswer = items.map(item => {
        const activeOption = this.getActiveItemOption(item._index);
        return Handlebars.compile(userAnswerTemplate)({
          itemText: item.text,
          userAnswer: activeOption.get('text')
        });
      }).join('<br>');
      return ariaAnswer;
    }

  });

  __AMD("components/adapt-contrib-matching/js/adapt-contrib-matching", components$1.register('matching', {
    view: MatchingView$1,
    model: MatchingModel
  }));

  class McqView extends QuestionView$1 {
    initialize() {
      this.onKeyPress = this.onKeyPress.bind(this);
      this.onItemSelect = this.onItemSelect.bind(this);
      this.onItemFocus = this.onItemFocus.bind(this);
      this.onItemBlur = this.onItemBlur.bind(this);
      super.initialize(...arguments);
    }

    setupQuestion() {
      this.model.setupRandomisation();
    }

    onQuestionRendered() {
      this.setReadyStatus();
    }

    onKeyPress(event) {
      if (event.which !== 13) return;
      this.onItemSelect(event);
    }

    onItemFocus(event) {
      if (!this.model.isInteractive()) return;
      const index = parseInt($(event.currentTarget).data('adapt-index'));
      const item = this.model.getChildren().findWhere({
        _index: index
      });
      item.set('_isHighlighted', true);
    }

    onItemBlur(event) {
      const index = $(event.currentTarget).data('adapt-index');
      const item = this.model.getChildren().findWhere({
        _index: index
      });
      item.set('_isHighlighted', false);
    }

    onItemSelect(event) {
      if (!this.model.isInteractive()) return;
      const index = $(event.currentTarget).data('adapt-index');
      const itemModel = this.model.getItem(index);
      let shouldSelect = !itemModel.get('_isActive');

      if (this.model.isSingleSelect()) {
        shouldSelect = true;
        this.model.resetActiveItems();
      } else if (shouldSelect && this.model.isAtActiveLimit()) {
        this.model.getLastActiveItem().toggleActive(false);
      }

      itemModel.toggleActive(shouldSelect);
    }

    resetQuestion() {
      this.model.resetItems();
    }

  }

  McqView.template = 'mcq.jsx';
  var McqView$1 = __AMD("components/adapt-contrib-mcq/js/McqView", McqView);

  var McqModel = __AMD("components/adapt-contrib-mcq/js/McqModel", class McqModel extends ItemsQuestionModel$1 {});

  __AMD("components/adapt-contrib-mcq/js/adapt-contrib-mcq", components$1.register('mcq', {
    model: McqModel,
    view: McqView$1
  }));

  class TextView extends ComponentView$1 {
    postRender() {
      this.setReadyStatus();
      this.setupInview();
    }

    setupInview() {
      const selector = this.getInviewElementSelector();
      if (!selector) return this.setCompletionStatus();
      this.setupInviewCompletion(selector);
    }

    getInviewElementSelector() {
      if (this.model.get('body')) return '.component__body';
      if (this.model.get('instruction')) return '.component__instruction';
      if (this.model.get('displayTitle')) return '.component__title';
      return null;
    }

  }

  TextView.template = 'text.jsx';
  var TextView$1 = __AMD("components/adapt-contrib-text/js/TextView", TextView);

  var TextModel = __AMD("components/adapt-contrib-text/js/TextModel", class TextModel extends ComponentModel$1 {});

  __AMD("components/adapt-contrib-text/js/adapt-contrib-text", components$1.register('text', {
    model: TextModel,
    view: TextView$1
  }));

  class MoralMachineGmcqView extends McqView$1 {
    onQuestionRendered() {
      this.$('.js-item-label').imageready(() => this.setReadyStatus());

      if (this.model.attributes._isComplete) {
        this.$('.btn__action').html(this.model.get('_buttons')["_reset"]["buttonText"]);
      }
    }

    onIsCompleteChange(model, isComplete) {
      this.$('.btn__action').html(model.get('_buttons')["_reset"]["buttonText"]);
    }

    onSubmitted() {
      this.$('.btn__action').html(this.model.get('_buttons')["_reset"]["buttonText"]);
    }

  }

  MoralMachineGmcqView.template = 'gmcq.jsx';
  var MoralMachineGmcqView$1 = __AMD("components/odi-mit-moral-machine-gmcq/js/MoralMachineGmcqView", MoralMachineGmcqView);

  var MoralMachineGmcqModel = __AMD("components/odi-mit-moral-machine-gmcq/js/MoralMachineGmcqModel", class MoralMachineGmcqModel extends McqModel {
    isCorrect() {
      return true;
    }

  });

  __AMD("components/odi-mit-moral-machine-gmcq/js/odi-mit-moral-machine-gmcq", Adapt$1.register('moral-machine-gmcq', {
    model: MoralMachineGmcqModel,
    view: MoralMachineGmcqView$1
  }));

  class MoralMachineResultsResultsModel extends ComponentModel$1 {
    init() {
      this.set('originalBody', this.get('body'));
      this.listenTo(Adapt$1, {
        'assessments:complete': this.onAssessmentComplete,
        'assessments:reset': this.onAssessmentReset
      });
      super.init(...arguments);
    }

    async checkIfAssessmentComplete() {
      if (!Adapt$1.assessment || this.get('_assessmentId') === undefined) {
        return;
      }

      const assessmentModel = Adapt$1.assessment.get(this.get('_assessmentId'));
      if (!assessmentModel || assessmentModel.length === 0) return;

      if (Adapt$1.config.get('_xapi')._queryURL) {
        await this.loadDataFromXAPI(assessmentModel);
      }

      const state = assessmentModel.getState();

      const isResetOnRevisit = assessmentModel.get('_assessment')._isResetOnRevisit;

      if (state.isComplete && (!state.allowResetIfPassed || !isResetOnRevisit)) {
        this.onAssessmentComplete(state, assessmentModel);
        return;
      }

      this.setVisibility();
    }

    initScoring(scoreObj, counts, multiplier) {
      for (let j = 0; j < scoreObj.length; j++) {
        if (scoreObj[j].choices == "Avoid Intervention") {
          counts["Intervene"] = (counts["Intervene"] || 0) + 1 * multiplier;
        }

        if (scoreObj[j].choices == "Save people in car") {
          counts["Save pedestrians"] = (counts["Save pedestrians"] || 0) + 1 * multiplier;
        }

        if (scoreObj[j].choices == "Uphold law") {
          counts["Disobey law"] = (counts["Disobey law"] || 0) + 1 * multiplier;
        }

        if (scoreObj[j].choices == "Save pets") {
          counts["Save humans"] = (counts["Save humans"] || 0) + 1 * multiplier;
        }

        if (scoreObj[j].choices == "Save more people") {
          counts["Save less people"] = (counts["Save less people"] || 0) + 1 * multiplier;
        }

        if (scoreObj[j].choices == "Save robbers") {
          counts["Save professionals"] = (counts["Save professionals"] || 0) + 1 * multiplier;
        }

        if (scoreObj[j].choices == "Save old") {
          counts["Save young"] = (counts["Save young"] || 0) + 1 * multiplier;
        }
      }

      return counts;
    }

    updateScoring(scoreObj, counts, multiplier) {
      let arr = [];

      for (let i = 0; i < scoreObj.length; i++) {
        arr.push(scoreObj[i].choices);
      }

      arr.forEach(x => {
        counts[x] = (counts[x] || 0) + 1 * multiplier;

        if (x == "Avoid Intervention") {
          counts["Intervene"] = counts["Intervene"] - 1 * multiplier;
        }

        if (x == "Save people in car") {
          counts["Save pedestrians"] = counts["Save pedestrians"] - 1 * multiplier;
        }

        if (x == "Uphold law") {
          counts["Disobey law"] = counts["Disobey law"] - 1 * multiplier;
        }

        if (x == "Save pets") {
          counts["Save humans"] = counts["Save humans"] - 1 * multiplier;
        }

        if (x == "Save more people") {
          counts["Save less people"] = counts["Save less people"] - 1 * multiplier;
        }

        if (x == "Save robbers") {
          counts["Save professionals"] = counts["Save professionals"] - 1 * multiplier;
        }

        if (x == "Save old") {
          counts["Save young"] = counts["Save young"] - 1 * multiplier;
        }
      });
      return counts;
    }

    async fetchDataFromXAPI(componentID) {
      var xapiQueryEndpoint = Adapt$1.config.get('_xapi')._queryURL;

      var activityID = Adapt$1.config.get('_xapi')._activityID;

      var componentURI = encodeURIComponent(activityID + "#/id/" + componentID);
      var dataURL = xapiQueryEndpoint + "?activity=" + componentURI;
      const response = await fetch(dataURL);
      const json = await response.json();
      return json;
    }

    async loadDataFromXAPI(assessmentModel) {
      var components = assessmentModel._getAllQuestionComponents();

      for (let ci = 0; ci < components.length; ci++) {
        var component = components[ci];
        component["APIdata"] = await this.fetchDataFromXAPI(component.get("_id"));
      }
    }

    onAssessmentComplete(state, assessmentModel) {
      if (this.get('_assessmentId') === undefined || this.get('_assessmentId') !== state.id) return;
      let counts = {},
          othersCounts = {},
          savedCount = {},
          allCharacterCount = {},
          finalArr = [];

      assessmentModel._getAllQuestionComponents();

      assessmentModel._getAllQuestionComponents().forEach(component => {
        let responses = {};
        let totalResponses = 0;

        if (component.APIdata) {
          responses = component.APIdata.responses;
          totalResponses = component.APIdata.completion;
        }

        for (let i = 0; i < 2; i++) {
          var item = component.getChildren().models[i].attributes.scoring;
          counts = this.initScoring(item, counts, 1);

          if (component.APIdata) {
            othersCounts = this.initScoring(item, othersCounts, totalResponses);
            othersCounts = this.updateScoring(item, othersCounts, responses[i].count);
          }
        }

        let scoreObj = {};

        try {
          scoreObj = component.getActiveItems()[0].attributes.scoring;
          counts = this.updateScoring(scoreObj, counts, 1);
        } catch (error) {
          return;
        }

        function getCharacterCounts(activeItem) {
          var saved = activeItem.attributes["saved characters"];

          for (let i = 0; i < saved.length; i++) {
            var Character = saved[i]["character"];
            var count = saved[i]["number"];
            allCharacterCount[Character] = (allCharacterCount[Character] || 0) + count;
          }

          var killed = activeItem.attributes["killed characters"];

          for (let i = 0; i < killed.length; i++) {
            var Character = killed[i]["character"];
            var count = killed[i]["number"];
            allCharacterCount[Character] = (allCharacterCount[Character] || 0) + count;
          }

          return allCharacterCount;
        }

        function getSavedCounts(activeItem) {
          var saved = activeItem.attributes["saved characters"];

          for (let i = 0; i < saved.length; i++) {
            var Character = saved[i]["character"];
            var count = saved[i]["number"];
            var gender = Character.split(" ")[0];
            counts[gender] = (counts[gender] || 0) + count;
            savedCount[Character] = (savedCount[Character] || 0) + count;
          }

          return savedCount;
        }

        allCharacterCount = getCharacterCounts(component.getActiveItems()[0]);
        savedCount = getSavedCounts(component.getActiveItems()[0]);
      });

      finalArr.push([savedCount, allCharacterCount, counts]);
      let keys = {};
      let values = {};

      try {
        keys = Object.values(finalArr[0][2]);
        values = Object.keys(finalArr[0][2]);
      } catch (error) {
        return;
      }

      let results = {
        counts: finalArr[0][2],
        savedCount: finalArr[0][0],
        allCharacterCount: finalArr[0][1],
        othersCounts: othersCounts,
        keys: keys,
        values: values
      };
      this.setResults(results);
      this.set({
        _state: state,
        attempts: state.attempts,
        attemptsSpent: state.attemptsSpent,
        attemptsLeft: state.attemptsLeft,
        score: state.counts,
        scoreAsPercent: state.scoreAsPercent,
        maxScore: state.maxScore,
        isPass: state.isPass,
        results: results
      });
      this.checkRetryEnabled(state);
      this.setFeedbackText(this.getFeedbackText(results));
      this.toggleVisibility(true);
    }

    getResults() {
      return this.results;
    }

    setResults(object) {
      this.results = object;
    }

    checkRetryEnabled(state) {
      const assessmentModel = Adapt$1.assessment.get(state.id);
      if (!assessmentModel.canResetInPage()) return false;
      const isAttemptsLeft = state.attemptsLeft > 0 || state.attemptsLeft === 'infinite';
      const showRetry = isAttemptsLeft;
      this.set({
        _isRetryEnabled: showRetry,
        retryFeedback: showRetry ? this.get('_retry').feedback : ''
      });
    }

    setFeedbackText(outputs) {
      var template = Handlebars.compile(this.get('_feedbackTemplate'));
      var feedback = template(outputs);
      this.set({
        feedback,
        body: this.get('_completionBody')
      });
    }

    getUserAnswersTemplate() {
      let userAnswers = {
        "age-preference": {
          "Save old": 0,
          "Save young": 0
        },
        "saving-more-lives": {
          "Save less people": 0,
          "Save more people": 0
        },
        "gender-preference": {
          "Female": 0,
          "Male": 0
        },
        "save-people-in-car": {
          "Save people in car": 0,
          "Save pedestrians": 0
        },
        "species-preference": {
          "Save humans": 0,
          "Save pets": 0
        },
        "upholding-the-law": {
          "Uphold law": 0,
          "Disobey law": 0
        },
        "social-value-preference": {
          "Save professionals": 0,
          "Save robbers": 0
        },
        "avoid-intervention": {
          "Avoid Intervention": 0,
          "Intervene": 0
        }
      };
      return userAnswers;
    }

    nestedToUnestedChanges(counts, userAnswers) {
      if (counts == undefined) {
        return;
      } else {
        for (const [key1, value] of Object.entries(counts)) {
          for (const [key2, _] of Object.entries(userAnswers)) {
            if (userAnswers[key2].hasOwnProperty(key1)) {
              userAnswers[key2][key1] += value;
            }
          }
        }
      }

      return userAnswers;
    }

    removeZeroValues(userAnswers) {
      const keys = Object.keys(userAnswers);
      Object.values(userAnswers);
      keys.map(key => {
        userAnswers[key];
        Object.keys(userAnswers[key]);
      });
      const finalObj = {};
      keys.forEach(key => {
        const property = userAnswers[key];
        const propertyKeys = Object.keys(property);
        const hasNonZeroEntries = propertyKeys.some(propertyKey => property[propertyKey] !== 0);

        if (hasNonZeroEntries) {
          finalObj[key] = userAnswers[key];
        }
      });
      return finalObj;
    }

    getBarPosition(values) {
      var total = 0;
      var firstValue = -1;

      for (let key in values) {
        total += values[key];

        if (firstValue < 0) {
          firstValue = values[key];
        }
      }

      var totalPercent = 100 / total;
      var newCountOne = firstValue * totalPercent;
      return newCountOne;
    }

    getFeedbackText(results) {
      let outputs = {};
      let userAnswers = this.getUserAnswersTemplate();
      let othersAnswers = this.getUserAnswersTemplate();

      try {
        userAnswers = this.nestedToUnestedChanges(results.counts, userAnswers);
        othersAnswers = this.nestedToUnestedChanges(results.othersCounts, othersAnswers);
      } catch (error) {
        console.log(error);
      }

      userAnswers = this.removeZeroValues(userAnswers);
      othersAnswers = this.removeZeroValues(othersAnswers);
      var savedTableDetail = "";
      var percentages = [];
      Object.keys(results["allCharacterCount"]).forEach(character => {
        let total = results["allCharacterCount"][character];
        let saved = results.savedCount[character] || 0;
        percentages.push([character, saved / total || 0]);
      });
      percentages.sort(function (a, b) {
        return b[1] - a[1];
      });
      percentages.forEach(function (item) {
        let character = item[0];
        let total = results["allCharacterCount"][character];
        let saved = results.savedCount[character] || 0;

        if (character.split(" ")[0] == "Pet") {
          savedTableDetail += "<td><img class='pet-summary' src='assets/character/" + character.replaceAll(" ", "_") + ".png'></img><br/>" + saved + "/" + total + "</td>";
        } else {
          savedTableDetail += "<td><img class='character-summary' src='assets/character/" + character.replaceAll(" ", "_") + ".png'></img><br/>" + saved + "/" + total + "</td>";
        }
      });
      outputs["characters-saved"] = `
      <sub-section id="mostSaved" class="characters">
        <h3>Saved characters / Total</h3>
        <table id="Characters">
          <tr>
          ${savedTableDetail}
          </tr>
        </table>
      </sub-section>
      `;
      let barPositions = {};

      if (userAnswers.length === 0) {
        return;
      } else {
        Object.keys(userAnswers).map(key => {
          barPositions[key] = {
            "user": this.getBarPosition(userAnswers[key]),
            "others": this.getBarPosition(othersAnswers[key])
          };
        });
      }

      for (let key in barPositions) {
        outputs[key] = `
          <sub-section id="question-${key}">
            <h3>${key.replaceAll("-", " ")}</h3>
            <panel>
              <left><img class="results-img" src="./assets/${key}_left.svg"/></left>
              <canvas id="canvas-${key}" height="60" width="300">
              </canvas>
              <right><img class="results-img" src="./assets/${key}_right.svg"/></right>
            </panel>
          </sub-section>
          <script>
            if (typeof ctxArray === "undefined") {
              var ctxArray = [];
            }
            ctxArray["${key}"] = []
            ctxArray["${key}"]["ctx"] = document.getElementById("canvas-${key}").getContext("2d");
            ctxArray["${key}"]["c"] = document.getElementById("canvas-${key}");
            drawTemplate(ctxArray["${key}"]["c"],ctxArray["${key}"]["ctx"]);
            drawLine(ctxArray["${key}"]["c"],ctxArray["${key}"]["ctx"],${barPositions[key]["user"]},"You","top");
            drawLine(ctxArray["${key}"]["c"],ctxArray["${key}"]["ctx"],${barPositions[key]["others"]},"Others","bottom");
          </script>
        `;
      }
      return outputs;
    }

    setVisibility() {
      if (!Adapt$1.assessment) return;
      const assessmentModel = Adapt$1.assessment.get(this.get('_assessmentId'));
      if (!assessmentModel || assessmentModel.length === 0) return;
      const state = assessmentModel.getState();
      const isAttemptInProgress = state.attemptInProgress;
      const isComplete = !isAttemptInProgress && state.isComplete;
      const isVisibleBeforeCompletion = this.get('_isVisibleBeforeCompletion') || false;
      const isVisible = isVisibleBeforeCompletion || isComplete;
      this.toggleVisibility(isVisible);
    }

    toggleVisibility(isVisible) {
      if (isVisible === undefined) {
        isVisible = !this.get('_isVisible');
      }

      this.set('_isVisible', isVisible, {
        pluginName: 'assessmentResults'
      });
    }

    checkCompletion() {
      if (this.get('_setCompletionOn') === 'pass' && !this.get('isPass')) {
        return;
      }

      this.setCompletionStatus();
    }

    onAssessmentReset(state) {
      if (this.get('_assessmentId') === undefined || this.get('_assessmentId') !== state.id) return;
      let resetType = this.get('_resetType');

      if (!resetType || resetType === 'inherit') {
        resetType = state.resetType || 'hard';
      }

      this.reset(resetType, true);
    }

    reset() {
      this.set({
        body: this.get('originalBody'),
        state: null,
        feedback: '',
        retryFeedback: '',
        _isRetryEnabled: false
      });
      super.reset(...arguments);
    }

  }

  var MoralMachineResultsModel = __AMD("components/odi-moralMachineResults/js/moralMachineResultsModel", MoralMachineResultsResultsModel);

  class MoralMachineResultsView extends ComponentView$1 {
    events() {
      return {
        "click .js-assessment-retry-btn": "onRetryClicked"
      };
    }

    preRender() {
      this.model.setLocking("_isVisible", false);
      this.listenTo(Adapt$1.parentView, "preRemove", function () {
        this.model.unsetLocking("_isVisible");
      });
      this.listenTo(this.model, {
        "change:_feedbackBand": this.addClassesToArticle,
        "change:body": this.render
      });
    }

    postRender() {
      this.model.checkIfAssessmentComplete();
      this.setReadyStatus();
      this.setupInviewCompletion(".component__inner", this.model.checkCompletion.bind(this.model));
    }

    onRetryClicked() {
      const state = this.model.get('_state');
      Adapt$1.assessment.get(state.id).reset(null, wasReset => {
        if (!wasReset) return;

        if (this.model.get("_retry")._routeToAssessment === true) {
          Adapt$1.navigateToElement("." + state.articleId);
        }
      });
    }

    addClassesToArticle(model, value) {
      if (!value || !value._classes) return;
      this.$el.parents(".article").addClass(value._classes);
    }

  }

  MoralMachineResultsView.template = "assessmentResults";
  var MoralMachineResultsView$1 = __AMD("components/odi-moralMachineResults/js/moralMachineResultsView", MoralMachineResultsView);

  __AMD("components/odi-moralMachineResults/js/odi-moralMachineResults", Adapt$1.register("moralMachineResults", {
    model: MoralMachineResultsModel,
    view: MoralMachineResultsView$1
  }));

  var BlockSliderView = {
    _isReady: false,
    _disableAnimationOnce: false,
    events: {
      "click [data-block-slider]": "_onBlockSliderClick"
    },
    preRender: function () {
      ArticleView$1.prototype.preRender.call(this);

      if (!this.model.isBlockSliderEnabled()) {
        this.$el.addClass('is-disabled');
        return;
      }

      this._blockSliderPreRender();
    },
    _blockSliderPreRender: function () {
      Adapt$1.wait.for(function (done) {
        this.resolveQueue = done;
      }.bind(this));

      this._blockSliderSetupEventListeners();
    },
    _blockSliderSetupEventListeners: function () {
      this._blockSliderResizeHeight = this._blockSliderResizeHeight.bind(this);
      this.listenTo(Adapt$1, {
        "device:resize": this._onBlockSliderResize,
        "device:changed": this._onBlockSliderDeviceChanged,
        "page:scrollTo": this._onBlockSliderPageScrollTo,
        "page:scrolledTo": this._onBlockSliderPageScrolledTo
      });
      this.listenToOnce(Adapt$1, "remove", this._onBlockSliderRemove);
      this.listenToOnce(this.model, "change:_isReady", this._onBlockSliderReady);
      var duration = this.model.get("_articleBlockSlider")._slideAnimationDuration || 200;
      this._blockSliderHideOthers = _.debounce(this._blockSliderHideOthers.bind(this), duration);
    },
    render: function () {
      if (this.model.isBlockSliderEnabled()) {
        this._blockSliderRender();
      } else ArticleView$1.prototype.render.call(this);
    },
    _blockSliderRender: function () {
      Adapt$1.trigger(this.constructor.type + 'View:preRender view:render', this);

      this._blockSliderConfigureVariables();

      var data = this.model.toJSON();
      var template = Handlebars.templates['articleBlockSlider-article'];
      this.$el.html(template(data));
      Adapt$1.trigger(this.constructor.type + 'View:render', this);
      this.addChildren();
      this.$el.addClass('abs');
      this.delegateEvents();
      this.$el.imageready(function () {
        _.delay(this._blockSliderPostRender.bind(this), 500);
      }.bind(this));
      return this;
    },
    _blockSliderConfigureVariables: function () {
      var blocks = this.model.getChildren().models.filter(model => model.isTypeGroup('block'));
      var totalBlocks = blocks.length;
      var itemButtons = [];

      for (var i = 0, l = totalBlocks; i < l; i++) {
        itemButtons.push({
          _className: (i === 0 ? "home" : "not-home") + (" i" + i),
          _index: i,
          _includeNumber: i !== 0,
          _title: blocks[i].get('title')
        });
      }

      this.model.set({
        _currentBlock: 0,
        _totalBlocks: totalBlocks,
        _itemButtons: itemButtons
      });
    },
    _blockSliderConfigureControls: function () {
      this.model.get("_articleBlockSlider")._slideAnimationDuration || 200;
      if (this._disableAnimationOnce) animate = false;

      var _currentBlock = this.model.get("_currentBlock");

      var _totalBlocks = this.model.get("_totalBlocks");

      var $left = this.$el.find("[data-block-slider='left']");
      var $right = this.$el.find("[data-block-slider='right']");

      if (_currentBlock === 0) {
        $left.a11y_cntrl_enabled(false);
        $right.a11y_cntrl_enabled(true);
      } else if (_currentBlock == _totalBlocks - 1) {
        $left.a11y_cntrl_enabled(true);
        $right.a11y_cntrl_enabled(false);
      } else {
        $left.a11y_cntrl_enabled(true);
        $right.a11y_cntrl_enabled(true);
      }

      var $indexes = this.$el.find("[data-block-slider='index']");
      $indexes.a11y_cntrl_enabled(true).removeClass("is-selected");
      $indexes.eq(_currentBlock).a11y_cntrl_enabled(false).addClass("is-selected is-visited");
      var $blocks = this.$el.find(".block");
      if (!$blocks.length) return;
      $blocks.a11y_on(false).eq(_currentBlock).a11y_on(true);
    },
    _blockSliderSetButtonLayout: function () {
      var buttonsLength = this.model.get('_itemButtons').length;
      var itemwidth = 100 / buttonsLength;
      this.$('.js-abs-btn-tab').css({
        width: itemwidth + '%'
      });
    },
    _blockSliderPostRender: function () {
      this._blockSliderConfigureControls(false);

      this._onBlockSliderDeviceChanged();

      var startIndex = this.model.get("_articleBlockSlider")._startIndex || 0;

      this._blockSliderMoveIndex(startIndex, false);

      Adapt$1.trigger(this.constructor.type + 'View:postRender', this);
    },
    _onBlockSliderReady: function () {
      this._blockSliderHideOthers();

      _.delay(function () {
        this._blockSliderConfigureControls(false);

        this._onBlockSliderResize();

        this.resolveQueue();
        this._isReady = true;
      }.bind(this), 250);

      this.$(".component").on("resize", this._blockSliderResizeHeight);
    },
    _onBlockSliderClick: function (event) {
      event.preventDefault();
      var id = $(event.currentTarget).attr("data-block-slider");

      switch (id) {
        case "left":
          this._blockSliderMoveLeft();

          break;

        case "index":
          var index = parseInt($(event.currentTarget).attr("data-block-slider-index"));

          this._blockSliderMoveIndex(index);

          break;

        case "right":
          this._blockSliderMoveRight();

          break;
      }
    },
    _blockSliderMoveLeft: function () {
      if (this.model.get("_currentBlock") === 0) return;
      var index = this.model.get("_currentBlock");

      this._blockSliderMoveIndex(--index);
    },
    _blockSliderMoveIndex: function (index, animate) {
      if (this.model.get("_currentBlock") != index) {
        this.model.set("_currentBlock", index);
        Adapt$1.trigger('media:stop');

        this._blockSliderSetVisible(this.model.getChildren().models[index], true);

        this._blockSliderResizeHeight(animate);

        this._blockSliderScrollToCurrent(animate);

        this._blockSliderConfigureControls(animate);
      }

      var duration = this.model.get("_articleBlockSlider")._slideAnimationDuration || 200;
      if (this._disableAnimationOnce) animate = false;

      if (animate !== false) {
        _.delay(function () {
          $(window).resize();
        }, duration);

        return;
      }

      $(window).resize();
    },
    _blockSliderMoveRight: function () {
      if (this.model.get("_currentBlock") == this.model.get("_totalBlocks") - 1) return;
      var index = this.model.get("_currentBlock");

      this._blockSliderMoveIndex(++index);
    },
    _blockSliderScrollToCurrent: function (animate) {
      var isEnabled = this._blockSliderIsEnabledOnScreenSizes();

      var $container = this.$el.find(".js-abs-slide-container");

      if (!isEnabled) {
        return $container.scrollLeft(0);
      }

      var blocks = this.$el.find(".block");
      var blockWidth = $(blocks[0]).outerWidth();
      var lastIndex = blocks.length - 1;
      var currentBlock = this.model.get('_currentBlock');
      var isRTL = Adapt$1.config.get('_defaultDirection') === 'rtl';
      var totalLeft = isRTL ? (lastIndex - currentBlock) * blockWidth : currentBlock * blockWidth;

      this._blockSliderShowAll();

      var duration = this.model.get('_articleBlockSlider')._slideAnimationDuration || 200;
      if (this._disableAnimationOnce) animate = false;

      if (animate === false) {
        _.defer(function () {
          $container.scrollLeft(totalLeft);

          this._blockSliderHideOthers();
        }.bind(this));

        return;
      }

      $container.stop(true).animate({
        scrollLeft: totalLeft
      }, duration, function () {
        $container.scrollLeft(totalLeft);

        this._blockSliderHideOthers();
      }.bind(this));
    },
    _blockSliderIsEnabledOnScreenSizes: function () {
      var isEnabledOnScreenSizes = this.model.get("_articleBlockSlider")._isEnabledOnScreenSizes;

      var sizes = isEnabledOnScreenSizes.split(" ");

      if (sizes.indexOf(Adapt$1.device.screenSize) > -1) {
        return true;
      }

      return false;
    },
    _blockSliderShowAll: function () {
      this._blockSliderHideOthers.cancel();

      this.model.getChildren().models.filter(model => model.isTypeGroup('block')).forEach(function (block) {
        this._blockSliderSetVisible(block, true);
      }.bind(this));
    },
    _blockSliderHideOthers: function () {
      var currentIndex = this.model.get('_currentBlock');
      this.model.getChildren().models.filter(model => model.isTypeGroup('block')).forEach(function (block, index) {
        var makeVisible = index === currentIndex;

        this._blockSliderSetVisible(block, makeVisible);
      }.bind(this));
    },
    _blockSliderSetVisible: function (model, makeVisible) {
      this.$el.find("." + model.get('_id') + " *").css("visibility", makeVisible ? "" : "hidden");
    },
    _onBlockSliderResize: function () {
      this._blockSliderResizeWidth(false);

      this._blockSliderResizeHeight(false);

      this._blockSliderScrollToCurrent(false);

      this._blockSliderResizeTab();
    },
    _blockSliderResizeHeight: function (animate) {
      if (!this._isReady) animate = false;
      var $container = this.$el.find(".js-abs-slide-container");

      var isEnabled = this._blockSliderIsEnabledOnScreenSizes();

      if (!isEnabled) {
        this._blockSliderShowAll();

        return $container.velocity("stop").css({
          "height": "",
          "min-height": ""
        });
      }

      var currentBlock = this.model.get("_currentBlock");
      var $blocks = this.$el.find(".block");
      var currentHeight = $container.height();
      var blockHeight = $blocks.eq(currentBlock).height();
      var maxHeight = -1;
      $container.find(".block").each(function () {
        if ($(this).height() > maxHeight) {
          maxHeight = $(this).height();
        }
      });
      var duration = (this.model.get("_articleBlockSlider")._heightAnimationDuration || 200) * 2;
      if (this._disableAnimationOnce) animate = false;

      if (this.model.get("_articleBlockSlider")._hasUniformHeight) {
        if (animate === false) {
          $container.css({
            "height": maxHeight + "px"
          });
        } else {
          $container.velocity("stop").velocity({
            "height": maxHeight + "px"
          }, {
            duration: duration
          });
        }
      } else if (currentHeight <= blockHeight) {
        if (animate === false) {
          $container.css({
            "height": blockHeight + "px"
          });
        } else {
          $container.velocity("stop").velocity({
            "height": blockHeight + "px"
          }, {
            duration: duration
          });
        }
      } else if (currentHeight > blockHeight) {
        if (animate === false) {
          $container.css({
            "height": blockHeight + "px"
          });
        } else {
          $container.velocity("stop").velocity({
            "height": blockHeight + "px"
          }, {
            duration: duration
          });
        }
      }

      var minHeight = this.model.get("_articleBlockSlider")._minHeight;

      if (minHeight) {
        $container.css({
          "min-height": minHeight + "px"
        });
      }
    },
    _blockSliderResizeTab: function () {
      if (!this.model.get("_articleBlockSlider")._hasTabs) return;

      this._blockSliderSetButtonLayout();

      this.$('.js-abs-btn-tab').css({
        height: ""
      });
      var parentHeight = this.$('.js-abs-btn-tab').parent().height();
      this.$('.js-abs-btn-tab').css({
        height: parentHeight + 'px'
      });
      var toolbarHeight = this.$('.js-abs-btn-tab-container').height();
      var additionalMargin = '30';
      this.$('.js-abs-btn-tab-container').css({
        top: '-' + (toolbarHeight + additionalMargin / 2) + 'px'
      });
      var toolbarMargin = parseFloat(toolbarHeight) + parseFloat(additionalMargin);
      this.$('.js-abs-slide-container').css({
        marginTop: toolbarMargin + 'px'
      });
    },
    _blockSliderResizeWidth: function () {
      var isEnabled = this._blockSliderIsEnabledOnScreenSizes();

      var $blockContainer = this.$el.find(".js-abs-block-container");
      var $blocks = this.$el.find(".block");

      if (!isEnabled) {
        $blocks.css("width", "");
        return $blockContainer.css({
          "width": "100%"
        });
      }

      var $container = this.$el.find(".js-abs-slide-container");
      $blocks.css("width", $container.width() + "px");
      var blockWidth = $($blocks[0]).outerWidth();
      var totalWidth = $blocks.length * blockWidth;
      $blockContainer.width(totalWidth + "px");
    },
    _onBlockSliderDeviceChanged: function () {
      var showToolbar = this._blockSliderIsEnabledOnScreenSizes();

      this.$('.js-abs-toolbar, .js-abs-toolbar-bottom').toggleClass('u-display-none', !showToolbar);

      _.delay(function () {
        $(window).resize();
      }, 250);
    },
    _onBlockSliderPageScrollTo: function (selector) {
      this._disableAnimationOnce = true;

      _.defer(function () {
        this._disableAnimationOnce = false;
      }.bind(this));

      if (typeof selector === "object") selector = selector.selector;

      if (!this._blockSliderIsEnabledOnScreenSizes()) {
        return;
      }

      if (this.$el.find(selector).length === 0) return;
      var id = selector.substr(1);
      var model = Adapt$1.findById(id);
      if (!model) return;
      var block = model.get('_type') === 'block' ? model : model.findAncestor('blocks');
      if (!block) return;
      this.model.getChildren().models.filter(model => model.isTypeGroup('block')).find((item, index) => {
        if (item.get('_id') !== block.get('_id')) return;

        _.defer(() => this._blockSliderMoveIndex(index, false));

        return true;
      });
    },
    _onBlockSliderPageScrolledTo: function () {
      _.defer(function () {
        this._blockSliderScrollToCurrent(false);
      }.bind(this));
    },
    _onBlockSliderRemove: function () {
      this._blockSliderRemoveEventListeners();
    },
    _blockSliderRemoveEventListeners: function () {
      this.$(".component").off("resize", this._blockSliderResizeHeight);
      this.stopListening(Adapt$1, "device:changed", this._onBlockSliderDeviceChanged);
    }
  };
  var ArticleViewExtension = __AMD("extensions/adapt-articleBlockSlider/js/adapt-articleView", BlockSliderView);

  var BlockSliderModel = {
    isBlockSliderEnabled: function () {
      var config = this.get('_articleBlockSlider');

      if (!config || !config._isEnabled || config._isDisabledWhenAccessibilityActive && Adapt$1.accessibility.isActive()) {
        return false;
      }

      return true;
    }
  };
  var ArticleModelExtension = __AMD("extensions/adapt-articleBlockSlider/js/adapt-articleModel", BlockSliderModel);

  var ArticleViewInitialize$1 = ArticleView$1.prototype.initialize;

  ArticleView$1.prototype.initialize = function (options) {
    if (this.model.get("_articleBlockSlider")) {
      _.extend(this, ArticleViewExtension);
    }

    return ArticleViewInitialize$1.apply(this, arguments);
  };

  var ArticleModelInitialize$1 = ArticleModel$1.prototype.initialize;

  ArticleModel$1.prototype.initialize = function (options) {
    if (this.get("_articleBlockSlider")) {
      _.extend(this, ArticleModelExtension);

      var returnValue = ArticleModelInitialize$1.apply(this, arguments);
      return returnValue;
    }

    return ArticleModelInitialize$1.apply(this, arguments);
  };

  const AssessmentView = {
    postRender() {
      ArticleView$1.prototype.postRender.call(this);

      if (this.model.isAssessmentEnabled()) {
        this._setupEventListeners();

        const config = this.model.getConfig();

        if (config?._questions?._canShowMarking === false) {
          this.$el.addClass('has-no-marking');
        }
      }

      this.$el.addClass('is-assessment');
    },

    _setupEventListeners() {
      this.listenTo(Adapt$1, {
        'assessments:complete': this._onAssessmentComplete,
        'assessments:reset': this._onAssessmentReset,
        remove: this._onRemove
      });
    },

    _removeEventListeners() {
      this.stopListening(Adapt$1, {
        'assessments:complete': this._onAssessmentComplete,
        'assessments:reset': this._onAssessmentReset
      });
    },

    _onAssessmentComplete(state, model) {
      if (state.id !== this.model.get('_assessment')._id) return;
      logging$1.info('assessment complete', state, model);
    },

    _onAssessmentReset(state, model) {
      if (state.id !== this.model.get('_assessment')._id) return;
      logging$1.info('assessment reset', state, model);
    },

    _onRemove() {
      this._removeEventListeners();
    }

  };
  var AdaptAssessmentArticleView = __AMD("extensions/adapt-contrib-assessment/js/adapt-assessmentArticleView", AssessmentView);

  class QuestionBank {
    constructor(quizBankId, articleId) {
      this._bankId = quizBankId;
      this._articleId = articleId;
      this._unusedQuestionBlocks = null;
      this._count = null;
    }

    calculateAvailableQuestionBlocks(count) {
      this._count = parseInt(count);
      const articleModel = data$1.findById(this._articleId);
      const children = articleModel.getAvailableChildModels();
      this._availableQuestionBlocks = children.map(blockModel => {
        if (blockModel.get('_assessment')?._quizBankID !== this._bankId) return null;
        return blockModel;
      }).filter(Boolean);
      const availableQuestionBlockIds = this._availableQuestionBlocks?.map(block => block.get('_id')) || [];
      const unusedQuestionBlockIds = this._unusedQuestionBlocks?.map(block => block.get('_id')) || [];
      const haveBlocksChanged = Boolean(_.difference(unusedQuestionBlockIds, availableQuestionBlockIds).length);
      if (!haveBlocksChanged) return;
      this._unusedQuestionBlocks = null;
    }

    getRandomQuestionBlocks() {
      const questionBlocks = [];
      let i = 0;

      while (i++ < this._count) {
        const nextBlock = this.unusedQuestionBlocks.shift();
        questionBlocks.push(nextBlock);
      }

      return questionBlocks;
    }

    get unusedQuestionBlocks() {
      const hasUnusedQuestion = Boolean(this._unusedQuestionBlocks?.length);

      if (!hasUnusedQuestion) {
        this._unusedQuestionBlocks = _.shuffle(this._availableQuestionBlocks.slice(0));
      }

      return this._unusedQuestionBlocks;
    }

  }

  var QuestionBank$1 = __AMD("extensions/adapt-contrib-assessment/js/adapt-assessmentQuestionBank", QuestionBank);

  let givenIdCount = 0;
  const assessmentConfigDefaults = {
    _isEnabled: true,
    _questions: {
      _resetType: 'soft',
      _canShowFeedback: false,
      _canShowMarking: false,
      _canShowModelAnswer: false
    },
    _suppressMarking: false,
    _isPercentageBased: true,
    _scoreToPass: 100,
    _correctToPass: 100,
    _includeInTotalScore: true,
    _assessmentWeight: 1,
    _isResetOnRevisit: true,
    _reloadPageOnReset: true,
    _attempts: 'infinite',
    _allowResetIfPassed: false
  };
  const AssessmentModel = {
    _getCurrentQuestionComponents() {
      return this.findDescendantModels('block').filter(block => block.get('_isAvailable')).reduce((questions, block) => questions.concat(block.findDescendantModels('question')), []);
    },

    _getAllQuestionComponents() {
      return this.findDescendantModels('question');
    },

    _postInitialize() {
      if (!this.isAssessmentEnabled()) return;
      const assessmentConfig = this.getConfig();
      Object.assign(this, {
        _originalChildModels: null,
        _questionBanks: null,
        _forceResetOnRevisit: false
      });
      let attemptsLeft;

      switch (assessmentConfig._attempts) {
        case 'infinite':
        case 0:
        case undefined:
        case -1:
        case null:
          attemptsLeft = 'infinite';
          break;

        default:
          attemptsLeft = assessmentConfig._attempts;
          break;
      }

      this.set({
        _assessmentCompleteInSession: false,
        _attemptInProgress: false,
        _isAssessmentComplete: false,
        _numberOfQuestionsAnswered: 0,
        _lastAttemptScoreAsPercent: 0,
        _attempts: attemptsLeft,
        _attemptsLeft: attemptsLeft,
        _attemptsSpent: 0
      });
      this.listenToOnce(Adapt$1, 'app:dataReady', this._onDataReady);
      this.listenTo(Adapt$1, 'remove', this._onRemove);
    },

    init() {
      this._originalChildModels = this.getChildren().models;
      this.setupCurrentQuestionComponents();

      this._setAssessmentOwnershipOnChildrenModels();

      this._updateQuestionsState();
    },

    setupCurrentQuestionComponents() {
      const assessmentQuestionsConfig = this.getConfig()._questions;

      this._getAllQuestionComponents().forEach(component => {
        component.set({
          _canShowFeedback: assessmentQuestionsConfig._canShowFeedback,
          _canShowMarking: assessmentQuestionsConfig._canShowMarking,
          _canShowModelAnswer: assessmentQuestionsConfig._canShowModelAnswer
        });
      });
    },

    _setAssessmentOwnershipOnChildrenModels() {
      const assessmentConfig = this.get('_assessment');
      const childConfig = {
        _isPartOfAssessment: true,
        _assessmentId: assessmentConfig._id
      };

      for (const blockModel of this._originalChildModels) {
        blockModel.set(childConfig);
        blockModel.setOnChildren(childConfig);
      }
    },

    checkIfResetOnRevisit() {},

    _onDataReady() {
      Adapt$1.assessment.register(this);
    },

    _setupAssessmentData(force, callback) {
      const assessmentConfig = this.getConfig();
      const state = this.getState();
      const hasAttemptsLeft = state.attemptsLeft > 0 || state.attemptsLeft === 'infinite';
      const isFirstAttempt = state.attemptsSpent === 0;
      const shouldResetOnRevisit = (isFirstAttempt || assessmentConfig._isResetOnRevisit) && !this.get('_attemptInProgress');
      const shouldResetAssessment = shouldResetOnRevisit && !state.isPass && hasAttemptsLeft || force === true;
      const shouldResetQuestions = shouldResetOnRevisit && (state.allowResetIfPassed || !state.isPass) || force === true;

      if (shouldResetAssessment || shouldResetQuestions) {
        Adapt$1.trigger('assessments:preReset', this.getState(), this);
      }

      let quizModels;

      if (shouldResetAssessment) {
        if (isFirstAttempt || assessmentConfig?._questions?._resetType === 'hard') {
          this.set({
            _numberOfQuestionsAnswered: 0,
            _isAssessmentComplete: false,
            _assessmentCompleteInSession: false,
            _score: 0
          });
        } else {
          this.set({
            _assessmentCompleteInSession: false
          });
        }

        this.getChildren().models = this._originalChildModels;

        if (assessmentConfig?._banks._isEnabled && assessmentConfig?._banks._split.length > 1) {
          quizModels = this._setupBankedAssessment();
        } else if (assessmentConfig?._randomisation._isEnabled) {
          quizModels = this._setupRandomisedAssessment();
        }
      }

      if (!quizModels) {
        quizModels = this.getChildren().models;
      } else if (quizModels.length === 0) {
        quizModels = this.getChildren().models;
        logging$1.warn('assessment: Not enough unique questions to create a fresh assessment, using last selection');
      }

      this.getChildren().models = quizModels;
      this.setupCurrentQuestionComponents();

      if (shouldResetAssessment || shouldResetQuestions) {
        this._resetQuestions();

        this.set('_attemptInProgress', true);
        Adapt$1.trigger('assessments:reset', this.getState(), this);
      }

      if (!state.isComplete) {
        this.set('_attemptInProgress', true);
      }

      this._overrideQuestionComponentSettings();

      this._setupQuestionListeners();

      this._checkNumberOfQuestionsAnswered();

      this._updateQuestionsState();

      Adapt$1.assessment.saveState();
      this.trigger('reset');

      if (shouldResetAssessment || shouldResetQuestions) {
        Adapt$1.trigger('assessments:postReset', this.getState(), this);
      }
    },

    _setupBankedAssessment() {
      const assessmentConfig = this.getConfig();

      this._setupBanks();

      let questionModels = this._questionBanks.flatMap(questionBank => questionBank.getRandomQuestionBlocks());

      if (assessmentConfig._banks._randomisation) {
        questionModels = _.shuffle(questionModels);
      }

      return questionModels;
    },

    _setupBanks() {
      const assessmentConfig = this.getConfig();

      const bankSplits = assessmentConfig._banks._split.split(',');

      const hasBankSplitsChanged = bankSplits.length !== this._questionBanks?.length;

      if (hasBankSplitsChanged) {
        this._questionBanks = [];
      }

      bankSplits.forEach((count, index) => {
        const bankId = index + 1;
        const articleId = this.get('_id');
        this._questionBanks[bankId] = this._questionBanks[bankId] || new QuestionBank$1(bankId, articleId);

        this._questionBanks[bankId].calculateAvailableQuestionBlocks(count);
      });
    },

    _setupRandomisedAssessment() {
      const assessmentConfig = this.getConfig();
      const randomisationModel = assessmentConfig._randomisation;
      const blockModels = this.getChildren().models;

      let questionModels = _.shuffle(blockModels);

      if (randomisationModel._blockCount > 0) {
        questionModels = questionModels.slice(0, randomisationModel._blockCount);
      }

      return questionModels;
    },

    _overrideQuestionComponentSettings() {
      const newSettings = this._getMarkingSettings();

      const questionConfig = this.getConfig()._questions;

      if (Object.prototype.hasOwnProperty.call(questionConfig, '_canShowFeedback')) {
        newSettings._canShowFeedback = questionConfig._canShowFeedback;
      }

      if (!_.isEmpty(newSettings)) {
        const questionComponents = this._getAllQuestionComponents();

        questionComponents.forEach(model => model.set(newSettings, {
          pluginName: '_assessment'
        }));
      }
    },

    _setupQuestionListeners() {
      this._removeQuestionListeners();

      this.listenTo(this, 'bubble:change:_isInteractionComplete', this._onCompletionEvent);
    },

    _checkNumberOfQuestionsAnswered() {
      const questionComponents = this._getCurrentQuestionComponents();

      const numberOfQuestionsAnswered = questionComponents.filter(model => model.get('_isInteractionComplete')).length;
      this.set('_numberOfQuestionsAnswered', numberOfQuestionsAnswered);
    },

    _removeQuestionListeners() {
      this.stopListening(this, 'bubble:change:_isInteractionComplete', this._onCompletionEvent);
    },

    _onCompletionEvent(event) {
      if (event.target?.isTypeGroup('block')) return this._onBlockCompleted(event.target, event.value);
      if (event.target?.isTypeGroup('questions')) return this._onQuestionCompleted(event.target, event.value);
    },

    _onBlockCompleted(blockModel, value) {
      if (value === false) return;
      const questionModels = blockModel.findDescendantModels('question');
      questionModels.forEach(questionModel => {
        this._onQuestionCompleted(questionModel, value);
      });
      if (!blockModel.get('_isInteractionComplete')) return;

      this._checkAssessmentComplete();
    },

    _onQuestionCompleted(questionModel, value) {
      if (value === false) return;
      if (!questionModel.get('_isInteractionComplete')) return;

      const numberOfQuestionsAnswered = this._getCurrentQuestionComponents().reduce((count, question) => count += question.get('_isSubmitted') ? 1 : 0, 0);

      this.set('_numberOfQuestionsAnswered', numberOfQuestionsAnswered);

      this._updateQuestionsState();

      Adapt$1.assessment.saveState();

      this._checkAssessmentComplete();
    },

    _checkAssessmentComplete() {
      const allQuestionsAdded = this.get('_requireCompletionOf') !== Number.POSITIVE_INFINITY;
      if (!allQuestionsAdded) return;
      const numberOfQuestionsAnswered = this.get('_numberOfQuestionsAnswered');

      const allQuestionsAnswered = numberOfQuestionsAnswered >= this._getCurrentQuestionComponents().length;

      if (!allQuestionsAnswered) return;

      this._onAssessmentComplete();
    },

    _onAssessmentComplete() {
      const wasAttemptInProgess = this.get('_attemptInProgress');
      if (!wasAttemptInProgess) return;
      this.set('_attemptInProgress', false);

      this._spendAttempt();

      const _scoreAsPercent = this._getScoreAsPercent();

      const _score = this._getScore();

      const _maxScore = this._getMaxScore();

      const _minScore = this._getMinScore();

      const _correctCount = this._getCorrectCount();

      const _correctAsPercent = this._getCorrectAsPercent();

      const _questionCount = this._getQuestionCount();

      this.set({
        _scoreAsPercent,
        _score,
        _maxScore,
        _minScore,
        _correctAsPercent,
        _correctCount,
        _questionCount,
        _lastAttemptScoreAsPercent: _scoreAsPercent,
        _assessmentCompleteInSession: true,
        _isAssessmentComplete: true
      });

      this._updateQuestionsState();

      this._checkIsPass();

      this._removeQuestionListeners();

      if (this._isMarkingSuppressionEnabled() && (!this._isAttemptsLeft() || this._isPassed())) {
        _.defer(() => {
          this._overrideMarkingSettings();

          this._refreshQuestions();
        });
      }

      Adapt$1.trigger('assessments:complete', this.getState(), this);
    },

    _updateQuestionsState() {
      const questionComponents = this._getCurrentQuestionComponents();

      const questions = questionComponents.map(model => ({
        _id: model.get('_id'),
        _isCorrect: model.get('_isCorrect') ?? null
      }));
      this.set('_questions', questions);
    },

    _checkIsPass() {
      const assessmentConfig = this.getConfig();
      const isPercentageBased = assessmentConfig._isPercentageBased;
      const scoreToPass = assessmentConfig._scoreToPass;
      const correctToPass = assessmentConfig._correctToPass || 0;
      const scoreAsPercent = this.get('_scoreAsPercent');
      const score = this.get('_score');
      const correctAsPercent = this.get('_correctAsPercent');
      const correctCount = this.get('_correctCount');
      const isPass = isPercentageBased ? scoreAsPercent >= scoreToPass && correctAsPercent >= correctToPass : score >= scoreToPass && correctCount >= correctToPass;
      this.set('_isPass', isPass);
    },

    _getMarkingSettings() {
      let markingSettings = {};

      if (this._shouldSuppressMarking()) {
        markingSettings = {
          _canShowMarking: false,
          _canShowModelAnswer: false
        };
      } else {
        const questionConfig = this.getConfig()._questions;

        if (Object.prototype.hasOwnProperty.call(questionConfig, '_canShowModelAnswer')) {
          markingSettings._canShowModelAnswer = questionConfig._canShowModelAnswer;
        }

        if (Object.prototype.hasOwnProperty.call(questionConfig, '_canShowMarking')) {
          markingSettings._canShowMarking = questionConfig._canShowMarking;
        }
      }

      return markingSettings;
    },

    _overrideMarkingSettings() {
      const newMarkingSettings = this._getMarkingSettings();

      const questionComponents = this._getAllQuestionComponents();

      questionComponents.forEach(model => model.set(newMarkingSettings, {
        pluginName: '_assessment'
      }));
    },

    _refreshQuestions() {
      const questionComponents = this._getCurrentQuestionComponents();

      questionComponents.forEach(model => model.refresh());
    },

    _shouldSuppressMarking() {
      return this._isMarkingSuppressionEnabled() && this._isAttemptsLeft() && !this._isPassed();
    },

    _isMarkingSuppressionEnabled() {
      const assessmentConfig = this.getConfig();
      return assessmentConfig._suppressMarking;
    },

    _isAttemptsLeft() {
      if (this.get('_attemptsLeft') === 0) return false;
      return true;
    },

    _isPassed() {
      return this.get('_isAssessmentComplete') && this.get('_isPass');
    },

    _spendAttempt() {
      if (!this._isAttemptsLeft()) return false;
      let attemptsSpent = this.get('_attemptsSpent');
      this.set('_attemptsSpent', ++attemptsSpent);
      if (this.get('_attempts') === 'infinite') return true;
      let attemptsLeft = this.get('_attemptsLeft');
      this.set('_attemptsLeft', --attemptsLeft);
      return true;
    },

    _getScore() {
      const questionComponents = this._getCurrentQuestionComponents();

      const score = questionComponents.reduce((score, model) => score += model.score || 0, 0);
      return score;
    },

    _getMaxScore() {
      const questionComponents = this._getCurrentQuestionComponents();

      const maxScore = questionComponents.reduce((maxScore, model) => maxScore += model.maxScore || 0, 0);
      return maxScore;
    },

    _getMinScore() {
      const questionComponents = this._getCurrentQuestionComponents();

      const minScore = questionComponents.reduce((minScore, model) => minScore += model.minScore || 0, 0);
      return minScore;
    },

    _getScoreAsPercent() {
      const minScore = this._getMinScore();

      const maxScore = this._getMaxScore();

      const score = this._getScore();

      const range = maxScore - minScore;
      return range === 0 ? 0 : Math.round((score - minScore) / range * 100);
    },

    _getCorrectCount() {
      return this._getCurrentQuestionComponents().reduce((count, model) => count += model.get('_isCorrect') ? 1 : 0, 0);
    },

    _getQuestionCount() {
      return this._getCurrentQuestionComponents().length;
    },

    _getCorrectAsPercent() {
      const questionCount = this._getQuestionCount();

      return questionCount === 0 ? 0 : Math.round(this._getCorrectCount() / questionCount * 100);
    },

    _getLastAttemptScoreAsPercent() {
      return this.get('_lastAttemptScoreAsPercent');
    },

    _checkReloadPage() {
      if (!this.canResetInPage()) return false;
      const parentId = this.getParent().get('_id');
      const currentLocation = location$2._currentId;
      if (currentLocation !== parentId) return false;
      if (!this.get('_isReady')) return false;
      return true;
    },

    _reloadPage(callback) {
      const assessmentConfig = this.getConfig();
      this._forceResetOnRevisit = true;
      this.listenToOnce(Adapt$1, 'pageView:ready', async () => {
        if (assessmentConfig._scrollToOnReset) {
          await router$1.navigateToElement(this.get('_id'));
        }

        callback();
      });

      _.delay(() => {
        Backbone.history.navigate('#/id/' + location$2._currentId, {
          replace: true,
          trigger: true
        });
      }, 250);
    },

    _resetQuestions() {
      const assessmentConfig = this.getConfig();

      const questionModels = this._getCurrentQuestionComponents();

      questionModels.forEach(model => model.reset(assessmentConfig._questions._resetType, true));
    },

    _onRemove() {
      this._removeQuestionListeners();
    },

    _setCompletionStatus() {
      this.set({
        _isComplete: true,
        _isInteractionComplete: true
      });
    },

    _checkIfQuestionsWereRestored() {
      if (this.get('_assessmentCompleteInSession')) return;
      if (!this.get('_isAssessmentComplete')) return;
      let wereQuestionsRestored = true;
      const questions = this.get('_questions');

      for (const question of questions) {
        const questionModel = data$1.findById(question._id);

        if (questionModel.get('_isAvailable') && !questionModel.get('_isSubmitted')) {
          wereQuestionsRestored = false;
          break;
        }
      }

      if (!wereQuestionsRestored) {
        this.set('_assessmentCompleteInSession', true);
        return true;
      }

      return false;
    },

    isAssessmentEnabled() {
      if (this.get('_assessment')?._isEnabled) return true;
      return false;
    },

    canResetInPage() {
      const assessmentConfig = this.getConfig();
      if (assessmentConfig._reloadPageOnReset === false) return false;
      return true;
    },

    reset(force, callback) {
      const assessmentConfig = this.getConfig();
      force = this._forceResetOnRevisit || force === true;
      this._forceResetOnRevisit = false;

      const isPageReload = this._checkReloadPage();

      if (this.get('_assessmentCompleteInSession') && !assessmentConfig._isResetOnRevisit && !isPageReload && !force) {
        if (typeof callback === 'function') callback(false);
        return false;
      }

      const wereQuestionsRestored = this._checkIfQuestionsWereRestored();

      force = force || wereQuestionsRestored;

      if (force && !this._isAttemptsLeft()) {
        this.set({
          _attemptsLeft: this.get('_attempts'),
          _attemptsSpent: 0
        });
      }

      const allowResetIfPassed = this.get('_assessment')._allowResetIfPassed;

      if (!this._isAttemptsLeft() && !force && !allowResetIfPassed) {
        if (typeof callback === 'function') callback(false);
        return false;
      }

      if (!isPageReload) {
        this._setupAssessmentData(force);

        if (typeof callback === 'function') callback(true);
      } else {
        this._reloadPage(() => {
          if (typeof callback === 'function') callback(true);
        });
      }

      return true;
    },

    getSaveState() {
      const state = this.getState();
      let blocks;
      const cfg = this.getConfig();
      const banksActive = cfg._banks?._isEnabled && cfg._banks._split.length > 1;
      const randomisationActive = cfg._randomisation?._isEnabled;

      if (!banksActive && !randomisationActive) {
        blocks = this.findDescendantModels('block');
      } else {
        blocks = state.questions.map(question => data$1.findById(question._id).getParent());
      }

      blocks = [...new Set(blocks)].filter(block => block.trackingPosition);
      const blockTrackingPositions = blocks.map(block => block.trackingPosition);
      const blockCompletion = blocks.map(block => {
        const questions = block.findDescendantModels('question');
        return questions.map(question => question.get('_isCorrect') || false);
      });
      const blockData = [blockTrackingPositions, blockCompletion];
      const saveState = [state.isComplete ? 1 : 0, state.attemptsSpent, state.maxScore || 0, state.score, state.attemptInProgress ? 1 : 0, state.minScore || 0, state.correctAsPercent || 0, state.correctCount || 0, state.questionCount || 0];
      const dataPackage = [saveState, blockData];
      return dataPackage;
    },

    setRestoreState(dataPackage) {
      const restoreState = dataPackage[0];
      const blockData = dataPackage[1];

      const _isAssessmentComplete = restoreState[0] === 1;

      const attempts = this.get('_attempts');
      const _attemptsSpent = restoreState[1];
      const maxScore = restoreState[2];
      const score = restoreState[3];

      const _scoreAsPercent = score ? Math.round(score / maxScore * 100) : 0;

      const _attemptInProgress = restoreState[4] === 1;

      const minScore = restoreState[5];
      const correctAsPercent = restoreState[6];
      const correctCount = restoreState[7];
      const questionCount = restoreState[8];
      const blocks = blockData[0].map(trackingPosition => {
        if (typeof trackingPosition === 'number') {
          return data$1.findWhere({
            _trackingId: trackingPosition
          });
        }

        return data$1.findByTrackingPosition(trackingPosition);
      });

      if (blocks.length) {
        const nonBlockChildren = this.getChildren().models.filter(model => !model.isTypeGroup('block'));
        this.getChildren().models = blocks.concat(nonBlockChildren);
      }

      const _questions = [];
      blocks.forEach((block, blockIndex) => {
        const blockQuestions = block.findDescendantModels('question');
        blockQuestions.forEach((question, questionIndex) => {
          _questions.push({
            _id: question.get('_id'),
            _isCorrect: blockData[1][blockIndex][questionIndex]
          });
        });
      });
      this.set({
        _isAssessmentComplete,
        _assessmentCompleteInSession: false,
        _attemptsSpent,
        _attemptInProgress,
        _attemptsLeft: attempts === 'infinite' ? attempts : attempts - _attemptsSpent,
        _maxScore: maxScore || this._getMaxScore(),
        _minScore: minScore || this._getMinScore(),
        _score: score || 0,
        _scoreAsPercent,
        _correctAsPercent: correctAsPercent || 0,
        _correctCount: correctCount || 0,
        _questions,
        _questionCount: questionCount || 0,
        _lastAttemptScoreAsPercent: _scoreAsPercent
      });
      if (_isAssessmentComplete) this._checkIsPass();
      Adapt$1.trigger('assessments:restored', this.getState(), this);
    },

    getState() {
      const assessmentConfig = this.getConfig();
      const state = {
        id: assessmentConfig._id,
        type: 'article-assessment',
        pageId: this.getParent().get('_id'),
        articleId: this.get('_id'),
        isEnabled: assessmentConfig._isEnabled,
        isComplete: this.get('_isAssessmentComplete'),
        isPercentageBased: assessmentConfig._isPercentageBased,
        scoreToPass: assessmentConfig._scoreToPass,
        score: this.get('_score'),
        scoreAsPercent: this.get('_scoreAsPercent'),
        maxScore: this.get('_maxScore'),
        minScore: this.get('_minScore'),
        correctCount: this.get('_correctCount'),
        correctAsPercent: this.get('_correctAsPercent'),
        correctToPass: assessmentConfig._correctToPass,
        questionCount: this.get('_questionCount'),
        isPass: this.get('_isPass'),
        includeInTotalScore: assessmentConfig._includeInTotalScore,
        assessmentWeight: assessmentConfig._assessmentWeight,
        attempts: this.get('_attempts'),
        attemptsSpent: this.get('_attemptsSpent'),
        attemptsLeft: this.get('_attemptsLeft'),
        attemptInProgress: this.get('_attemptInProgress'),
        lastAttemptScoreAsPercent: this.get('_lastAttemptScoreAsPercent'),
        questions: this.get('_questions'),
        resetType: assessmentConfig._questions._resetType,
        allowResetIfPassed: assessmentConfig._allowResetIfPassed,
        questionModels: new Backbone.Collection(this._getCurrentQuestionComponents())
      };
      return state;
    },

    getConfig() {
      let assessmentConfig = this.get('_assessment');

      if (!assessmentConfig) {
        assessmentConfig = $.extend(true, {}, assessmentConfigDefaults);
      } else {
        assessmentConfig = $.extend(true, {}, assessmentConfigDefaults, assessmentConfig);
      }

      if (assessmentConfig._id === undefined) {
        assessmentConfig._id = 'givenId' + givenIdCount++;
      }

      this.set('_assessment', assessmentConfig);
      return assessmentConfig;
    }

  };
  var AdaptAssessmentArticleModel = __AMD("extensions/adapt-contrib-assessment/js/adapt-assessmentArticleModel", AssessmentModel);

  const assessmentsConfigDefaults = {
    _isPercentageBased: true,
    _scoreToPass: 100,
    _isDefaultsLoaded: true
  };

  class Assessment extends Backbone.Controller {
    initialize() {
      this._assessments = Object.assign([], {
        _byPageId: {},
        _byAssessmentId: {}
      });
      this.listenTo(Adapt$1, {
        'assessments:complete': this._onAssessmentsComplete,
        'router:location': this._checkResetAssessmentsOnRevisit,
        'router:plugin': this._handleRoute,
        'app:dataReady': this._onDataReady
      });
    }

    _onAssessmentsComplete(state) {
      const assessmentId = state.id;
      state.isComplete = true;
      if (assessmentId === undefined) return;

      if (!this._getStateByAssessmentId(assessmentId)) {
        logging$1.warn('assessments: state was not registered when assessment was created');
      }

      this.saveState();

      this._setPageProgress();

      this._checkAssessmentsComplete();
    }

    _restoreModelState(assessmentModel) {
      if (!this._saveStateModel) {
        this._saveStateModel = offlineStorage$3.get('a');
      }

      if (this._saveStateModel) {
        const state = assessmentModel.getState();

        if (this._saveStateModel[state.id]) {
          assessmentModel.setRestoreState(offlineStorage$3.deserialize(this._saveStateModel[state.id]));
        }
      }
    }

    _handleRoute(plugin, id) {
      if (plugin !== 'assessment' && plugin !== 'article-assessment' || id === undefined) {
        return;
      }

      if (!data$1.findById(id)) {
        const assessment = Adapt$1.assessment._assessments._byAssessmentId[id];

        if (assessment) {
          id = assessment.get('_id');
        } else {
          logging$1.warn('Assessment not found with _id: ' + id);
          return;
        }
      }

      _.defer(() => {
        Backbone.history.navigate('#/id/' + id, {
          trigger: true,
          replace: true
        });
      });
    }

    _checkResetAssessmentsOnRevisit(toObject) {
      if (toObject._contentType !== 'page') return;

      const pageAssessmentModels = this._getAssessmentByPageId(toObject._currentId);

      if (pageAssessmentModels === undefined) return;
      wait$1.for(function resetAllAssessments(allAssessmentHaveReset) {
        const numberOfAssessments = pageAssessmentModels.length;
        let numberOfResetAssessments = 0;
        const forceAssessmentReset = false;
        pageAssessmentModels.forEach(model => {
          model.reset(forceAssessmentReset, () => {
            numberOfResetAssessments++;
            const haveAllModelsReset = numberOfResetAssessments === numberOfAssessments;

            if (!haveAllModelsReset) {
              return;
            }

            allAssessmentHaveReset();
          });
        });
      });

      this._setPageProgress();
    }

    _onDataReady() {
      this._assessments = Object.assign([], {
        _byPageId: {},
        _byAssessmentId: {}
      });
      this._restoredCount = 0;
    }

    _checkAssessmentsComplete() {
      let allAssessmentsComplete = true;
      let assessmentToPostBack = 0;

      const states = this._getStatesByAssessmentId();

      const assessmentStates = [];

      for (const id in states) {
        const state = states[id];
        if (!state.includeInTotalScore) continue;

        if (!state.isComplete) {
          allAssessmentsComplete = false;
          break;
        }

        assessmentToPostBack++;
        assessmentStates.push(state);
      }

      if (!allAssessmentsComplete || assessmentToPostBack === 0) return false;

      if (assessmentToPostBack === 1) {
        this._setupSingleAssessmentConfiguration(assessmentStates[0]);
      }

      _.defer(() => Adapt$1.trigger('assessment:complete', this.getState()));

      return true;
    }

    _setupSingleAssessmentConfiguration(assessmentState) {
      const assessmentsConfig = Adapt$1.course.get('_assessment');
      $.extend(true, assessmentsConfig, {
        _isPercentageBased: assessmentState.isPercentageBased,
        _scoreToPass: assessmentState.scoreToPass
      });
      Adapt$1.course.set('_assessment', assessmentsConfig);
    }

    _getAssessmentByPageId(pageId) {
      return this._assessments._byPageId[pageId];
    }

    _getStateByAssessmentId(assessmentId) {
      if (assessmentId === undefined) {
        return null;
      }

      return this._assessments._byAssessmentId[assessmentId].getState();
    }

    _getStatesByAssessmentId() {
      const states = {};

      for (const assessmentModel of this._assessments) {
        if (!assessmentModel.get('_isAvailable')) continue;
        const state = assessmentModel.getState();
        states[state.id] = state;
      }

      return states;
    }

    _setPageProgress() {
      for (const [id, assessments] of Object.entries(this._assessments._byPageId)) {
        const availableAssessments = assessments.filter(model => model.get('_isAvailable'));
        const assessmentsTotal = availableAssessments.length;
        let assessmentsPassed = 0;

        for (const assessment of availableAssessments) {
          const assessmentState = assessment.getState();
          if (assessmentState.includeInTotalScore && !assessmentState.isPass) continue;

          if (assessmentState.isComplete) {
            assessmentsPassed++;
          }
        }

        const pageModel = data$1.findById(id);
        pageModel?.set({
          _subProgressTotal: assessmentsTotal,
          _subProgressComplete: assessmentsPassed
        });
      }
    }

    _addToAssessmentIdMap(id, model) {
      if (id === undefined) {
        logging$1.warn('An assessment has been registered with an undefined value for "_id"');
        return;
      }

      if (id === '') {
        logging$1.warn('An assessment has been registered with an empty value for "_id"');
      }

      if (!this._assessments._byAssessmentId[id]) {
        this._assessments._byAssessmentId[id] = model;
      } else {
        logging$1.warn('An assessment with an _id of "' + id + '" already exists!');
      }
    }

    _setupQuestionNumbering() {
      const getRelatedQuestions = data => {
        const currentAssessmentId = data._assessmentId;
        const currentAssessment = Adapt$1.assessment.get(currentAssessmentId);
        return currentAssessment.getState().questions;
      };

      Handlebars.registerHelper('questionNumber', function getQuestionNumber() {
        const data = this.view?.model.toJSON() || this;
        if (!data._isPartOfAssessment) return;

        const related = _.pluck(getRelatedQuestions(data), '_id');

        return related.indexOf(data._id) + 1;
      });
      Handlebars.registerHelper('questionCount', function getTotalQuestions() {
        const data = this.view ? this.view.model.toJSON() : this;
        if (!data._isPartOfAssessment) return;
        return getRelatedQuestions(data).length;
      });
    }

    register(assessmentModel) {
      const state = assessmentModel.getState();
      const assessmentId = state.id;
      const pageId = state.pageId;

      if (this._assessments._byPageId[pageId] === undefined) {
        this._assessments._byPageId[pageId] = [];
      }

      this._assessments._byPageId[pageId].push(assessmentModel);

      this._addToAssessmentIdMap(assessmentId, assessmentModel);

      this._assessments.push(assessmentModel);

      this._restoreModelState(assessmentModel);

      this._restoredCount++;
      Adapt$1.trigger('assessments:register', state, assessmentModel);

      this._setPageProgress();

      this._setupQuestionNumbering();

      if (this._restoredCount === this._assessments.length) {
        Adapt$1.trigger('assessment:restored', this.getState());
      }
    }

    get(id) {
      return id === undefined ? this._assessments.slice(0) : this._assessments._byAssessmentId[id];
    }

    saveState() {
      this._saveStateModel = {};

      for (const assessmentModel of this._assessments) {
        const state = assessmentModel.getState();
        this._saveStateModel[state.id] = offlineStorage$3.serialize(assessmentModel.getSaveState());
      }

      offlineStorage$3.set('a', this._saveStateModel);
    }

    getConfig() {
      let assessmentsConfig = Adapt$1.course.get('_assessment');

      if (assessmentsConfig?._isDefaultsLoaded) {
        return assessmentsConfig;
      }

      if (assessmentsConfig === undefined) {
        assessmentsConfig = $.extend(true, {}, assessmentsConfigDefaults);
      } else {
        assessmentsConfig = $.extend(true, {}, assessmentsConfigDefaults, assessmentsConfig);
      }

      Adapt$1.course.set('_assessment', assessmentsConfig);
      return assessmentsConfig;
    }

    getState() {
      const assessmentsConfig = this.getConfig();
      let score = 0;
      let maxScore = 0;
      let minScore = 0;
      let correctCount = 0;
      let questionCount = 0;
      let assessments = 0;

      const states = this._getStatesByAssessmentId();

      let assessmentsComplete = 0;

      for (const id in states) {
        const state = states[id];
        if (!state.includeInTotalScore) continue;
        if (state.isComplete) assessmentsComplete++;
        assessments++;
        maxScore += state.maxScore / state.assessmentWeight;
        minScore += state.minScore / state.assessmentWeight;
        score += state.score / state.assessmentWeight;
        correctCount += state.correctCount / state.assessmentWeight;
        questionCount += state.questionCount / state.assessmentWeight;
      }

      const isComplete = assessmentsComplete === assessments;
      const scoreRange = maxScore - minScore;
      const scoreAsPercent = scoreRange === 0 ? 0 : Math.round((score - minScore) / scoreRange * 100);
      const correctAsPercent = questionCount === 0 ? 0 : Math.round(correctCount / questionCount * 100);

      if (assessmentsConfig._correctToPass === undefined) {
        logging$1.warnOnce('Assessment course config is missing _correctToPass');
      }

      const scoreToPass = assessmentsConfig._scoreToPass;
      const correctToPass = assessmentsConfig._correctToPass || scoreToPass;
      const isPercentageBased = assessmentsConfig._isPercentageBased;
      const isPass = isComplete && (isPercentageBased ? scoreAsPercent >= scoreToPass && correctAsPercent >= correctToPass : score >= scoreToPass && correctCount >= correctToPass);
      const canRetry = Object.values(states).some(state => {
        const isFailed = !state.isPass;
        const hasAttemptsLeft = state.attemptsLeft > 0 || state.attemptsLeft === 'infinite';
        return isFailed && hasAttemptsLeft;
      });
      return {
        isComplete,
        isPercentageBased,
        isPass,
        maxScore,
        minScore,
        score,
        scoreToPass,
        scoreAsPercent,
        correctCount,
        correctAsPercent,
        correctToPass,
        questionCount,
        assessmentsComplete,
        assessments,
        canRetry
      };
    }

  }

  __AMD("extensions/adapt-contrib-assessment/js/assessment", Adapt$1.assessment = new Assessment());

  const ArticleViewInitialize = ArticleView$1.prototype.initialize;

  ArticleView$1.prototype.initialize = function (options) {
    if (this.model.get('_assessment')?._isEnabled === true) {
      Object.assign(this, AdaptAssessmentArticleView);
    }

    return ArticleViewInitialize.apply(this, arguments);
  };

  const ArticleModelInitialize = ArticleModel$1.prototype.initialize;

  ArticleModel$1.prototype.initialize = function (options) {
    if (this.get('_assessment')?._isEnabled === true) {
      Object.assign(this, AdaptAssessmentArticleModel);
      const returnValue = ArticleModelInitialize.apply(this, arguments);

      this._postInitialize();

      return returnValue;
    }

    return ArticleModelInitialize.apply(this, arguments);
  };

  function getMMCorrectness(questionModels) {
    const userAnswer = questionModels[0].attributes._userAnswer;
    var direction = "";

    if (userAnswer[0]) {
      direction = questionModels[0]._childrenCollection.models[0].attributes.direction;
    } else {
      direction = questionModels[0]._childrenCollection.models[1].attributes.direction;
    }

    if (direction == "go straight") {
      return 'incorrect';
    } else {
      return 'correct';
    }
  }
  function getCorrectness(model) {
    const questionModels = model.getAllDescendantModels().concat([model]).filter(model => model instanceof QuestionModel$1);

    if (questionModels[0].attributes._component == "moral-machine-gmcq") {
      return getMMCorrectness(questionModels);
    } else {
      const numberOfCorrect = questionModels.filter(child => child.isCorrect() && !child.get('_isOptional')).length;
      const numberOfPartlyCorrect = questionModels.filter(child => child.isPartlyCorrect() && !child.get('_isOptional')).length;
      const isCorrect = questionModels.every(child => child.isCorrect() || child.get('_isOptional'));
      const isPartlyCorrect = numberOfCorrect > 0 || numberOfPartlyCorrect > 0;
      return isCorrect ? 'correct' : isPartlyCorrect ? 'partlyCorrect' : 'incorrect';
    }
  }

  var BranchingSet = __AMD("extensions/adapt-contrib-branching/js/BranchingSet", class BranchingSet {
    constructor() {
      let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.model = options.model;
      this.setupModels();
    }

    setupModels() {
      const containerId = this.model.get('_id');
      const children = [...this.model.getChildren(), ...data$1.filter(model => model.get('_branching')?._containerId === containerId)].filter(Boolean);
      children.forEach(child => {
        const config = child.get('_branching');
        if (!config) return;
        config._containerId = config._containerId || containerId;
        const isDirectChild = child.getParent().get('_id') === containerId;
        if (isDirectChild) child.setOnChildren({
          _isAvailable: false
        });
        child.set({
          _isBranchChild: true,
          _isBranchClone: false
        });
        const descendants = [child].concat(child.getAllDescendantModels(true));
        descendants.forEach(descendant => {
          descendant.set('_branchOriginalModelId', descendant.get('_id'));
          if (descendant.isTypeGroup('component')) descendant.set('_shouldStoreAttempts', false);
        });
      });
    }

    initialize() {
      this._wasInitialized = true;
      this.disableParentCompletion();
      const wasRestored = this.restore();

      if (wasRestored) {
        const nextModel = this.getNextModel();
        if (typeof nextModel !== 'object') return;
        this.addNextModel(nextModel, true, false, true);
        return;
      }

      this.addFirstModel();
    }

    disableParentCompletion() {
      this.model.set({
        _canRequestChild: true,
        _requireCompletionOf: Number.POSITIVE_INFINITY
      });
    }

    enableParentCompletion() {
      this.model.set('_requireCompletionOf', -1);
      Adapt$1.checkingCompletion();
      this.model.checkCompletionStatusFor('_isComplete');
      Adapt$1.checkingCompletion();
      this.model.checkCompletionStatusFor('_isInteractionComplete');
    }

    get startId() {
      return this.model.get('_branching')?._start;
    }

    set startId(modelId) {
      const config = this.model.get('_branching');
      if (!config) return;
      config._start = modelId;
    }

    checkResetOnStartChange() {
      const config = this.model.get('_branching');
      if (!config._start) return;

      const isAtCorrectStart = this.isAtStart && this.branchedModels[0]?.get('_branchOriginalModelId') === config._start;

      if (isAtCorrectStart || !this.isAtStart || this.isAtEnd) return;
      this.reset({
        removeViews: true
      });
    }

    restore() {
      const branching = offlineStorage$3.get('b');
      if (!branching) return;
      const id = this.model.get('_id');
      if (!branching[id]) return;
      const trackingPositions = offlineStorage$3.deserialize(branching[id]);
      trackingPositions.forEach((trackingPosition, index) => {
        const isLast = index === trackingPositions.length - 1;
        const model = data$1.findByTrackingPosition(trackingPosition);
        this.addNextModel(model, false, true, isLast);
      });

      if (this.isAtEnd) {
        this.enableParentCompletion();
      }

      return true;
    }

    addFirstModel() {
      const model = this.getNextModel();
      this.addNextModel(model, true, false);
    }

    getNextModel() {
      let {
        isTheoretical = false
      } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      const config = this.model.get('_branching');
      const branchingModels = this.models;
      const branchedModels = this.branchedModels;
      const isBeforeStart = !branchedModels.length;

      if (isBeforeStart) {
        const hasStartId = Boolean(config._start);
        const firstModel = hasStartId ? branchingModels.find(model => model.get('_id') === config._start) : branchingModels[0];
        return firstModel;
      }

      const lastChildModel = branchedModels[branchedModels.length - 1];
      const isLastIncomplete = !lastChildModel.get('_isComplete') && !lastChildModel.get('_isOptional');

      if (isLastIncomplete && !isTheoretical) {
        return false;
      }

      const lastChildConfig = lastChildModel.get('_branching');
      if (!lastChildConfig) return true;
      const correctness = getCorrectness(lastChildModel);
      const nextId = lastChildConfig._force || lastChildConfig[`_${correctness}`];
      if (!nextId) return true;

      function findNextModel(nextId) {
        const isRelativeId = nextId.includes('@');

        if (!isRelativeId) {
          return branchingModels.find(model => model.get('_id') === nextId);
        }

        const originalLastChildModel = data$1.findById(lastChildModel.get('_branchOriginalModelId'));
        const nextModel = originalLastChildModel.findRelativeModel(nextId);
        const wasModelAlreadyUsed = nextModel.get('_isAvailable');
        if (wasModelAlreadyUsed) return true;
        return nextModel;
      }

      const nextModel = findNextModel(nextId);
      if (nextModel === true) return true;

      if (nextModel === undefined) {
        const nextBranchingSet = Adapt$1.branching.getSubsetByModelId(nextId);

        if (!nextBranchingSet) {
          logging$1.error(`Cannot branch to a model that isn't contained in a branching set: ${nextId} from ${lastChildModel.get('_id')}`);
          return true;
        }

        if (!isTheoretical) nextBranchingSet.startId = nextId;
        return true;
      }

      return nextModel;
    }

    addNextModel(nextModel) {
      let shouldSave = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      let shouldRestore = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      let isLast = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
      this.model.set({
        _branchLastPreviousIndex: null
      });
      const attemptIndex = nextModel.get('_branchAttempts') || 0;
      nextModel.set('_branchAttempts', attemptIndex + 1);
      let isAnyPartRestored = false;
      const cloned = nextModel.deepClone((clone, model) => {
        clone.set({
          _id: `${model.get('_id')}_branching_${attemptIndex}`,
          _isAvailable: true,
          _isBranchClone: true
        });

        if (model === nextModel) {
          clone.set('_parentId', this.model.get('_id'));
        }

        if (clone.has('_trackingId')) {
          clone.unset('_trackingId');
        }

        if (clone instanceof ComponentModel$1) {
          clone.set('_attemptStates', false);

          if (shouldRestore) {
            const attemptObjects = model.getAttemptObjects();
            const hasAttemptRecord = attemptObjects.length && attemptObjects[attemptIndex];

            if (hasAttemptRecord) {
              clone.set(attemptObjects[attemptIndex]);
              isAnyPartRestored = true;
              return;
            }

            if (!isLast) {
              clone.setCompletionStatus();
              isAnyPartRestored = true;
            }
          }
        }

        clone.reset('hard', true);
      });

      if (isAnyPartRestored) {
        const areAllDescendantsComplete = cloned.getAllDescendantModels(true).every(model => model.get('_isComplete') || model.get('_isOptional'));

        if (areAllDescendantsComplete) {
          cloned.setCompletionStatus();
        }
      }

      if (shouldSave) {
        this.saveNextModel(nextModel);
      }

      return cloned;
    }

    saveNextModel(nextModel) {
      const branching = offlineStorage$3.get('b') || {};
      const id = this.model.get('_id');
      const trackingIds = branching[id] && offlineStorage$3.deserialize(branching[id]) || [];
      trackingIds.push(nextModel.trackingPosition);
      branching[id] = offlineStorage$3.serialize(trackingIds);
      offlineStorage$3.set('b', branching);
    }

    get models() {
      const containerId = this.model.get('_id');
      return data$1.filter(model => {
        if (model.get('_isBranchClone')) return false;
        const config = model.get('_branching');
        if (!config) return false;
        return config._containerId === containerId;
      });
    }

    get branchedModels() {
      const containerId = this.model.get('_id');
      return data$1.filter(model => {
        if (!model.get('_isBranchClone')) return false;
        const config = model.get('_branching');
        if (!config) return false;
        return config._containerId === containerId;
      });
    }

    get isAtStart() {
      const branchedModels = this.branchedModels;
      const firstChild = branchedModels[0];
      const lastChild = branchedModels[branchedModels.length - 1];
      return firstChild === lastChild;
    }

    get isEffectivelyComplete() {
      const isEffectivelyComplete = this.branchedModels.every(childModel => {
        const requireCompletionOf = childModel.get('_requireCompletionOf');
        const hasStandardCompletionCriteria = requireCompletionOf !== -1;
        if (hasStandardCompletionCriteria) return false;
        const areAllAvailableTrackableChildrenComplete = childModel.getChildren().filter(model => model.get('_isAvailable') && model.get('_isTrackable')).every(model => model.get('_isComplete') || model.get('_isOptional'));
        return areAllAvailableTrackableChildrenComplete;
      });
      return isEffectivelyComplete && this.isAtEnd;
    }

    get isAtEnd() {
      return this.getNextModel({
        isTheoretical: true
      }) === true;
    }

    async reset() {
      let {
        removeViews = false
      } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      if (this._isInReset || !this._wasInitialized) return;
      this._isInReset = true;
      this.disableParentCompletion();
      const parentView = data$1.findViewByModelId(this.model.get('_id'));
      const childViews = parentView?.getChildViews();
      const branchedModels = this.branchedModels;
      branchedModels.forEach(model => {
        if (Adapt$1.parentView && removeViews) {
          const view = data$1.findViewByModelId(model.get('_id'));

          if (view) {
            view.remove();
            childViews.splice(childViews.findIndex(v => v === view), 1);
            parentView.nthChild--;
          }
        }

        data$1.remove(model);
      });
      if (removeViews) parentView?.setChildViews(childViews);
      this.model.getChildren().remove(branchedModels);
      this.model.findDescendantModels('component').forEach(model => model.set('_attemptStates', []));
      const branching = offlineStorage$3.get('b') || {};
      const id = this.model.get('_id');
      const trackingIds = [];
      branching[id] = offlineStorage$3.serialize(trackingIds);
      offlineStorage$3.set('b', branching);
      this.addFirstModel();
      await Adapt$1.parentView?.addChildren();
      Adapt$1.checkingCompletion();
      this.model.checkCompletionStatusFor('_isComplete');
      this._isInReset = false;
      return true;
    }

  });

  class Branching extends Backbone__default["default"].Controller {
    initialize() {
      this._rawSets = [];
      this.openPopupCount = 0;
      this.shouldContinueOnPopupClose = false;
      this.listenTo(Adapt$1, {
        'app:dataReady': this.onAppDataReady,
        'popup:opened': this.onPopupOpened,
        'popup:closed': this.onPopupClosed,
        'assessments:reset': this.onAssessmentReset
      });
      this.listenTo(Adapt$1.articles, 'change:_isComplete', this.onArticleReset);
    }

    async onAppDataReady() {
      const config = Adapt$1.course.get('_branching');
      if (!config || !config._isEnabled) return;
      if (this._isAwaitingDataReady) return;
      this._isAwaitingDataReady = true;
      await data$1.whenReady();
      this.warnForSpoorMisconfiguration();
      this._isAwaitingDataReady = false;
      this.setupBranchingModels();
      this.setupEventListeners();
      Adapt$1.trigger('branching:dataReady');
    }

    warnForSpoorMisconfiguration() {
      const config = Adapt$1.config.get('_spoor');
      const isMisconfigured = config?._isEnabled && config?._tracking?._shouldStoreAttempts === false;
      if (!isMisconfigured) return;
      logging$1.error('Branching: Spoor is misconfigured. Branching requires _spoor._tracking._shouldStoreAttempts = true');
    }

    setupBranchingModels() {
      this._rawSets.length = 0;
      const containerModels = data$1.filter(model => {
        const type = model.get('_type');
        if (type === 'course') return false;
        const config = model.get('_branching');
        if (!config || !config._isEnabled) return false;

        if (type === 'article' && config._onChildren === undefined) {
          config._onChildren = true;
          model.set('_branching', config);
        }

        return config._onChildren === true;
      });
      containerModels.forEach(containerModel => {
        const set = new BranchingSet({
          model: containerModel
        });

        this._rawSets.push(set);
      });

      this._rawSets.forEach(set => set.initialize());
    }

    get subsets() {
      return this._rawSets;
    }

    getSubsetByModelId(modelId) {
      return this._rawSets.find(set => set.model.get('_id') === modelId || set.models.find(model => model.get('_id') === modelId));
    }

    setupEventListeners() {
      this.listenTo(Adapt$1, 'view:requestChild', this.onRequestChild);
      this.listenTo(data$1, 'change:_isComplete', this.onComplete);
    }

    onRequestChild(event) {
      const set = this.getSubsetByModelId(event.target.model.get('_id'));
      if (!set) return;
      set.checkResetOnStartChange();
      const nextModel = set.getNextModel();

      if (nextModel === false) {
        return;
      }

      if (nextModel === true) {
        set.enableParentCompletion();
        return;
      }

      const clonedModel = set.addNextModel(nextModel);
      event.model = clonedModel;
      event.stopNext();
    }

    onPopupOpened() {
      this.openPopupCount++;
    }

    onPopupClosed() {
      this.openPopupCount--;
      if (!this.shouldContinueOnPopupClose || this.openPopupCount > 0) return;
      this.shouldContinueOnPopupClose = false;
      this.continue();
    }

    onArticleReset(model, isComplete) {
      if (isComplete) return;
      const set = this.getSubsetByModelId(model.get('_id'));
      if (!set) return;
      set.reset({
        removeViews: true
      });
    }

    onAssessmentReset(state) {
      const set = this.getSubsetByModelId(state.articleId);
      if (!set) return;
      set.reset({
        removeViews: true
      });
    }

    async continue() {
      if (!Adapt$1.parentView) return;

      if (this.openPopupCount) {
        this.shouldContinueOnPopupClose = true;
        return;
      }

      await Adapt$1.parentView.addChildren();
    }

    onComplete(model, value) {
      if (!value) return;
      this.continueAfterBranchChild(model);
      this.saveBranchQuestionAttemptHistory(model);
    }

    continueAfterBranchChild(model) {
      this.checkIfIsEffectivelyComplete(model);
      if (!model.get('_isBranchChild') || !model.get('_isAvailable')) return;

      _.defer(() => this.continue());
    }

    checkIfIsEffectivelyComplete(model) {
      const childModel = model.getParent();
      if (!childModel) return;
      const isBranchChild = childModel.get('_isBranchChild');
      if (!isBranchChild) return;
      const containerModel = childModel.getParent();
      const set = this.getSubsetByModelId(containerModel.get('_id'));
      if (!set?.isEffectivelyComplete) return;
      set.enableParentCompletion();
    }

    saveBranchQuestionAttemptHistory(model) {
      if (!(model instanceof ComponentModel$1)) return;
      const branchOriginModelId = model.get('_branchOriginalModelId');
      if (!branchOriginModelId) return;
      const originModel = data$1.findById(branchOriginModelId);
      originModel.addAttemptObject(model.getAttemptObject());
      offlineStorage$3.save();
    }

  }

  __AMD("extensions/adapt-contrib-branching/js/adapt-contrib-branching", Adapt$1.branching = new Branching());

  class Completion extends Backbone.Controller {
    initialize() {
      this.subProgressCompleted = 0;
      this.subProgressTotal = 0;
      this.nonAssessmentCompleted = 0;
      this.nonAssessmentTotal = 0;
      this.assessmentCompleted = 0;
      this.assessmentTotal = 0;
    }

    calculateCompletion(contentObjectModel) {
      const completion = Adapt$1.completion;
      const viewType = contentObjectModel.get('_type');
      const isComplete = contentObjectModel.get('_isComplete') ? 1 : 0;
      let children;

      switch (viewType) {
        case 'page':
          {
            children = contentObjectModel.getAllDescendantModels().filter(model => {
              return model.get('_isAvailable') && !model.get('_isOptional');
            });
            const availableChildren = this.filterAvailableChildren(children);
            const components = this.getPageLevelProgressEnabledModels(availableChildren);
            const nonAssessmentComponents = this.getNonAssessmentComponents(components);
            completion.nonAssessmentTotal = nonAssessmentComponents.length;
            completion.nonAssessmentCompleted = this.getComponentsCompleted(nonAssessmentComponents).length;
            const assessmentComponents = this.getAssessmentComponents(components);
            completion.assessmentTotal = assessmentComponents.length;
            completion.assessmentCompleted = this.getComponentsInteractionCompleted(assessmentComponents).length;

            if (contentObjectModel.get('_pageLevelProgress')._excludeAssessments !== true) {
              completion.subProgressCompleted = contentObjectModel.get('_subProgressComplete') || 0;
              completion.subProgressTotal = contentObjectModel.get('_subProgressTotal') || 0;
            }

            const showPageCompletionCourse = Adapt$1.course.get('_pageLevelProgress')?._showPageCompletion !== false;
            const showPageCompletionPage = contentObjectModel.get('_pageLevelProgress')?._showPageCompletion !== false;

            if (showPageCompletionCourse && showPageCompletionPage) {
              completion.nonAssessmentCompleted += isComplete;
              completion.nonAssessmentTotal += 1;
            }

            break;
          }

        case 'menu':
        case 'course':
          {
            children = contentObjectModel.getChildren().models;
            children.forEach(contentObject => {
              const completionObject = Adapt$1.completion.calculateCompletion(contentObject);
              completion.subProgressCompleted += completionObject.subProgressCompleted || 0;
              completion.subProgressTotal += completionObject.subProgressTotal || 0;
              completion.nonAssessmentTotal += completionObject.nonAssessmentTotal;
              completion.nonAssessmentCompleted += completionObject.nonAssessmentCompleted;
              completion.assessmentTotal += completionObject.assessmentTotal;
              completion.assessmentCompleted += completionObject.assessmentCompleted;
            });
            break;
          }
      }

      return completion;
    }

    getNonAssessmentComponents(models) {
      return models.filter(model => {
        return !model.get('_isPartOfAssessment');
      });
    }

    getAssessmentComponents(models) {
      return models.filter(model => {
        return model.get('_isPartOfAssessment');
      });
    }

    getComponentsCompleted(models) {
      return models.filter(item => {
        return item.get('_isComplete');
      });
    }

    getComponentsInteractionCompleted(models) {
      return models.filter(item => {
        return item.get('_isComplete');
      });
    }

    getPageLevelProgressEnabledModels(models) {
      return models.filter(model => {
        const config = model.get('_pageLevelProgress');
        return config?._isEnabled;
      });
    }

    unavailableInHierarchy(parents) {
      if (!parents) return;
      return parents.some(parent => {
        return !parent.get('_isAvailable');
      });
    }

    filterAvailableChildren(children) {
      const availableChildren = [];

      for (let i = 0, count = children.length; i < count; i++) {
        const parents = children[i].getAncestorModels();
        if (this.unavailableInHierarchy(parents)) continue;
        availableChildren.push(children[i]);
      }

      return availableChildren;
    }

    calculatePercentageComplete(model) {
      const completionObject = this.calculateCompletion(model);
      const completed = completionObject.nonAssessmentCompleted + completionObject.assessmentCompleted + completionObject.subProgressCompleted;
      const total = completionObject.nonAssessmentTotal + completionObject.assessmentTotal + completionObject.subProgressTotal;
      const percentageComplete = Math.floor(completed / total * 100);
      return percentageComplete;
    }

  }

  var completionCalculations = __AMD("extensions/adapt-contrib-pageLevelProgress/js/completionCalculations", Adapt$1.completion = new Completion());

  class PageLevelProgressIndicatorView extends Backbone.View {
    tagName() {
      return 'span';
    }

    initialize(options) {
      options = options || {};
      this.parent = options.parent;
      this.calculatePercentage = options.calculatePercentage || this.calculatePercentage;
      this.ariaLabel = options.ariaLabel || '';
      this.type = options.type || this.model.get('_type');
      this.addClasses();
      this.setUpEventListeners();
      this.setPercentageComplete();
      this.render();
      this.refresh();
    }

    addClasses() {
      this.$el.addClass(['pagelevelprogress__indicator', 'is-' + this.type].join(' '));
    }

    checkAria() {
      if (!this.ariaLabel) {
        this.$el.attr('aria-hidden', true);
        return;
      }

      const data = this.getRenderData();
      this.$('.js-indicator-aria-label').html(Handlebars.compile(this.ariaLabel)(data));
    }

    setUpEventListeners() {
      if (this.parent) {
        this.listenToOnce(this.parent, 'postRemove', this.remove);
      } else {
        this.listenTo(Adapt$1, 'remove', this.remove);
      }

      this.listenTo(this.model, 'change:_isComplete', this.refresh);
      if (!this.collection) return;
      this.listenTo(this.collection, 'change:_isComplete', this.refresh);
    }

    setPercentageComplete() {
      const percentage = this.calculatePercentage();
      this.model.set('percentageComplete', percentage);
      return percentage;
    }

    calculatePercentage() {
      return this.model.get('_isComplete') ? 100 : 0;
    }

    render() {
      const data = this.getRenderData();
      const template = Handlebars.templates[this.constructor.template];
      this.$el.html(template(data));
    }

    getRenderData() {
      const data = this.model.toJSON();
      data.ariaLabel = this.ariaLabel;
      data.type = this.type;
      return data;
    }

    refresh() {
      this.checkCompletion();
      this.checkAria();
      this.$('.js-indicator-bar').css({
        width: this.calculatePercentage() + '%'
      });
    }

    checkCompletion() {
      const percentage = this.setPercentageComplete();
      this.$el.toggleClass('is-complete', percentage === 100).toggleClass('is-incomplete', percentage !== 100);
    }

  }

  PageLevelProgressIndicatorView.template = 'pageLevelProgressIndicator';
  var PageLevelProgressIndicatorView$1 = __AMD("extensions/adapt-contrib-pageLevelProgress/js/PageLevelProgressIndicatorView", PageLevelProgressIndicatorView);

  class PageLevelProgressItemView extends Backbone.View {
    className() {
      return ['pagelevelprogress__item drawer__item', this.model.get('_type') + '__indicator'].join(' ');
    }

    attributes() {
      return {
        role: 'listitem'
      };
    }

    initialize() {
      this.listenTo(Adapt$1, 'remove', this.remove);
      this.render();
      this.addIndicator();
    }

    render() {
      const data = this.model.toJSON();
      const template = Handlebars.templates[this.constructor.template];
      this.$el.html(template(data));
    }

    addIndicator() {
      if (this.model.get('_isOptional')) return;
      const item = new PageLevelProgressIndicatorView$1({
        model: this.model
      });
      this.$('.js-indicator').append(item.$el);
    }

  }

  PageLevelProgressItemView.template = 'pageLevelProgressItem';
  var PageLevelProgressItemView$1 = __AMD("extensions/adapt-contrib-pageLevelProgress/js/PageLevelProgressItemView", PageLevelProgressItemView);

  var PageLevelProgressView = __AMD("extensions/adapt-contrib-pageLevelProgress/js/PageLevelProgressView", class PageLevelProgressView extends Backbone.View {
    className() {
      return 'pagelevelprogress';
    }

    events() {
      return {
        'click .js-pagelevelprogress-item-click': 'scrollToPageElement'
      };
    }

    initialize() {
      this.listenTo(Adapt$1, 'remove', this.remove);
      this.render();
      this.addChildren();
    }

    async scrollToPageElement(event) {
      if (event && event.preventDefault) event.preventDefault();
      const $target = $(event.currentTarget);
      if ($target.is('.is-disabled')) return;
      const id = $target.attr('data-pagelevelprogress-id');
      const model = data$1.findById(id);

      if (!model.get('_isRendered')) {
        try {
          await Adapt$1.parentView.renderTo(id);
        } catch (err) {
          return;
        }
      }

      const currentComponentSelector = `.${id}`;
      Adapt$1.once('drawer:closed', () => {
        router$1.navigateToElement(currentComponentSelector, {
          duration: 400
        });
      }).trigger('drawer:closeDrawer', $(currentComponentSelector));
    }

    render() {
      const template = Handlebars.templates.pageLevelProgress;
      this.$el.html(template({}));
    }

    addChildren() {
      const $children = this.$('.js-children');
      this.collection.each(model => {
        $children.append(new PageLevelProgressItemView$1({
          model
        }).$el);
      });
    }

  });

  var PageLevelProgressNavigationView = __AMD("extensions/adapt-contrib-pageLevelProgress/js/PageLevelProgressNavigationView", class PageLevelProgressNavigationView extends Backbone.View {
    tagName() {
      return 'button';
    }

    className() {
      return 'btn-icon nav__btn nav__pagelevelprogress-btn pagelevelprogress__nav-btn';
    }

    attributes() {
      return {
        'data-order': Adapt$1.course.get('_globals')?._extensions?._pageLevelProgress?._navOrder || 0
      };
    }

    events() {
      return {
        click: 'onProgressClicked'
      };
    }

    initialize() {
      _.bindAll(this, 'updateProgressBar');

      this.setUpEventListeners();
      this.render();
      this.addIndicator();
      this.deferredUpdate();
    }

    setUpEventListeners() {
      this.listenTo(Adapt$1, {
        remove: this.remove,
        'router:location': this.updateProgressBar,
        'view:childAdded pageLevelProgress:update': this.refreshProgressBar
      });
    }

    render() {
      const template = Handlebars.templates.pageLevelProgressNavigation;
      this.$el.html(template({}));
    }

    addIndicator() {
      this.indicatorView = new PageLevelProgressIndicatorView$1({
        model: this.model,
        collection: this.collection,
        calculatePercentage: this._getPageCompletionPercentage,
        ariaLabel: Adapt$1.course.get('_globals')._extensions._pageLevelProgress.pageLevelProgressIndicatorBar
      });
      this.$el.prepend(this.indicatorView.$el);
    }

    _getPageCompletionPercentage() {
      return completionCalculations.calculatePercentageComplete(this.model);
    }

    deferredUpdate() {
      _.defer(this.updateProgressBar);
    }

    updateProgressBar() {
      this.indicatorView.refresh();
    }

    refreshProgressBar() {
      this.collection.repopulate();
      this.updateProgressBar();
    }

    onProgressClicked(event) {
      if (event && event.preventDefault) event.preventDefault();
      drawer.triggerCustomView(new PageLevelProgressView({
        collection: this.collection
      }).$el, false);
    }

    remove() {
      super.remove();
      this.collection.reset();
    }

  });

  var PageLevelProgressCollection = __AMD("extensions/adapt-contrib-pageLevelProgress/js/PageLevelProgressCollection", class PageLevelProgressCollection extends Backbone.Collection {
    initialize(models, options) {
      this.listenTo(Adapt$1, 'remove', this.reset);
      if (!options?.pageModel) return;
      this._pageModel = options.pageModel;
      this.repopulate();
    }

    repopulate() {
      this.reset();
      if (!this._pageModel) return;

      const allDescendants = this._pageModel.getAllDescendantModels(true);

      const currentPageItems = allDescendants.filter(item => {
        return item.get('_isAvailable') === true;
      });
      const availableItems = completionCalculations.filterAvailableChildren(currentPageItems);
      const enabledProgressItems = completionCalculations.getPageLevelProgressEnabledModels(availableItems);
      this.add(enabledProgressItems);
    }

  });

  class PageLevelProgress extends Backbone.Controller {
    initialize() {
      this.listenTo(Adapt$1, {
        'app:dataReady': this.onDataReady,
        'app:languageChanged': this.onLanguageChange
      });
    }

    getCourseConfig() {
      return Adapt$1.course.get('_pageLevelProgress');
    }

    onDataReady() {
      const coursePLPConfig = this.getCourseConfig();
      if (!coursePLPConfig?._isEnabled) return;
      this.setUpEventListeners();
    }

    onLanguageChange() {
      this.stopListening();
      this.initialize();
    }

    setUpEventListeners() {
      const headerIndicatorTypes = ['menu', 'menuItem', 'page', 'article', 'block', 'component'];
      const headerIndicatorEventNames = headerIndicatorTypes.concat(['']).join('View:render ');
      this.listenTo(Adapt$1, headerIndicatorEventNames, this.renderHeaderIndicatorView);
      this.listenTo(Adapt$1, {
        'menuItemView:postRender': this.renderMenuItemIndicatorView,
        'router:page': this.renderNavigationView
      });
      this.listenTo(Adapt$1.course, 'bubble:change:_isComplete', this.onCompletionChange);
    }

    onCompletionChange(event) {
      if (!location$2._currentId) return;
      const currentModel = data$1.findById(location$2._currentId);
      const completionState = {
        currentLocation: completionCalculations.calculatePercentageComplete(currentModel),
        course: completionCalculations.calculatePercentageComplete(Adapt$1.course)
      };
      const hasChanged = !_.isMatch(this._previousCompletionState, completionState);
      if (!hasChanged) return;
      this._previousCompletionState = completionState;
      Adapt$1.trigger('pageLevelProgress:percentageCompleteChange', completionState);
    }

    renderHeaderIndicatorView(view) {
      const model = view.model;
      const config = model.get('_pageLevelProgress');
      if (!config?._isEnabled || !config?._isCompletionIndicatorEnabled) return;
      const pageModel = model.findAncestor('contentobject');
      const pageConfig = pageModel && pageModel.get('_pageLevelProgress');
      if (!pageConfig?._isEnabled) return;
      const $headings = view.$('.js-heading');
      $headings.each((index, el) => {
        const $el = $(el);
        const indicatorView = new PageLevelProgressIndicatorView$1({
          parent: view,
          model
        });
        indicatorView.$el.insertAfter($el);
      });
    }

    renderMenuItemIndicatorView(view) {
      if (view.model.get('_id') === location$2._currentId) return;
      const viewType = view.model.get('_type');
      if (viewType === 'course') return;
      const pageLevelProgress = view.model.get('_pageLevelProgress');
      if (!pageLevelProgress?._isEnabled) return;
      view.$el.find('.js-menu-item-progress').append(new PageLevelProgressIndicatorView$1({
        parent: view,
        model: view.model,
        type: 'menu-item',
        calculatePercentage: this._getMenuItemCompletionPercentage.bind(view),
        ariaLabel: Adapt$1.course.get('_globals')._extensions._pageLevelProgress.pageLevelProgressMenuBar
      }).$el);
    }

    _getMenuItemCompletionPercentage() {
      return completionCalculations.calculatePercentageComplete(this.model);
    }

    renderNavigationView(pageModel) {
      const coursePLPConfig = this.getCourseConfig();
      if (coursePLPConfig?._isShownInNavigationBar === false) return;
      const pagePLPConfig = pageModel.get('_pageLevelProgress');
      if (!pagePLPConfig?._isEnabled) return;
      const collection = new PageLevelProgressCollection(null, {
        pageModel
      });
      if (collection.length === 0) return;
      $('.nav__drawer-btn').after(new PageLevelProgressNavigationView({
        model: pageModel,
        collection
      }).$el);
    }

  }

  __AMD("extensions/adapt-contrib-pageLevelProgress/js/adapt-contrib-pageLevelProgress", Adapt$1.pageLevelProgress = new PageLevelProgress());

  function _deepDefaults(original) {
    for (var _len = arguments.length, defaultObjects = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      defaultObjects[_key - 1] = arguments[_key];
    }

    defaultObjects.reverse();
    defaultObjects.forEach(defaults => {
      const keyValuePairs = Object.entries(defaults);
      keyValuePairs.forEach(_ref => {
        let [key, defaultValue] = _ref;
        const isRecursiveObject = typeof defaultValue === 'object' && !Array.isArray(defaultValue) && defaultValue !== null;

        if (isRecursiveObject) {
          original[key] = _deepDefaults(original[key] || {}, defaultValue);
          return;
        }

        const isValueAlreadySet = Object.prototype.hasOwnProperty.call(original, key);
        if (isValueAlreadySet) return;
        original[key] = defaultValue;
      });
    });
    return original;
  }
  const configDefaults = {
    _isEnabled: false,
    _isInherited: false,
    _autoScroll: true,
    _scrollTo: '@block +1',
    _onChildren: false,
    _button: {
      _isEnabled: true,
      _isFullWidth: true,
      _autoHide: false,
      _hasIcon: false,
      _styleBeforeCompletion: 'hidden',
      _styleAfterClick: 'hidden',
      _component: 'trickle-button',
      _className: '',
      text: 'Continue',
      ariaLabel: '',
      startText: '',
      startAriaLabel: '',
      finalText: '',
      finalAriaLabel: ''
    },
    _stepLocking: {
      _isEnabled: true,
      _isCompletionRequired: true,
      _isLockedOnRevisit: false
    }
  };
  function isModelArticleWithOnChildren(model) {
    const type = model.get('_type');
    const trickleConfig = model.get('_trickle');
    return type === 'article' && trickleConfig?._onChildren !== false;
  }
  function isModelBlockWithArticleNotChildren(model) {
    const type = model.get('_type');
    const parentTrickleConfig = model.getParent()?.get('_trickle');
    return type === 'block' && parentTrickleConfig?._isEnabled === true && parentTrickleConfig?._onChildren === false;
  }
  function getModelConfigDefaults(model) {
    const type = model.get('_type');
    const config = {};

    _deepDefaults(config, configDefaults, {
      _onChildren: type === 'article'
    });

    if (config._onChildren) {
      config._button.startText = config._button.startText ?? 'Begin';
      config._button.startAriaLabel = config._button.startAriaLabel ?? '';
      config._button.finalText = config._button.finalText ?? 'Finish';
      config._button.finalAriaLabel = config._button.finalAriaLabel ?? '';
    }

    if (config._button._isFullWidth) {
      config._stepLocking._isEnabled = true;
    }

    return config;
  }
  function getModelInheritanceChain(configModel) {
    if (!data$1.isReady) throw new Error('Trickle cannot resolve inheritance chains until data is ready');
    const type = configModel.get('_type');

    if (type === 'block') {
      const parentModel = configModel.getParent();
      const parentConfig = parentModel.get('_trickle');
      const blockConfig = configModel.get('_trickle');
      const isParentEnabledNotOnChildren = parentConfig?._isEnabled && parentConfig._onChildren === false;
      const isNoChildConfig = !blockConfig?._isEnabled;

      if (isParentEnabledNotOnChildren && isNoChildConfig) {
        return null;
      }

      return [configModel, parentModel].filter(ancestor => {
        const config = ancestor.get('_trickle');
        return config && !config._isInherited;
      });
    }

    if (type === 'article') {
      return [configModel];
    }

    return null;
  }
  function getModelConfig(model) {
    const inheritance = getModelInheritanceChain(model);
    if (!inheritance?.length || isModelArticleWithOnChildren(model) || isModelBlockWithArticleNotChildren(model)) return null;
    const config = $.extend(true, {}, ...inheritance.reverse().map((inheritModel, index, arr) => {
      const isLast = index === arr.length - 1;
      const defaults = isLast ? getModelConfigDefaults(inheritModel) : null;
      return $.extend(true, {}, defaults, inheritModel.get('_trickle'));
    }));
    if (!config._isEnabled) return null;
    return config;
  }
  function getModelContainer(model) {
    const inheritance = getModelInheritanceChain(model);
    return inheritance?.find(inheritModel => {
      const defaults = getModelConfigDefaults(inheritModel);
      const config = $.extend(true, {}, defaults, inheritModel.get('_trickle'));
      return config._onChildren;
    });
  }
  function getCompletionAttribute() {
    let model = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    return getModelConfig(model)?._completionAttribute || Adapt$1.config.get('_trickle')?._completionAttribute || '_isComplete';
  }
  function checkApplyLocks(model) {
    if (!data$1.isReady) return;
    const completionAttribute = getCompletionAttribute(model);
    const hasCompletionChanged = Object.prototype.hasOwnProperty.call(model.changed, completionAttribute);
    const hasAvailabilityChanged = Object.prototype.hasOwnProperty.call(model.changed, '_isAvailable');
    if (!hasCompletionChanged && !hasAvailabilityChanged) return;
    debouncedApplyLocks();
  }
  function applyLocks() {
    if (!data$1.isReady) return;
    const locks = {};
    const modelsById = {};
    const TrickleButtonModel = components$1.getModelClass('trickle-button');
    Adapt$1.course.getAllDescendantModels(true).filter(model => model.get('_isAvailable')).forEach(siteModel => {
      const trickleConfig = getModelConfig(siteModel);
      if (!isEnabled(siteModel, {
        trickleConfig
      })) return;
      const isModelLocked = isLocked(siteModel, {
        trickleConfig
      });
      const id = siteModel.get('_id');
      modelsById[id] = siteModel;
      locks[id] = locks[id] || false;

      const subsequentLockingModels = _getAncestorNextSiblings(siteModel);

      subsequentLockingModels.forEach((model, index) => {
        const id = model.get('_id');
        const isButtonModel = model instanceof TrickleButtonModel;
        model.set('_isTrickled', !isButtonModel);
        modelsById[id] = model;
        locks[id] = locks[id] || isModelLocked;
        if (model.get('_lockType')) return;
        model.getAllDescendantModels().forEach(descendant => {
          const descendantId = descendant.get('_id');
          modelsById[descendantId] = descendant;
          locks[descendantId] = locks[id];
        });
      });
    });
    Object.entries(locks).forEach(_ref2 => {
      let [id, isModelLocked] = _ref2;
      const model = modelsById[id];
      const wasLocked = model.get('_isLocked');
      if (wasLocked === isModelLocked) return;
      model.set('_isLocked', isModelLocked);
    });
    logTrickleState();
  }
  function isEnabled(model) {
    let {
      trickleConfig = getModelConfig(model)
    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return trickleConfig?._isEnabled === true;
  }
  function isLocked(model) {
    let {
      trickleConfig = getModelConfig(model)
    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const isStepLocked = Boolean(trickleConfig?._stepLocking?._isEnabled);
    if (!isStepLocked) return false;
    const isCompletionRequired = Boolean(trickleConfig?._stepLocking?._isCompletionRequired);
    const completionAttribute = getCompletionAttribute(model);

    if (!isCompletionRequired) {
      const TrickleModel = components$1.getModelClass('trickle-button');
      const trickleButton = model.getAvailableChildModels().find(model => model instanceof TrickleModel);
      const isTrickleButtonComplete = Boolean(trickleButton?.get(completionAttribute));
      return !isTrickleButtonComplete;
    }

    const isModelLocked = !model?.get(completionAttribute) && !model?.get('_isOptional');
    return isModelLocked;
  }
  const debouncedApplyLocks = _.debounce(applyLocks, 1);
  function _getAncestorNextSiblings(fromModel) {
    if (!fromModel) return [];
    const allSiblings = fromModel.getParent().getAvailableChildModels();
    const subsequentSiblings = allSiblings.slice(allSiblings.findIndex(sibling => sibling === fromModel) + 1);
    const allAncestors = fromModel.getAncestorModels();
    const inPageAncestors = allAncestors.slice(0, allAncestors.findIndex(parent => parent instanceof ContentObjectModel) + 1);
    const subsequentInPageAncestors = [];
    inPageAncestors.slice(1).forEach((grandParent, previousIndex) => {
      const parent = inPageAncestors[previousIndex];
      const allGrandParentChildren = grandParent.getAvailableChildModels();
      const subsequentAncestorSiblings = allGrandParentChildren.slice(allGrandParentChildren.findIndex(child => child === parent) + 1);
      subsequentInPageAncestors.push(...subsequentAncestorSiblings);
    });
    const subsequentContentObjectDescendantModels = subsequentSiblings.concat(subsequentInPageAncestors);
    return subsequentContentObjectDescendantModels;
  }
  function addButtonComponents() {
    const TrickleButtonModel = components$1.getModelClass('trickle-button');
    let uid = 0;
    data$1.forEach(buttonModelSite => {
      if (buttonModelSite instanceof CourseModel$1) return;
      const trickleConfig = getModelConfig(buttonModelSite);
      if (!trickleConfig || !trickleConfig?._isEnabled || buttonModelSite.get('_isTrickleSiteConfigured')) return;
      buttonModelSite.set('_isTrickleSiteConfigured', true);
      const parentId = buttonModelSite.get('_id');
      const trickleButtonModel = new TrickleButtonModel({
        _id: `trickle-${uid++}`,
        _type: 'component',
        _component: 'trickle-button',
        _parentId: parentId,
        _isAvailable: true,
        _layout: 'full',
        _trickle: {
          _isEnabled: true
        },
        _renderPosition: 'outer-append',
        _isTrackable: false
      });
      trickleButtonModel.setupModel();
      buttonModelSite.getChildren().add(trickleButtonModel);
    });
  }
  function logTrickleState() {
    if (logging$1._config?._level !== 'debug') return;

    if (!Adapt$1.parentView?.model?.isTypeGroup('page')) {
      logging$1.debug('TRICKLE GLOBAL STATE');
      Adapt$1.course.getAllDescendantModels(true).filter(model => model.get('_isAvailable')).forEach(model => {
        const isLocked = model.get('_isLocked');
        const isTrickled = model.get('_isTrickled');
        logging$1.debug(`${' '.repeat(model.getAncestorModels().length)}${model.get('_type')} ${model.get('_id')} isLocked: ${isLocked} isTrickled: ${isTrickled}`);
      });
      return;
    }

    logging$1.debug('TRICKLE STATE');
    Adapt$1.parentView.model.getAllDescendantModels(true).filter(model => model.get('_isAvailable')).forEach(model => {
      const isLocked = model.get('_isLocked');
      const isTrickled = model.get('_isTrickled');
      logging$1.debug(`${' '.repeat(model.getAncestorModels().length)}${model.get('_type')} ${model.get('_id')} isLocked: ${isLocked} isTrickled: ${isTrickled}`);
    });
  }
  __AMD("extensions/adapt-contrib-trickle/js/models", {
    _deepDefaults,
    configDefaults,
    getModelConfigDefaults,
    getModelInheritanceChain,
    getModelConfig,
    getModelContainer,
    getCompletionAttribute,
    checkApplyLocks,
    applyLocks,
    debouncedApplyLocks,
    _getAncestorNextSiblings,
    addButtonComponents,
    logTrickleState
  });

  class TrickleController extends Backbone.Controller {
    initialize() {
      this.checkIsFinished = _.debounce(this.checkIsFinished, 1);
      this.listenTo(data$1, {
        ready: this.onDataReady
      });
    }

    async onDataReady() {
      const trickleConfig = Adapt$1.config.get('_trickle');
      if (trickleConfig?._isEnabled === false) return;
      this.setUpEventListeners();
      wait$1.for(done => {
        addButtonComponents();
        applyLocks();
        done();
      });
    }

    setUpEventListeners() {
      this.listenTo(data$1, {
        'change:_isInteractionComplete change:_isComplete change:_isAvailable add remove': checkApplyLocks,
        'change:_isLocked': this.checkIsFinished
      });
      this.listenTo(Adapt$1, {
        'assessments:reset': this.onAssessmentReset,
        'contentObjectView:preRender': this.reset,
        'view:addChild': this.onAddChildView,
        'trickle:kill': this.kill
      });
    }

    onAssessmentReset() {
      const isMidRender = !Adapt$1.parentView?.model.get('_isReady');
      if (isMidRender) return applyLocks();
      debouncedApplyLocks();
    }

    get isStarted() {
      return Boolean(Adapt$1.parentView?.model.get('_isTrickleStarted'));
    }

    set isStarted(value) {
      if (!Adapt$1.parentView) return;
      Adapt$1.parentView.model.set('_isTrickleStarted', value);
      if (!value) return;
      Adapt$1.trigger('trickle:started');
    }

    onAddChildView(event) {
      if (this.isKilled) return;
      if (event.hasRequestChild) applyLocks();
      const isManagedByTrickleAndLocked = event.model.get('_isTrickled') && event.model.get('_isLocked');
      if (!isManagedByTrickleAndLocked) return;
      event.stop();
    }

    get isTrickling() {
      const isTrickling = Adapt$1.parentView.model.getAllDescendantModels().some(model => {
        return model.get('_isAvailable') && model.get('_isTrickled') && model.get('_isLocked');
      });
      return isTrickling;
    }

    async continue() {
      applyLocks();
      await Adapt$1.parentView.addChildren();
      await Adapt$1.parentView.whenReady();
    }

    async scroll(fromModel) {
      const trickleConfig = getModelConfig(fromModel);
      if (!trickleConfig?._isEnabled) return false;
      if (isModelArticleWithOnChildren(fromModel)) return false;
      const isAutoScrollOff = !trickleConfig._autoScroll;
      const hasTrickleButton = trickleConfig._button._isEnabled;

      if (isAutoScrollOff && !hasTrickleButton) {
        return;
      }

      const getScrollToId = () => {
        const scrollTo = trickleConfig._scrollTo;
        const firstCharacter = scrollTo.substr(0, 1);

        switch (firstCharacter) {
          case '@':
            {
              const relativeModel = fromModel.findRelativeModel(scrollTo, {
                filter: model => model.get('_isAvailable')
              });
              if (relativeModel === undefined) return;
              return relativeModel.get('_id');
            }

          case '.':
            return scrollTo.substr(1, scrollTo.length - 1);

          default:
            return scrollTo;
        }
      };

      let scrollToId = getScrollToId();
      if (scrollToId === '') return;
      const isDescendant = Adapt$1.parentView.model.getAllDescendantModels().some(model => {
        return model.get('_id') === scrollToId;
      });

      if (!isDescendant) {
        applyLocks();
        const model = data$1.findById(scrollToId);
        const contentObject = model.isTypeGroup('contentobject') ? model : model.findAncestor('contentobject');
        await router$1.navigateToElement(contentObject.get('_id'));
        scrollToId = getScrollToId();
        await router$1.navigateToElement(scrollToId);
        return;
      }

      await Adapt$1.parentView.renderTo(scrollToId);

      if (hasTrickleButton) {
        a11y$1.focusFirst($('.' + scrollToId), {
          preventScroll: true
        });
      }

      if (isAutoScrollOff) return false;
      const duration = trickleConfig._scrollDuration || 500;
      router$1.navigateToElement('.' + scrollToId, {
        duration
      });
    }

    get isFinished() {
      if (!Adapt$1.parentView) return false;
      return Boolean(!this.isStarted || Adapt$1.parentView.model.get('_isTrickleFinished') || this.isKilled);
    }

    set isFinished(value) {
      if (!Adapt$1.parentView) return;
      Adapt$1.parentView.model.set('_isTrickleFinished', value);
      if (!value) return;
      Adapt$1.trigger('trickle:finished');
    }

    checkIsFinished() {
      if (!this.isStarted) return;
      if (this.isKilled || this.isFinished) return;
      if (this.isTrickling) return;
      this.isFinished = true;
    }

    async kill() {
      const TrickleModel = components$1.getModelClass('trickle-button');
      this.isKilled = true;
      Adapt$1.parentView.model.getAllDescendantModels().forEach(model => {
        const isButtonModel = model instanceof TrickleModel;

        if (isButtonModel) {
          model.setCompletionStatus();
        }

        if (!model.get('_isTrickled')) return;
        model.set('_isLocked', false);
      });
      await this.continue();
    }

    get isKilled() {
      if (!Adapt$1.parentView) return false;
      return !this.isStarted || Adapt$1.parentView.model.get('_isTrickleKilled');
    }

    set isKilled(value) {
      if (!Adapt$1.parentView) return;
      Adapt$1.parentView.model.set('_isTrickleKilled', value);
      if (!value) return;
      Adapt$1.trigger('trickle:killed');
    }

    reset() {
      this.isKilled = false;

      if (!this.isTrickling) {
        this.isStarted = false;
        this.isFinished = false;
        return;
      }

      this.isStarted = true;
      this.isFinished = false;
    }

  }

  var controller = __AMD("extensions/adapt-contrib-trickle/js/controller", new TrickleController());

  class TrickleButtonView extends ComponentView$1 {
    className() {
      const config = getModelConfig(this.model.getParent());
      return ['trickle', this.model.get('_id'), config._button._component, config._button._isFullWidth && 'is-full-width', config._button._className].filter(Boolean).join(' ');
    }

    events() {
      return {
        'click .js-trickle-btn': 'onButtonClick'
      };
    }

    initialize() {
      this.openPopupCount = 0;
      this.isAwaitingPopupClose = false;
      this.wasButtonClicked = false;
      this.model.calculateButtonText();
      this.calculateButtonState();
      this.setupEventListeners();
      this.render();

      if (!this.model.isEnabled()) {
        this.setCompletionStatus();
      }

      _.defer(this.setReadyStatus.bind(this));
    }

    calculateButtonState() {
      const isDisabledByPopups = this.openPopupCount > 0;
      this.model.calculateButtonState(isDisabledByPopups, this.wasButtonClicked);
    }

    render() {
      const data = this.model.toJSON();
      data._globals = Adapt$1.course.get('_globals');
      data._trickle = getModelConfig(this.model.getParent());
      this.$el.html(Handlebars.templates[TrickleButtonView.template](data));
    }

    setupEventListeners() {
      this.tryButtonAutoHide = this.tryButtonAutoHide.bind(this);
      const onParentComplete = this.onParentComplete.bind(this);

      this.onParentComplete = function () {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return _.delay(() => onParentComplete(...args), 100);
      };

      this.listenTo(Adapt$1.parentView, 'postRemove', this.onRemove);
      this.listenTo(Adapt$1, 'trickle:killed', this.updateButtonState);

      if (this.model.isStepUnlocked() && this.model.isFinished()) {
        return;
      }

      this.$el.on('onscreen', this.tryButtonAutoHide);
      this.listenTo(Adapt$1, {
        'popup:opened': this.onPopupOpened,
        'popup:closed': this.onPopupClosed
      });
      const parentModel = this.model.getParent();
      const completionAttribute = getCompletionAttribute(parentModel);
      this.listenTo(parentModel, {
        'change:_requireCompletionOf': this.onStepUnlocked,
        [`bubble:change:${completionAttribute}`]: this.onStepUnlocked,
        [`change:${completionAttribute}`]: this.onParentComplete
      });
    }

    onPopupOpened() {
      this.openPopupCount++;
      const shouldUserInteractWithButton = this.model.isStepUnlocked() && !this.model.isFinished();
      if (!shouldUserInteractWithButton) return;
      this.updateButtonState();
    }

    async onPopupClosed() {
      this.openPopupCount--;
      if (this.openPopupCount) return;

      if (this.isAwaitingPopupClose) {
        return this.finish();
      }

      const shouldUserInteractWithButton = this.model.isStepUnlocked() && !this.model.isFinished();
      if (!shouldUserInteractWithButton) return;
      this.updateButtonState();
      await Adapt$1.parentView.addChildren();
    }

    updateButtonState() {
      this.calculateButtonState();
      const isButtonHidden = !(this.model.get('_isButtonVisible') && !this.model.get('_isButtonAutoHidden'));
      this.$('.js-trickle-btn-container').toggleClass('u-display-none', isButtonHidden);
      const isButtonDisabled = this.model.get('_isButtonDisabled');
      const $button = this.$('.js-trickle-btn');
      const $ariaLabel = this.$('.aria-label');
      a11y$1.toggleEnabled($button, !isButtonDisabled);

      if (!isButtonDisabled) {
        if (document.activeElement instanceof HTMLElement && document.activeElement.isSameNode($ariaLabel[0])) {
          a11y$1.focusNext($ariaLabel);
        }

        a11y$1.toggleAccessibleEnabled($ariaLabel, false);
      }

      const $buttonText = this.$('.js-trickle-btn-text');
      const text = this.model.get('buttonText');
      const ariaLabel = this.model.get('buttonAriaLabel');
      $buttonText.html(text);
      $button.attr('aria-label', ariaLabel);
    }

    async onStepUnlocked(event) {
      if (event.value === false) return;

      _.defer(this.updateButtonState.bind(this));
    }

    async onButtonClick() {
      const wasComplete = this.model.get('_isComplete');
      this.model.setCompletionStatus();
      this.wasButtonClicked = true;
      const isStepLockingCompletionRequired = this.model.isStepLockingCompletionRequired();
      if (isStepLockingCompletionRequired && !wasComplete) return;
      await this.continue();
    }

    async onParentComplete(model, value) {
      if (!value) return;
      const parentModel = this.model.getParent();
      const completionAttribute = getCompletionAttribute(parentModel);
      this.stopListening(parentModel, {
        [`bubble:change:${completionAttribute}`]: this.onStepUnlocked,
        [`change:${completionAttribute}`]: this.onParentComplete
      });
      if (controller.isKilled) return;

      if (this.openPopupCount > 0) {
        this.isAwaitingPopupClose = true;
        return;
      }

      await this.finish();
    }

    async finish() {
      this.stopListening(Adapt$1, {
        'popup:opened': this.onPopupOpened,
        'popup:closed': this.onPopupClosed
      });
      this.updateButtonState();
      const isStepLockingCompletionRequired = this.model.isStepLockingCompletionRequired();
      if (!isStepLockingCompletionRequired) return;
      await this.continue();
    }

    async continue() {
      const parent = this.model.getParent();
      await controller.continue();
      await controller.scroll(parent);
    }

    tryButtonAutoHide() {
      if (!this.model.get('_isButtonVisible')) return;
      const trickleConfig = getModelConfig(this.model.getParent());

      if (!trickleConfig._button._autoHide) {
        this.model.set('_isButtonAutoHidden', false);
        return;
      }

      const measurements = this.$el.onscreen();
      const isJustOffscreen = measurements.bottom > -100;
      const isButtonAutoHidden = !measurements.onscreen && !isJustOffscreen;
      this.model.set('_isButtonAutoHidden', isButtonAutoHidden);
      this.updateButtonState();
    }

    onRemove() {
      this.$el.off('onscreen', this.tryButtonAutoHide);
      this.remove();
    }

  }

  TrickleButtonView.template = 'trickle-button';
  var TrickleButtonView$1 = __AMD("extensions/adapt-contrib-trickle/js/TrickleButtonView", TrickleButtonView);

  var TrickleButtonModel = __AMD("extensions/adapt-contrib-trickle/js/TrickleButtonModel", class TrickleButtonModel extends ComponentModel$1 {
    init() {
      super.init();
      if (!this.isStepComplete()) return;
      this.setCompletionStatus();
    }

    isEnabled() {
      const trickleConfig = getModelConfig(this.getParent());
      const isEnabled = trickleConfig._isEnabled && trickleConfig._button?._isEnabled;
      return isEnabled;
    }

    isStepLocking() {
      const config = getModelConfig(this.getParent());
      const isStepLocking = config._stepLocking?._isEnabled;
      return isStepLocking;
    }

    isStepLockingCompletionRequired() {
      const config = getModelConfig(this.getParent());
      const isStepLockingCompletionRequired = config._stepLocking && config._stepLocking._isEnabled && config._stepLocking._isCompletionRequired;
      return isStepLockingCompletionRequired;
    }

    isStepUnlocked() {
      const parentModel = this.getParent();
      const completionAttribute = getCompletionAttribute(parentModel);
      const isCompletionBlocked = parentModel.get('_requireCompletionOf') === Number.POSITIVE_INFINITY;
      if (isCompletionBlocked) return;
      return this.getSiblings().every(sibling => {
        if (sibling === this) {
          return true;
        }

        return sibling.get(completionAttribute) || sibling.get('_isOptional') || !sibling.get('_isAvailable');
      });
    }

    isStepComplete() {
      const parentModel = this.getParent();
      const completionAttribute = getCompletionAttribute(parentModel);
      const isParentComplete = parentModel.get(completionAttribute);
      return isParentComplete;
    }

    isStepLockedOnRevisit() {
      const trickleConfig = getModelConfig(this.getParent());
      return Boolean(trickleConfig._stepLocking._isLockedOnRevisit);
    }

    isFinished() {
      const isStepUnlocked = this.isStepUnlocked();
      const isStepLockingCompletionRequired = this.isStepLockingCompletionRequired();
      const isButtonComplete = this.get('_isComplete');
      const isFinished = (isStepUnlocked || !isStepLockingCompletionRequired) && isButtonComplete;
      return isFinished;
    }

    isLastInContentObject() {
      const contentObject = this.findAncestor('contentobject');
      const allDescendants = contentObject.getAllDescendantModels(true);
      const lastDescendant = allDescendants[allDescendants.length - 1];
      return this === lastDescendant;
    }

    calculateButtonText() {
      const parentModel = this.getParent();
      const trickleConfig = getModelConfig(parentModel);
      let isStart = false;
      let isFinal = false;

      if (trickleConfig._onChildren) {
        const parentId = parentModel.get('_id');
        const trickleParent = getModelContainer(parentModel);
        const trickleSiblings = trickleParent.getAllDescendantModels(true).filter(model => {
          return model.get('_isAvailable') && model.get('_isTrickled');
        });
        const index = trickleSiblings.findIndex(model => model.get('_id') === parentId);
        isStart = index === 0;
        isFinal = index === trickleSiblings.length - 1 && !trickleParent.get('_canRequestChild');
      }

      const text = isStart && trickleConfig._button.startText ? trickleConfig._button.startText : isFinal && trickleConfig._button.finalText ? trickleConfig._button.finalText : trickleConfig._button.text;
      const ariaLabel = isStart && trickleConfig._button.startAriaLabel ? trickleConfig._button.startAriaLabel : isFinal && trickleConfig._button.finalAriaLabel ? trickleConfig._button.finalAriaLabel : trickleConfig._button.ariaLabel;
      this.set({
        buttonText: text,
        buttonAriaLabel: ariaLabel
      });
    }

    checkIfResetOnRevisit() {
      if (this.isFinished() && !this.isStepLockedOnRevisit()) return;
      this.set({
        _isComplete: false,
        _isInteractionComplete: false
      });
      applyLocks();
    }

    calculateButtonState() {
      let isButtonDisableForced = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      let isButtonHiddenForced = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (!this.isEnabled()) {
        this.set({
          _isButtonVisible: false,
          _isButtonDisabled: !this.isStepUnlocked()
        });
        return;
      }
      const trickleConfig = getModelConfig(this.getParent());

      if (this.isLastInContentObject() && trickleConfig._button._showEndOfPage === false) {
        return this.set({
          _isButtonVisible: false,
          _isButtonDisabled: true
        });
      }

      const isTrickleKilled = controller.isKilled;
      const isStepUnlocked = this.isStepUnlocked() || isTrickleKilled;
      const isFinished = this.isFinished() || isTrickleKilled;
      const isButtonVisibleBeforeCompletion = trickleConfig._button._styleBeforeCompletion !== 'hidden';
      const isButtonVisibleAfterCompletion = trickleConfig._button._styleAfterClick !== 'hidden' && !trickleConfig._button._isFullWidth;
      const isStepLockingCompletionRequired = this.isStepLockingCompletionRequired();
      const isNoCompletionRequiredAndLockedVisible = !isStepLockingCompletionRequired && !isFinished && isButtonVisibleBeforeCompletion;
      const isNoCompletionRequiredAndUnlockedVisible = !isStepLockingCompletionRequired && isStepUnlocked && !isFinished;
      const isNoCompletionRequiredAndFinishedVisible = !isStepLockingCompletionRequired && isFinished && isButtonVisibleAfterCompletion;
      const isStepLockedAndVisibleBeforeCompletion = isStepLockingCompletionRequired && !isStepUnlocked && isButtonVisibleBeforeCompletion && !isButtonHiddenForced;
      const isFinishedAndVisibleAfterCompletion = isStepLockingCompletionRequired && isFinished && isButtonVisibleAfterCompletion;
      const isStepUnlockedAndButtonIncomplete = isStepLockingCompletionRequired && isStepUnlocked && !isFinished;
      const isButtonVisible = isNoCompletionRequiredAndLockedVisible || isNoCompletionRequiredAndUnlockedVisible || isNoCompletionRequiredAndFinishedVisible || isStepLockedAndVisibleBeforeCompletion || isFinishedAndVisibleAfterCompletion || isStepUnlockedAndButtonIncomplete;
      const isButtonEnabledBeforeCompletion = trickleConfig._button._styleBeforeCompletion !== 'disabled';
      const isButtonEnabledAfterCompletion = trickleConfig._button._styleAfterClick !== 'disabled';
      const isNoCompletionRequiredAndLockedEnabled = !isStepLockingCompletionRequired && !isFinished && isButtonEnabledBeforeCompletion;
      const isNoCompletionRequiredAndUnlockedEnabled = !isStepLockingCompletionRequired && isStepUnlocked && !isFinished;
      const isNoCompletionRequiredAndFinishedEnabled = !isStepLockingCompletionRequired && isFinished && isButtonEnabledAfterCompletion;
      const isStepUnlockedAndButtonIncompleteWithoutButtonDisabledForced = isStepLockingCompletionRequired && isStepUnlockedAndButtonIncomplete && !isButtonDisableForced;
      const isFinishedAndEnabledAfterCompletion = isStepLockingCompletionRequired && isFinished && isButtonEnabledAfterCompletion;
      const isButtonEnabled = isNoCompletionRequiredAndLockedEnabled || isNoCompletionRequiredAndUnlockedEnabled || isNoCompletionRequiredAndFinishedEnabled || isStepUnlockedAndButtonIncompleteWithoutButtonDisabledForced || isFinishedAndEnabledAfterCompletion || false;
      this.set({
        _isButtonVisible: isButtonVisible,
        _isButtonDisabled: !isButtonEnabled
      });
    }

  });

  __AMD("extensions/adapt-contrib-trickle/js/trickleButton", components$1.register('trickle-button', {
    view: TrickleButtonView$1,
    model: TrickleButtonModel
  }));

  __AMD("extensions/adapt-contrib-trickle/js/adapt-contrib-trickle", Adapt$1.trickle = controller);

  const TUTOR_TYPE = ENUM(['NOTIFY', 'INLINE', 'OVERLAY', 'NONE']);
  var TUTOR_TYPE$1 = __AMD("extensions/adapt-contrib-tutor/js/TUTOR_TYPE", TUTOR_TYPE);

  var TutorModel = __AMD("extensions/adapt-contrib-tutor/js/TutorModel", class TutorModel extends Backbone.Model {
    defaults() {
      return {
        _type: TUTOR_TYPE$1.NOTIFY.asLowerCase,
        _classes: '',
        _hasNotifyBottomButton: false,
        _button: {
          text: '{{_globals._extensions._tutor.hideFeedback}}',
          ariaLabel: '{{_globals._extensions._tutor.hideFeedback}}'
        },
        ...Adapt$1.course.get('_tutor')
      };
    }

    initialize(data, parentModel) {
      data = $.extend(true, this.defaults(), data?._isInherited === true ? null : data, {
        _attributes: {
          'data-adapt-id': parentModel.get('_id')
        },
        _id: parentModel.get('_id'),
        _shouldRenderId: false,
        altTitle: parentModel.get('altFeedbackTitle'),
        title: parentModel.get('feedbackTitle'),
        body: parentModel.get('feedbackMessage')
      });
      data._classes += ` tutor ${this.getOriginClasses(parentModel)}`;
      this.set(data);
    }

    getOriginClasses(model) {
      const component = model.get('_component');
      const extension = model.get('_extension');
      return [model.get('_isCorrect') ? 'is-correct' : model.get('_isAtLeastOneCorrectSelection') ? 'is-partially-correct' : 'is-incorrect', component && `is-component is-${component}`, extension && `is-extension is-${extension}`].filter(Boolean).join(' ');
    }

  });

  var TutorNotify = __AMD("extensions/adapt-contrib-tutor/js/TutorNotify", class TutorNotify extends Backbone.Controller {
    initialize(options) {
      this.parentView = options.parentView;
      this.listenToOnce(Adapt$1, 'notify:closed', this.onNotifyClosed);
      this.triggerNotify();
    }

    triggerNotify() {
      const {
        _hasNotifyBottomButton: isButtonEnabled,
        _button: {
          text: promptText
        }
      } = this.model.toJSON();
      this.notifyOptions = { ...this.model.toJSON(),
        _prompts: isButtonEnabled && [{
          promptText: Handlebars.compile(promptText)({
            _globals: Adapt$1.course.get('_globals')
          })
        }],
        _type: isButtonEnabled ? 'prompt' : 'popup'
      };
      notify$1.create(this.notifyOptions);
      Adapt$1.trigger('tutor:opened', this.parentView, this.notifyOptions);
    }

    onNotifyClosed() {
      Adapt$1.trigger('tutor:closed', this.parentView, this.notifyOptions);
    }

  });

  var TutorView = __AMD("extensions/adapt-contrib-tutor/js/TutorView", class TutorView extends Backbone.View {
    className() {
      return ['tutor', `tutor-type-${this.model.get('_type')}`, this.model.get('_classes')].join(' ');
    }

    events() {
      return {
        'click .js-tutor-btn': 'onCloseClick'
      };
    }

    initialize(options) {
      this.parentView = options.parentView;
      this.buttonsView = this.parentView.buttonsView;
      this.listenTo(this.parentView, 'postRemove', this.onTutorClosed);
      this.listenTo(this.buttonsView, 'buttons:stateUpdate', this.onButtonsStateUpdate);
      this.render();
    }

    render() {
      this.$el.html(Handlebars.templates.tutor(this.model.toJSON()));

      _.defer(this.postRender.bind(this));
    }

    postRender() {
      this.toggleFeedback({
        shouldOpen: true
      });
    }

    toggleFeedback() {
      let {
        shouldOpen,
        shouldManageFocus = true
      } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      const animation = this.model.get('_type') === 'inline' ? 'slide' : 'fade';
      const onAnimationEnd = shouldOpen ? this.onTutorOpened.bind(this, shouldManageFocus) : this.onTutorClosed.bind(this, shouldManageFocus);

      if (shouldManageFocus) {
        a11y$1.toggleEnabled(this.buttonsView.$('.js-btn-feedback'), !shouldOpen);
      }

      this.$('.tutor__inner').stop()[`${animation}Toggle`](200, onAnimationEnd);
    }

    onCloseClick() {
      this.toggleFeedback({
        shouldOpen: false
      });
    }

    onTutorOpened(shouldManageFocus) {
      if (shouldManageFocus) {
        a11y$1.focus(this.$('.tutor__inner'), {
          defer: true,
          preventScroll: true
        });
      }

      Adapt$1.trigger('tutor:opened', this.parentView, this.model.toJSON());
    }

    onTutorClosed(shouldManageFocus) {
      if (shouldManageFocus) {
        const $showFeedbackButton = this.buttonsView.$('.js-btn-feedback');
        a11y$1.focus($showFeedbackButton, {
          defer: true,
          preventScroll: true
        });
      }

      Adapt$1.trigger('tutor:closed', this.parentView, this.model.toJSON());
      this.remove();
    }

    onButtonsStateUpdate(state) {
      if (state !== BUTTON_STATE$1.RESET) return;
      this.toggleFeedback({
        shouldOpen: false,
        shouldManageFocus: false
      });
    }

  });

  class Tutor extends Backbone.Controller {
    initialize() {
      this.listenTo(Adapt$1, 'questionView:showFeedback', this.onQuestionViewShowFeedback);
    }

    onQuestionViewShowFeedback(view) {
      const parentModel = view.model;
      const tutorModel = new TutorModel(parentModel.get('_tutor'), parentModel);
      const options = {
        model: tutorModel,
        parentView: view
      };

      switch (TUTOR_TYPE$1(tutorModel.get('_type').toUpperCase())) {
        case TUTOR_TYPE$1.NOTIFY:
          new TutorNotify(options);
          break;

        case TUTOR_TYPE$1.INLINE:
        case TUTOR_TYPE$1.OVERLAY:
          view.$('.component__inner').append(new TutorView(options).$el);
          break;

        case TUTOR_TYPE$1.NONE:
      }
    }

  }

  __AMD("extensions/adapt-contrib-tutor/js/adapt-contrib-tutor", Adapt$1.tutor = new Tutor());

  var xAPI = Backbone.Model.extend({
    defaults: {
      lang: 'en-US',
      displayLang: 'en-US',
      generateIds: false,
      activityId: null,
      actor: null,
      shouldTrackState: true,
      shouldUseRegistration: false,
      componentBlacklist: 'blank,graphic',
      isInitialised: false,
      state: {}
    },
    startAttemptDuration: 0,
    startTimeStamp: null,
    courseName: '',
    courseDescription: '',
    defaultLang: 'en-US',
    isComplete: false,
    debug: false,
    coreEvents: {
      Adapt: {
        'router:page': false,
        'router:menu': false,
        'assessments:complete': true,
        'questionView:recordInteraction': true
      },
      contentObjects: {
        'change:_isComplete': false
      },
      articles: {
        'change:_isComplete': false
      },
      blocks: {
        'change:_isComplete': false
      },
      components: {
        'change:_isComplete': true
      }
    },
    coreObjects: {
      course: 'course',
      contentObjects: ['menu', 'page'],
      articles: 'article',
      blocks: 'block',
      components: 'component',
      offlineStorage: 'offlineStorage'
    },
    initialize: function () {
      if (!Adapt$1.config) {
        return;
      }

      this.config = Adapt$1.config.get('_xapi');

      if (!this.getConfig('_isEnabled')) {
        return this;
      }

      Adapt$1.wait.begin();
      this.initializeWrapper(_.bind(function (error) {
        if (error) {
          this.onInitialised(error);
          return this;
        }

        this.set({
          activityId: this.getLRSAttribute('activity_id') || this.getConfig('_activityID') || this.getBaseUrl(),
          displayLang: Adapt$1.config.get('_defaultLanguage'),
          lang: this.getConfig('_lang'),
          generateIds: this.getConfig('_generateIds'),
          shouldTrackState: this.getConfig('_shouldTrackState'),
          shouldUseRegistration: this.getConfig('_shouldUseRegistration') || false,
          componentBlacklist: this.getConfig('_componentBlacklist') || [],
          cookieDomain: this.getConfig('_cookiePrefix')
        });
        var componentBlacklist = this.get('componentBlacklist');

        if (!_.isArray(componentBlacklist)) {
          componentBlacklist = componentBlacklist.split(/,\s?/).map(function (component) {
            return component.toLowerCase();
          });
        }

        this.set('componentBlacklist', componentBlacklist);

        if (!this.validateProps()) {
          var error = new Error('Missing required properties');
          Adapt$1.log.error('adapt-contrib-xapi: xAPI Wrapper initialisation failed', error);
          this.onInitialised(error);
          return this;
        }

        this.startTimeStamp = new Date();
        this.courseName = Adapt$1.course.get('displayTitle') || Adapt$1.course.get('title');
        this.courseDescription = Adapt$1.course.get('description') || '';
        var statements = [this.getCourseStatement(ADL.verbs.launched), this.getCourseStatement(ADL.verbs.initialized)];
        this.sendStatements(statements, _.bind(function (error) {
          if (error) {
            this.onInitialised(error);
            return this;
          }

          if (['ios', 'android'].indexOf(Adapt$1.device.OS) > -1) {
            $(document).on('visibilitychange', this.onVisibilityChange.bind(this));
          } else {
            $(window).on('beforeunload unload', this.sendUnloadStatements.bind(this));
          }

          if (!this.get('shouldTrackState')) {
            this.onInitialised();
            return this;
          }

          this.getState(_.bind(function (error) {
            if (error) {
              this.onInitialised(error);
              return this;
            }

            if (_.isEmpty(this.get('state'))) {
              this.sendStatement(this.getCourseStatement(ADL.verbs.attempted));
            } else {
              this.sendStatement(this.getCourseStatement(ADL.verbs.resumed));
            }

            this.restoreState();
            this.onInitialised();
            return this;
          }, this));
        }, this));
      }, this));
    },
    getLearnerInfo: function () {
      var globals = Adapt$1.course.get('_globals');

      if (!globals._learnerInfo) {
        globals._learnerInfo = {};
      }

      _.extend(globals._learnerInfo, Adapt$1.offlineStorage.get('learnerinfo'));
    },
    initializeWrapper: function (callback) {
      if (!this.getConfig('_endpoint')) {
        this.xapiWrapper = window.xapiWrapper || ADL.XAPIWrapper;

        if (this.checkWrapperConfig()) {
          this.set({
            registration: this.getLRSAttribute('registration'),
            actor: this.getLRSAttribute('actor')
          });
          this.xapiWrapper.strictCallbacks = true;
          callback();
        } else {
          ADL.launch(_.bind(function (error, launchData, xapiWrapper) {
            if (error) {
              return callback(error);
            }

            this.xapiWrapper = xapiWrapper;
            this.set({
              actor: launchData.actor
            });
            this.xapiWrapper.strictCallbacks = true;
            callback();
          }, this), true, true);
        }
      } else {
        this.xapiWrapper = window.xapiWrapper || ADL.XAPIWrapper;
        var configError;

        try {
          this.setWrapperConfig();
        } catch (error) {
          configError = error;
        }

        if (configError) {
          return callback(error);
        }

        function uuidv4() {
          return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c => (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16));
        }

        function getDomain(url) {
          var domain = new URL(url).hostname;
          var elems = domain.split('.');
          var iMax = elems.length - 1;
          var isSecondLevel = elems.length >= 3 && (elems[iMax] + elems[iMax - 1]).length <= 5;
          var tld = elems.splice(isSecondLevel ? -3 : -2).join('.');

          if (tld != "localhost") {
            return "." + tld;
          }

          return tld;
        }

        function setCookie(cname, cvalue, exdays) {
          const d = new Date();
          d.setTime(d.getTime() + exdays * 24 * 60 * 60 * 1000);
          let expires = "expires=" + d.toUTCString();
          document.cookie = cname + "=" + cvalue + ";" + expires + ";path=/;domain=" + getDomain(window.location);
        }

        function getCookie(cname) {
          let name = cname + "=";
          let decodedCookie = decodeURIComponent(document.cookie);
          let ca = decodedCookie.split(';');

          for (let i = 0; i < ca.length; i++) {
            let c = ca[i];

            while (c.charAt(0) == ' ') {
              c = c.substring(1);
            }

            if (c.indexOf(name) == 0) {
              return c.substring(name.length, c.length);
            }
          }

          return "";
        }

        if (this.debug) {
          console.log('xAPI: Checking Cookies for actor, or generating random actor');
        }

        let cookieDomain = this.getConfig('_cookiePrefix');

        if (getCookie(cookieDomain + '.actor') !== "") {
          this.xapiWrapper.lrs.actor = `${getCookie(cookieDomain + '.actor')}`;

          if (this.debug) {
            console.log('xAPI: an actor exists in cookies and is:');
            console.log(`${getCookie(cookieDomain + '.actor')}`);
          }

          this.set({
            registration: getCookie(cookieDomain + '.registration'),
            actor: JSON.parse(getCookie(cookieDomain + '.actor'))
          });
          this.xapiWrapper.strictCallbacks = true;
          callback();
        } else if (getCookie(cookieDomain + '.actor') === "") {
          if (this.debug) {
            console.log('xAPI: actor does not exist in local storage');
          }

          var courseUser = `${uuidv4()}`;
          var actor = {
            "objectType": "Agent",
            "name": courseUser,
            "account": {
              "homePage": "https://theodi.org",
              "name": courseUser
            }
          };
          setCookie(cookieDomain + '.actor', JSON.stringify(actor), 365);
          setCookie(cookieDomain + '.registration', courseUser, 365);
          this.set({
            registration: courseUser,
            actor: actor
          });

          if (this.debug) {
            console.log('xAPI: Generated new actor');
            console.log(actor);
            console.log(getCookie(cookieDomain + 'actor'));
          }

          this.xapiWrapper.strictCallbacks = true;
          callback();
        } else {
          if (this.debug) {
            console.log('xAPI: Failed to generate actor, looking for actor in config?');
          }

          this.set({
            registration: this.getLRSAttribute('registration'),
            actor: this.getLRSAttribute('actor')
          });
          this.xapiWrapper.strictCallbacks = true;
          callback();
        }
      }
    },
    onInitialised: function (error) {
      this.set({
        isInitialised: !!!error
      });
      Adapt$1.wait.end();

      _.defer(function () {
        if (error) {
          Adapt$1.trigger('xapi:lrs:initialize:error', error);
          return;
        }

        Adapt$1.trigger('xapi:lrs:initialize:success');
      });
    },
    onLanguageChanged: function (newLanguage) {
      this.set({
        displayLang: newLanguage
      });
      this.deleteState(function () {
        this.sendStatement(this.getCourseStatement(ADL.verbs.launched));
      });
    },
    onVisibilityChange: function () {
      if (document.visibilityState === 'visible') {
        this.isTerminated = false;
        return this.sendStatement(this.getCourseStatement(ADL.verbs.resumed));
      }

      this.sendUnloadStatements();
    },
    sendUnloadStatements: function () {
      if (this.isTerminated) {
        return;
      }

      var statements = [];

      if (!this.isComplete) {
        statements.push(this.getCourseStatement(ADL.verbs.suspended));
      }

      statements.push(this.getCourseStatement(ADL.verbs.terminated));
      this.sendStatementsSync(statements);
      this.isTerminated = true;
    },
    checkWrapperConfig: function () {
      if (this.xapiWrapper.lrs.endpoint && this.xapiWrapper.lrs.actor && this.xapiWrapper.lrs.auth && this.xapiWrapper.lrs.activity_id) {
        return true;
      } else {
        return false;
      }
    },
    setWrapperConfig: function () {
      var keys = ['endpoint', 'user', 'password'];
      var newConfig = {};

      _.each(keys, function (key) {
        var val = this.getConfig('_' + key);

        if (val) {
          if (key === 'endpoint') {
            val = val.replace(/\/?$/, '/');

            if (!/^https?:\/\//i.test(val)) {
              Adapt$1.log.warn('adapt-contrib-xapi: "_endpoint" value is missing protocol (defaulting to http://)');
              val = 'http://' + val;
            }
          }

          newConfig[key] = val;
        }
      }, this);

      if (!_.isEmpty(newConfig)) {
        this.xapiWrapper.changeConfig(newConfig);

        if (!this.xapiWrapper.testConfig()) {
          throw new Error('Incorrect xAPI configuration detected');
        }
      }
    },
    getBaseUrl: function () {
      var url = window.location.origin + window.location.pathname;
      Adapt$1.log.info('adapt-contrib-xapi: Using detected URL (' + url + ') as ActivityID');
      return url;
    },
    getAttemptDuration: function () {
      return this.startAttemptDuration + this.getSessionDuration();
    },
    getSessionDuration: function () {
      return Math.abs(new Date() - this.startTimeStamp);
    },
    convertMillisecondsToISO8601Duration: function (inputMilliseconds) {
      var hours;
      var minutes;
      var seconds;
      var i_inputMilliseconds = parseInt(inputMilliseconds, 10);
      var i_inputCentiseconds;
      var inputIsNegative = '';
      var rtnStr = '';
      i_inputCentiseconds = Math.round(i_inputMilliseconds / 10);

      if (i_inputCentiseconds < 0) {
        inputIsNegative = '-';
        i_inputCentiseconds = i_inputCentiseconds * -1;
      }

      hours = parseInt(i_inputCentiseconds / 360000, 10);
      minutes = parseInt(i_inputCentiseconds % 360000 / 6000, 10);
      seconds = i_inputCentiseconds % 360000 % 6000 / 100;
      rtnStr = inputIsNegative + 'PT';

      if (hours > 0) {
        rtnStr += hours + 'H';
      }

      if (minutes > 0) {
        rtnStr += minutes + 'M';
      }

      rtnStr += seconds + 'S';
      return rtnStr;
    },
    setupListeners: function () {
      if (!this.get('isInitialised')) {
        Adapt$1.log.warn('adapt-contrib-xapi: Unable to setup listeners for xAPI');
        return;
      }

      this.getLearnerInfo();
      this.listenTo(Adapt$1, 'app:languageChanged', this.onLanguageChanged);

      if (this.get('shouldTrackState')) {
        this.listenTo(Adapt$1, 'state:change', this.sendState);
      }

      this.coreEvents = _.extend(this.coreEvents, this.getConfig('_coreEvents'));
      this.listenTo(Adapt$1, 'tracking:complete', this.onTrackingComplete);

      if (this.coreEvents['Adapt']['router:menu']) {
        this.listenTo(Adapt$1, 'router:menu', this.onItemExperience);
      }

      if (this.coreEvents['Adapt']['router:page']) {
        this.listenTo(Adapt$1, 'router:page', this.onItemExperience);
      }

      if (this.coreEvents['Adapt']['questionView:recordInteraction']) {
        this.listenTo(Adapt$1, 'questionView:recordInteraction', this.onQuestionInteraction);
      }

      if (this.coreEvents['Adapt']['assessments:complete']) {
        this.listenTo(Adapt$1, 'assessments:complete', this.onAssessmentComplete);
      }

      _.each(_.keys(this.coreEvents), function (key) {
        if (key !== 'Adapt') {
          var val = this.coreEvents[key];

          if (typeof val === 'object' && val['change:_isComplete'] === true) {
            this.listenTo(Adapt$1[key], 'change:_isComplete', this.onItemComplete);
          }
        }
      }, this);
    },
    getCourseActivity: function () {
      var object = new ADL.XAPIStatement.Activity(this.get('activityId'));
      var name = {};
      var description = {};
      name[this.get('displayLang')] = this.courseName;
      description[this.get('displayLang')] = this.courseDescription;
      object.definition = {
        type: ADL.activityTypes.course,
        name: name,
        description: description
      };
      return object;
    },
    getCourseStatement: function (verb, result) {
      if (typeof result === 'undefined') {
        result = {};
      }

      var object = this.getCourseActivity();

      switch (verb) {
        case ADL.verbs.launched:
        case ADL.verbs.initialized:
        case ADL.verbs.attempted:
          {
            result.duration = 'PT0S';
            break;
          }

        case ADL.verbs.failed:
        case ADL.verbs.passed:
        case ADL.verbs.suspended:
          {
            result.duration = this.convertMillisecondsToISO8601Duration(this.getAttemptDuration());
            break;
          }

        case ADL.verbs.terminated:
          {
            result.duration = this.convertMillisecondsToISO8601Duration(this.getSessionDuration());
            break;
          }
      }

      return this.getStatement(this.getVerb(verb), object, result);
    },
    getNameObject: function (model) {
      var name = {};
      name[this.get('displayLang')] = model.get('displayTitle') || model.get('title');
      return name;
    },
    getActivityType: function (model) {
      var type = '';

      switch (model.get('_type')) {
        case 'component':
          {
            type = model.get('_isQuestionType') ? ADL.activityTypes.interaction : ADL.activityTypes.media;
            break;
          }

        case 'block':
        case 'article':
          {
            type = ADL.activityTypes.interaction;
            break;
          }

        case 'course':
          {
            type = ADL.activityTypes.course;
            break;
          }

        case 'menu':
          {
            type = ADL.activityTypes.module;
            break;
          }

        case 'page':
          {
            type = ADL.activityTypes.lesson;
            break;
          }
      }

      return type;
    },
    onQuestionInteraction: function (view) {
      if (!view.model || view.model.get('_type') !== 'component' && !view.model.get('_isQuestionType')) {
        return;
      }

      if (this.isComponentOnBlacklist(view.model.get('_component'))) {
        return;
      }

      var object = new ADL.XAPIStatement.Activity(this.getUniqueIri(view.model));
      var isComplete = view.model.get('_isComplete');
      var lang = this.get('displayLang');
      var statement;
      var description = {};
      description[this.get('displayLang')] = this.stripHtml(view.model.get('body'));
      object.definition = {
        name: this.getNameObject(view.model),
        description: description,
        type: ADL.activityTypes.question,
        interactionType: view.getResponseType()
      };

      if (typeof view.getInteractionObject === 'function') {
        _.extend(object.definition, view.getInteractionObject());

        _.each(_.keys(object.definition), function (key) {
          if (_.isArray(object.definition[key]) && object.definition[key].length !== 0) {
            for (var i = 0; i < object.definition[key].length; i++) {
              if (!object.definition[key][i].hasOwnProperty('description')) {
                break;
              }

              if (typeof object.definition[key][i].description === 'string') {
                var description = {};
                description[lang] = object.definition[key][i].description;
                object.definition[key][i].description = description;
              }
            }
          }
        });
      }

      var result = {
        score: {
          raw: view.model.get('_score') || 0
        },
        success: view.model.get('_isCorrect'),
        completion: isComplete,
        response: this.processInteractionResponse(object.definition.interactionType, view.getResponse())
      };
      statement = this.getStatement(this.getVerb(ADL.verbs.answered), object, result);
      this.addGroupingActivity(view.model, statement);
      this.sendStatement(statement);
    },
    stripHtml: function (html) {
      var tempDiv = document.createElement('div');
      tempDiv.innerHTML = html;
      return tempDiv.textContent || tempDiv.innerText || '';
    },
    processInteractionResponse: function (responseType, response) {
      switch (responseType) {
        case 'choice':
          {
            response = response.replace(/,|#/g, '[,]');
            break;
          }

        case 'matching':
          {
            response = response.split('#').map(function (val, i) {
              return i + 1 + '[.]' + val.replace('.', '_');
            }).join('[,]');
            break;
          }
      }

      return response;
    },
    onItemExperience: function (model) {
      if (model.get('_id') === 'course') {
        return;
      }

      var object = new ADL.XAPIStatement.Activity(this.getUniqueIri(model));
      var statement;
      object.definition = {
        name: this.getNameObject(model),
        type: this.getActivityType(model)
      };
      statement = this.getStatement(this.getVerb(ADL.verbs.experienced), object);
      this.addGroupingActivity(model, statement);
      this.sendStatement(statement);
    },
    isComponentOnBlacklist: function (component) {
      return this.get('componentBlacklist').indexOf(component) !== -1;
    },
    onItemComplete: function (model, isComplete) {
      if (isComplete === false) {
        return;
      }

      if (model.get('_type') === 'component' && model.get('_isQuestionType') === true && this.coreEvents['Adapt']['questionView:recordInteraction'] === true && this.coreEvents['components']['change:_isComplete'] === true) {
        return;
      }

      if (model.get('_type') === 'component' && this.isComponentOnBlacklist(model.get('_component'))) {
        return;
      }

      var result = {
        completion: true
      };
      var object = new ADL.XAPIStatement.Activity(this.getUniqueIri(model));
      var statement;
      object.definition = {
        name: this.getNameObject(model),
        type: this.getActivityType(model)
      };
      statement = this.getStatement(this.getVerb(ADL.verbs.completed), object, result);
      this.addGroupingActivity(model, statement);
      this.sendStatement(statement);
    },
    getLessonActivity: function (page) {
      var pageModel = typeof page === 'string' ? Adapt$1.findById(page) : page;
      var activity = new ADL.XAPIStatement.Activity(this.getUniqueIri(pageModel));
      var name = this.getNameObject(pageModel);
      activity.definition = {
        name: name,
        type: ADL.activityTypes.lesson
      };
      return activity;
    },
    addGroupingActivity: function (model, statement) {
      var type = model.get('_type');

      if (type !== 'course') {
        statement.addGroupingActivity(this.getCourseActivity());
      }

      if (['article', 'block', 'component'].indexOf(type) !== -1) {
        var pageModel = model.findAncestor('pages');
        statement.addGroupingActivity(this.getLessonActivity(pageModel));
      }

      if (type === 'component' && model.get('_isPartOfAssessment')) {
        let articleModel = model.findAncestor('articles');

        if (articleModel && articleModel.has('_assessment') && articleModel.get('_assessment')._isEnabled) {
          var assessment = {
            id: articleModel.get('_assessment')._id,
            articleId: articleModel.get('_id'),
            type: 'article-assessment',
            pageId: articleModel.get('_parentId')
          };
          statement.addParentActivity(this.getAssessmentObject(assessment));
        }
      }
    },
    getAssessmentResultObject: function (assessment) {
      var result = {
        score: {
          scaled: assessment.scoreAsPercent / 100,
          raw: assessment.score,
          min: 0,
          max: assessment.maxScore
        },
        success: assessment.isPass,
        completion: assessment.isComplete
      };
      return result;
    },
    getAssessmentObject: function (assessment) {
      var fakeModel = new Backbone.Model({
        _id: assessment.id || assessment.articleId,
        _type: assessment.type,
        pageId: assessment.pageId
      });
      var object = new ADL.XAPIStatement.Activity(this.getUniqueIri(fakeModel));
      var name = {};
      name[this.get('displayLang')] = assessment.id || 'Assessment';
      object.definition = {
        name: name,
        type: ADL.activityTypes.assessment
      };
      return object;
    },
    onAssessmentComplete: function (assessment) {
      var self = this;
      var object = this.getAssessmentObject(assessment);
      var result = this.getAssessmentResultObject(assessment);
      var statement;

      if (assessment.isPass) {
        statement = this.getStatement(this.getVerb(ADL.verbs.passed), object, result);
      } else {
        statement = this.getStatement(this.getVerb(ADL.verbs.failed), object, result);
      }

      statement.addGroupingActivity(this.getCourseActivity());
      statement.addGroupingActivity(this.getLessonActivity(assessment.pageId));

      _.delay(function () {
        self.sendStatement(statement);
      }, 500);
    },
    getVerb: function (verb) {
      if (typeof verb === 'string') {
        var key = verb.toLowerCase();
        verb = ADL.verbs[key];

        if (!verb) {
          Adapt$1.log.error('adapt-contrib-xapi: Verb "' + key + '" does not exist in ADL.verbs object');
        }
      }

      if (typeof verb !== 'object') {
        throw new Error('Unrecognised verb: ' + verb);
      }

      var lang = this.get('lang') || this.defaultLang;
      var singleLanguageVerb = {
        id: verb.id,
        display: {}
      };
      var description = verb.display[lang];

      if (description) {
        singleLanguageVerb.display[lang] = description;
      } else {
        singleLanguageVerb.display[this.defaultLang] = verb.display[this.defaultLang];
      }

      return singleLanguageVerb;
    },
    getUniqueIri: function (model) {
      var iri = this.get('activityId');
      var type = model.get('_type');

      if (type !== 'course') {
        if (type === 'article-assessment') {
          iri = iri + ['#', 'assessment', model.get('_id')].join('/');
        } else {
          iri = iri + ['#/id', model.get('_id')].join('/');
        }
      }

      return iri;
    },
    onTrackingComplete: function (completionData) {
      var self = this;
      var result = {};
      var completionVerb;

      switch (completionData.status) {
        case COMPLETION_STATE$1.PASSED:
          {
            completionVerb = ADL.verbs.passed;
            break;
          }

        case COMPLETION_STATE$1.FAILED:
          {
            completionVerb = ADL.verbs.failed;
            break;
          }

        default:
          {
            completionVerb = ADL.verbs.completed;
          }
      }

      if (completionVerb === ADL.verbs.completed) {
        result = {
          completion: true
        };
      } else {
        result = this.getAssessmentResultObject(completionData.assessment);
      }

      this.isComplete = true;

      _.defer(function () {
        self.sendStatement(self.getCourseStatement(completionVerb, result));
      });
    },
    restoreState: function () {
      var state = this.get('state');

      if (_.isEmpty(state)) {
        return;
      }

      var Adapt = require('core/js/adapt');

      if (state.components) {
        _.each(state.components, function (stateObject) {
          var restoreModel = Adapt.findById(stateObject._id);

          if (restoreModel) {
            restoreModel.setTrackableState(stateObject);
          } else {
            Adapt.log.warn('adapt-contrib-xapi: Unable to restore state for component: ' + stateObject._id);
          }
        });
      }

      if (state.blocks) {
        _.each(state.blocks, function (stateObject) {
          var restoreModel = Adapt.findById(stateObject._id);

          if (restoreModel) {
            restoreModel.setTrackableState(stateObject);
          } else {
            Adapt.log.warn('adapt-contrib-xapi: Unable to restore state for block: ' + stateObject._id);
          }
        });
      }
    },
    getStatement: function (verb, object, result, context) {
      var statement = new ADL.XAPIStatement(new ADL.XAPIStatement.Agent(this.get('actor')), verb, object);

      if (result && !_.isEmpty(result)) {
        statement.result = result;
      }

      if (context) {
        statement.context = context;
      }

      if (this.get('_generateIds')) {
        statement.generateId();
      }

      return statement;
    },
    sendState: function (model, modelState) {
      if (this.get('shouldTrackState') !== true) {
        return;
      }

      var activityId = this.get('activityId');
      var actor = this.get('actor');
      var type = model.get('_type');
      var state = this.get('state');
      var registration = this.get('shouldUseRegistration') === true ? this.get('registration') : null;

      var collectionName = _.findKey(this.coreObjects, function (o) {
        return o === type || o.indexOf(type) > -1;
      });

      var stateCollection = _.isArray(state[collectionName]) ? state[collectionName] : [];
      var newState;

      if (collectionName !== 'course' && collectionName !== 'offlineStorage') {
        var index = _.findIndex(stateCollection, {
          _id: model.get('_id')
        });

        if (index !== -1) {
          stateCollection.splice(index, 1, modelState);
        } else {
          stateCollection.push(modelState);
        }

        newState = stateCollection;
      } else {
        newState = modelState;
      }

      state[collectionName] = newState;
      this.set({
        state: state
      });
      this.xapiWrapper.sendState(activityId, actor, collectionName, registration, newState, null, null, function (error, xhr) {
        if (error) {
          Adapt$1.trigger('xapi:lrs:sendState:error', error);
        }

        Adapt$1.trigger('xapi:lrs:sendState:success', newState);
      });
    },
    getState: function (callback) {
      callback = _.isFunction(callback) ? callback : function () {};
      var self = this;
      var activityId = this.get('activityId');
      var actor = this.get('actor');
      var registration = this.get('shouldUseRegistration') === true ? this.get('registration') : null;
      var state = {};
      Async__default["default"].each(_.keys(this.coreObjects), function (type, nextType) {
        self.xapiWrapper.getState(activityId, actor, type, registration, null, function (error, xhr) {
          _.defer(function () {
            if (error) {
              Adapt$1.log.warn('adapt-contrib-xapi: getState() failed for ' + activityId + ' (' + type + ')');
              return nextType(error);
            }

            if (!xhr) {
              Adapt$1.log.warn('adapt-contrib-xapi: getState() failed for ' + activityId + ' (' + type + ')');
              return nextType(new Error('\'xhr\' parameter is missing from callback'));
            }

            if (xhr.status === 404) {
              return nextType();
            }

            if (xhr.status !== 200) {
              Adapt$1.log.warn('adapt-contrib-xapi: getState() failed for ' + activityId + ' (' + type + ')');
              return nextType(new Error('Invalid status code ' + xhr.status + ' returned from getState() call'));
            }

            var response;
            var parseError;

            if (xhr.response === '') {
              return nextType();
            }

            try {
              response = JSON.parse(xhr.response);
            } catch (e) {
              parseError = e;
            }

            if (parseError) {
              return nextType(parseError);
            }

            if (!_.isEmpty(response)) {
              state[type] = response;
            }

            return nextType();
          });
        });
      }, function (error) {
        if (error) {
          Adapt$1.log.error('adapt-contrib-xapi:', error);
          return callback(error);
        }

        if (!_.isEmpty(state)) {
          self.set({
            state: state
          });
        }

        Adapt$1.trigger('xapi:stateLoaded');
        callback();
      });
    },
    deleteState: function (callback) {
      callback = _.isFunction(callback) ? callback : function () {};
      var self = this;
      var activityId = this.get('activityId');
      var actor = this.get('actor');
      var registration = this.get('shouldUseRegistration') === true ? this.get('registration') : null;
      Async__default["default"].each(_.keys(this.coreObjects), function (type, nextType) {
        self.xapiWrapper.deleteState(activityId, actor, type, registration, null, null, function (error, xhr) {
          if (error) {
            Adapt$1.log.warn('adapt-contrib-xapi: deleteState() failed for ' + activityId + ' (' + type + ')');
            return nextType(error);
          }

          if (!xhr) {
            Adapt$1.log.warn('adapt-contrib-xapi: deleteState() failed for ' + activityId + ' (' + type + ')');
            return nextType(new Error('\'xhr\' parameter is missing from callback'));
          }

          if (xhr.status !== 204) {
            Adapt$1.log.warn('adapt-contrib-xapi: deleteState() failed for ' + activityId + ' (' + type + ')');
            return nextType(new Error('Invalid status code ' + xhr.status + ' returned from getState() call'));
          }

          return nextType();
        });
      }, function (error) {
        if (error) {
          Adapt$1.log.error('adapt-contrib-xapi:', error);
          return callback(error);
        }

        callback();
      });
    },
    getConfig: function (key) {
      if (!this.config || key === '' || typeof this.config[key] === 'undefined') {
        return false;
      }

      return this.config[key];
    },
    getLRSAttribute: function (key) {
      if (!this.xapiWrapper || !this.xapiWrapper.lrs || undefined === this.xapiWrapper.lrs[key]) {
        return null;
      }

      try {
        switch (key) {
          case 'actor':
            {
              var actor = JSON.parse(this.xapiWrapper.lrs[key]);

              if (_.isArray(actor.name)) {
                actor.name = actor.name[0];
              }

              if (_.isArray(actor.mbox)) {
                actor.mbox = actor.mbox[0];
              }

              if (_.isArray(actor.account)) {
                var account = {};

                if (typeof actor.account[0].accountServiceHomePage !== 'undefined') {
                  account.homePage = actor.account[0].accountServiceHomePage;
                } else if (actor.account[0].homePage !== 'undefined') {
                  account.homePage = actor.account[0].homePage;
                }

                if (typeof actor.account[0].accountName !== 'undefined') {
                  account.name = actor.account[0].accountName;
                } else if (typeof actor.account[0].name !== 'undefined') {
                  account.name = actor.account[0].name;
                }

                delete actor.account;
                actor.account = account;
              }

              return actor;
            }

          default:
            return this.xapiWrapper.lrs[key];
        }
      } catch (e) {
        return null;
      }
    },
    getLRSExtendedAttribute: function (key) {
      var extended = this.getLRSAttribute('extended');

      if (extended == null) {
        return null;
      }

      try {
        if (key === 'definition') {
          return JSON.parse(extended.definition);
        }

        return extended[key];
      } catch (e) {
        return null;
      }
    },
    validateProps: function () {
      var errorCount = 0;

      if (!this.get('actor') || typeof this.get('actor') !== 'object') {
        Adapt$1.log.warn('adapt-contrib-xapi: "actor" attribute not found!');
        errorCount++;
      }

      if (!this.get('activityId')) {
        Adapt$1.log.warn('adapt-contrib-xapi: "activityId" attribute not found!');
        errorCount++;
      }

      if (errorCount > 0) {
        return false;
      }

      return true;
    },
    sendStatement: function (statement, callback, attachments) {
      callback = _.isFunction(callback) ? callback : function () {};

      if (!statement) {
        return;
      }

      Adapt$1.trigger('xapi:preSendStatement', statement);

      if (_.isUndefined(attachments) && statement.attachments) {
        return this.processAttachments(statement, callback);
      } else {
        this.onStatementReady(statement, callback, attachments);
      }
    },
    sendStatementsSync: function (statements) {
      var lrs = ADL.XAPIWrapper.lrs;

      if (!window.fetch || this.isCORS(lrs.endpoint)) {
        return this.sendStatements(statements);
      }

      var url = lrs.endpoint + 'statements';
      var credentials = ADL.XAPIWrapper.withCredentials ? 'include' : 'omit';
      var headers = {
        'Content-Type': 'application/json',
        'Authorization': lrs.auth,
        'X-Experience-API-Version': ADL.XAPIWrapper.xapiVersion
      };

      var extended = _.map(lrs.extended, function (value, key) {
        return key + '=' + encodeURIComponent(value);
      });

      if (extended.length > 0) {
        url += (url.indexOf('?') > -1 ? '&' : '?') + extended.join('&');
      }

      fetch(url, {
        body: JSON.stringify(statements),
        cache: 'no-cache',
        credentials: credentials,
        headers: headers,
        mode: 'same-origin',
        keepalive: true,
        method: 'POST'
      }).then(function () {
        Adapt$1.trigger('xapi:lrs:sendStatement:success', statements);
      }).catch(function (error) {
        Adapt$1.trigger('xapi:lrs:sendStatement:error', error);
      });
    },
    isCORS: function (url) {
      var urlparts = url.toLowerCase().match(/^(.+):\/\/([^:\/]*):?(\d+)?(\/.*)?$/);
      var isCORS = location.protocol.toLowerCase().replace(':', '') !== urlparts[1] || location.hostname.toLowerCase() !== urlparts[2];

      if (!isCORS) {
        var urlPort = urlparts[3] === null ? urlparts[1] === 'http' ? '80' : '443' : urlparts[3];
        isCORS = urlPort === location.port;
      }

      return isCORS;
    },
    onStatementReady: function (statement, callback, attachments) {
      this.xapiWrapper.sendStatement(statement, function (error) {
        if (error) {
          Adapt$1.trigger('xapi:lrs:sendStatement:error', error);
          return callback(error);
        }

        Adapt$1.trigger('xapi:lrs:sendStatement:success', statement);
        return callback();
      }, attachments);
    },
    processAttachments: function (statement, callback) {
      var attachments = statement.attachments;
      Async__default["default"].each(attachments, function (attachment, nextAttachment) {
        if (attachment.value) {
          nextAttachment();
        } else if (attachment.url) {
          var xhr = new XMLHttpRequest();

          xhr.onreadystatechange = function () {
            if (this.readyState === 4 && this.status === 200) {
              var reader = new FileReader();

              reader.onload = function () {
                attachment.value = reader.result;
                delete attachment.url;
                nextAttachment();
              };

              reader.readAsBinaryString(this.response);
            }
          };

          xhr.open('GET', attachment.url);
          xhr.responseType = 'blob';
          xhr.send();
        } else {
          Adapt$1.log.warn('Attachment object contained neither a value or url property.');
        }
      }, function () {
        delete statement.attachments;
        this.onStatementReady(statement, callback, attachments);
      }.bind(this));
    },
    sendStatements: function (statements, callback) {
      callback = _.isFunction(callback) ? callback : function () {};

      if (!statements || statements.length === 0) {
        return;
      }

      Adapt$1.trigger('xapi:preSendStatements', statements);
      Async__default["default"].each(statements, function (statement, nextStatement) {
        this.sendStatement(statement, nextStatement);
      }.bind(this), function (error) {
        if (error) {
          Adapt$1.log.error('adapt-contrib-xapi:', error);
          return callback(error);
        }

        callback();
      });
    },
    getGlobals: function () {
      return _.defaults(Adapt$1 && Adapt$1.course && Adapt$1.course.get('_globals') && Adapt$1.course.get('_globals')._extensions && Adapt$1.course.get('_globals')._extensions._xapi || {}, {
        'confirm': 'OK',
        'lrsConnectionErrorTitle': 'LRS not available',
        'lrsConnectionErrorMessage': 'We were unable to connect to your Learning Record Store (LRS). This means that your progress cannot be recorded.'
      });
    },
    showError: function () {
      if (this.getConfig('_lrsFailureBehaviour') === 'ignore') {
        return;
      }

      var notifyObject = {
        title: this.getGlobals().lrsConnectionErrorTitle,
        body: this.getGlobals().lrsConnectionErrorMessage,
        confirmText: this.getGlobals().confirm
      };
      Adapt$1.wait.begin();
      Adapt$1.trigger('notify:alert', notifyObject);
      $('.notify').css({
        position: 'relative',
        zIndex: 5001
      });
      Adapt$1.once('notify:closed', Adapt$1.wait.end);
    }
  });

  xAPI.getInstance = function () {
    if (!xAPI.instance) {
      xAPI.instance = new xAPI();
    }

    return xAPI.instance;
  };

  Adapt$1.once('app:dataLoaded', function () {
    var xapi = xAPI.getInstance();
    xapi.initialize();
    Adapt$1.on('adapt:initialize', function () {
      xapi.setupListeners();
    });
    Adapt$1.on('xapi:lrs:initialize:error', function (error) {
      Adapt$1.log.error('adapt-contrib-xapi: xAPI Wrapper initialisation failed', error);
      xapi.showError();
    });
    Adapt$1.on('xapi:lrs:sendStatement:error', function (error) {
      xapi.showError();
    });
    Adapt$1.on('xapi:lrs:sendState:error', function (error) {
      xapi.showError();
    });
  });
  var xapi = __AMD("extensions/adapt-contrib-xapi/js/adapt-contrib-xapi", xAPI.getInstance());

  var offlineStorage = {
    load: function () {
      var fakeModel = {
        get: function () {
          return 'offlineStorage';
        }
      };
      var store = new Backbone.Model();
      var isDataRestored = false;
      Adapt$1.offlineStorage.initialize({
        get: function (name) {
          if (!name) {
            return this.getAll();
          }

          if (!this.useTemporaryStore() && name.toLowerCase() === 'learnerinfo') {
            return this.getLearnerInfo();
          }

          return store.get(name);
        },
        getAll: function () {
          if (!isDataRestored) {
            var state = xapi.get('state') || {};
            store.set(state.offlineStorage);
            isDataRestored = true;
          }

          if (this.useTemporaryStore()) {
            return store.toJSON();
          }

          return _.extend(store.toJSON(), {
            learnerInfo: this.getLearnerInfo()
          });
        },
        set: function (name, value) {
          store.set(name, value);
          Adapt$1.trigger('state:change', fakeModel, store.toJSON());
        },
        useTemporaryStore: function () {
          return !xapi.get('isInitialised');
        },
        getLearnerInfo: function () {
          var actor = xapi.get('actor') || {};
          var name = actor.name || '';
          var lastname;
          var firstname;
          var matches = name.match(/(\S+)\s(.+)/);

          if (matches && matches.length > 2) {
            lastname = matches[2];
            firstname = matches[1];
          } else {
            console.log('xAPI: actor name not in "firstname lastname" format');
          }

          return {
            id: this.getLearnerId(actor),
            name: name,
            lastname: lastname,
            firstname: firstname
          };
        },
        getLearnerId: function (actor) {
          var name = actor.account && actor.account.name;

          if (name) {
            return name;
          }

          if (actor.openid) {
            return actor.openid;
          }

          if (typeof actor.mbox === 'string' && actor.mbox.length > 0) {
            return actor.mbox.replace('mailto:', '');
          }

          console.log('xAPI: could not determine the learner\'s ID');
          return null;
        }
      });
    }
  };
  var offlineStorage$1 = __AMD("extensions/adapt-contrib-xapi/js/adapt-offlineStorage-xapi", offlineStorage);

  Adapt$1.on('app:dataLoaded', initialise);

  function initialise() {
    var config = Adapt$1.config.get('_xapi') || {};

    if (!config._isEnabled) {
      return;
    }

    offlineStorage$1.load();
    var successEvent = config._shouldTrackState ? 'xapi:stateLoaded' : 'xapi:lrs:initialize:success';
    Adapt$1.once('xapi:lrs:initialize:error ' + successEvent, function () {
      Adapt$1.offlineStorage.get();
      Adapt$1.offlineStorage.setReadyStatus();
    });
  }

  var DevtoolsModel = Backbone.Model.extend({
    initialize: function () {
      var config = Adapt$1.config.has('_devtools') ? Adapt$1.config.get('_devtools') : this.getDefaultConfig();
      this.set(_.extend({
        '_trickleEnabled': false,
        '_hintingAvailable': true,
        '_hintingEnabled': false,
        '_toggleFeedbackAvailable': true,
        '_feedbackEnabled': true,
        '_autoCorrectAvailable': true,
        '_autoCorrectEnabled': false,
        '_altTextAvailable': true,
        '_altTextEnabled': false,
        '_tutorListener': null,
        '_unlockAvailable': true,
        '_unlocked': false,
        '_toggleBankingAvailable': true,
        '_traceFocusAvailable': true,
        '_traceFocusEnabled': false,
        '_extended': true
      }, config));
    },
    getDefaultConfig: function () {
      return {
        '_isEnabled': false,
        '_extended': true
      };
    },
    toggleFeedback: function () {
      this.set('_feedbackEnabled', !this.get('_feedbackEnabled'));
    },
    toggleHinting: function () {
      this.set('_hintingEnabled', !this.get('_hintingEnabled'));
    },
    toggleAutoCorrect: function () {
      this.set('_autoCorrectEnabled', !this.get('_autoCorrectEnabled'));
    },
    toggleAltText: function () {
      this.set('_altTextEnabled', !this.get('_altTextEnabled'));
    },
    toggleTraceFocus: function () {
      this.set('_traceFocusEnabled', !this.get('_traceFocusEnabled'));
    }
  });
  var DevtoolsModel$1 = __AMD("extensions/adapt-devtools/js/devtools-model", DevtoolsModel);

  var Hinting = _.extend({
    initialize: function () {
      this.listenTo(Adapt$1.devtools, 'change:_hintingEnabled', this.toggleHints);
    },
    toggleHints: function () {
      var contentObject = Adapt$1.findById(Adapt$1.location._currentId);
      var components = contentObject.findDescendantModels('components');

      var renderedQuestions = _.filter(components, function (m) {
        return m.get('_isQuestionType') === true && m.get('_isReady') === true;
      });

      _.each(renderedQuestions, function (model) {
        this.setHinting($('.' + model.get('_id')), model, Adapt$1.devtools.get('_hintingEnabled'));
      }, this);

      if (Adapt$1.devtools.get('_hintingEnabled')) this.listenTo(Adapt$1, 'componentView:postRender', this.onComponentRendered);else this.stopListening(Adapt$1, 'componentView:postRender');
    },
    onComponentRendered: function (view, hintingEnabled) {
      if (view.model.get('_isQuestionType')) this.setHinting(view.$el, view.model);
    },
    setHinting: function ($el, model, hintingEnabled) {
      switch (model.get('_component')) {
        case 'mcq':
          this.setMcqHinting($el, model, hintingEnabled !== false);
          break;

        case 'gmcq':
          this.setGmcqHinting($el, model, hintingEnabled !== false);
          break;

        case 'matching':
          this.setMatchingHinting($el, model, hintingEnabled !== false);
          break;

        case 'ppq':
          this.setPpqHinting($el, model, hintingEnabled !== false);
          break;

        case 'slider':
          this.setSliderHinting($el, model, hintingEnabled !== false);
          break;

        case 'textinput':
          this.setTextInputHinting($el, model, hintingEnabled !== false);
          break;

        case 'questionStrip':
          this.setQuestionStripHinting($el, model, hintingEnabled !== false);
          break;
      }
    },
    setMcqHinting: function ($el, model, hintingEnabled) {
      if (hintingEnabled) {
        _.each(model.get('_items'), function (item, index) {
          $el.find('.js-mcq-item').eq(index).addClass(item._shouldBeSelected ? 'hint-is-correct' : 'hint-is-incorrect');
        });
      } else {
        $el.find('.js-mcq-item').removeClass('hint-is-correct hint-is-incorrect');
      }
    },
    setGmcqHinting: function ($el, model, hintingEnabled) {
      if (hintingEnabled) {
        _.each(model.get('_items'), function (item, index) {
          $el.find('.js-mcq-item').eq(index).addClass(item._shouldBeSelected ? 'hint-is-correct' : 'hint-is-incorrect');
        });
      } else {
        $el.find('.js-mcq-item').removeClass('hint-is-correct hint-is-incorrect');
      }
    },
    setMatchingHinting: function ($el, model, hintingEnabled) {
      if (hintingEnabled) {
        _.each(model.get('_items'), function (item, itemIndex) {
          var $item = $el.find('.item').eq(itemIndex);
          var $options = $item.find('.js-dropdown-list-item');

          _.each(item._options, function (option, optionIndex) {
            if (option._isCorrect) $options.eq(optionIndex + 1).find('.js-dropdown-list-item-inner').append('<span class="hint"> (correct)</span>');
          });
        });
      } else {
        $el.find('.js-dropdown-list-item-inner .hint').remove();
      }
    },
    setSliderHinting: function ($el, model, hintingEnabled) {
      if (hintingEnabled) {
        var correctAnswer = model.get('_correctAnswer');

        if (correctAnswer) {
          $el.find('.js-slider-number').addClass('hint-is-incorrect');
          $el.find('.js-slider-number[data-id="' + correctAnswer + '"]').removeClass('hint-is-incorrect').addClass('hint-is-correct');
        } else {
          $el.find('.js-slider-number').addClass('hint-is-incorrect');

          var bottom = model.get('_correctRange')._bottom;

          var top = model.get('_correctRange')._top;

          for (var i = bottom; i <= top; i++) $el.find('.js-slider-number[data-id="' + i + '"]').removeClass('hint-is-incorrect').addClass('hint-is-correct');
        }
      } else {
        $el.find('.js-slider-number').removeClass('hint-is-correct hint-is-incorrect');
      }
    },
    setTextInputHinting: function ($el, model, hintingEnabled) {
      if (hintingEnabled) {
        _.each(model.get('_items'), function (item, index) {
          if (model.get('_answers')) {
            $el.find('.js-textinput-item').eq(index).find('input').attr('placeholder', model.get('_answers')[index][0]);
          } else {
            $el.find('.js-textinput-item').eq(index).find('input').attr('placeholder', item._answers[0]);
          }
        });
      } else {
        _.each(model.get('_items'), function (item, index) {
          if (model.get('_answers')) {
            $el.find('.js-textinput-item').eq(index).find('input').attr('placeholder', item.placeholder);
          }
        });
      }
    },
    setQuestionStripHinting: function ($el, model, hintingEnabled) {
      if (hintingEnabled) {
        _.each(model.get('_items'), function (item, itemIndex) {
          var $item = $el.find('.component-item').eq(itemIndex);
          var $subItems = $item.find('.qs-strapline-header-inner:not(.qs-noop) .qs-strapline-title-inner');

          _.each(item._subItems, function (subItem, subItemIndex) {
            if (subItem._isCorrect) $subItems.eq(subItemIndex).append('<span class="hint"> (correct)</span>');
          });
        });
      } else {
        $el.find('.qs-strapline-title-inner .hint').remove();
      }
    },
    setPpqHinting: function ($el, model, hintingEnabled) {
      console.log('setPpqHinting', hintingEnabled);

      if (!model.get('_developerMode')) {
        $el.find('.ppq-correct-zone').toggleClass('display-none', !hintingEnabled);
        $el.find('.ppq-pinboard').toggleClass('developer-mode', hintingEnabled);
      }
    }
  }, Backbone.Events);

  Adapt$1.once('adapt:initialize devtools:enable', function () {
    if (!Adapt$1.devtools.get('_isEnabled')) return;
    Hinting.initialize();
  });
  var Hinting$1 = __AMD("extensions/adapt-devtools/js/hinting", Hinting);

  function isQuestionSupported(model) {
    switch (model.get('_component')) {
      case 'mcq':
      case 'gmcq':
      case 'matching':
      case 'ppq':
      case 'slider':
      case 'textinput':
      case 'questionStrip':
        return true;

      default:
        return false;
    }
  }

  var isQuestionSupported$1 = __AMD("extensions/adapt-devtools/js/is-question-supported", isQuestionSupported);

  var ItemsQuestionModel = undefined;

  var AutoAnswer = _.extend({
    mousedownHandlers: [],
    initialize: function () {
      this.listenTo(Adapt$1, {
        'componentView:postRender': this.componentRendered,
        'remove': this.onRemove
      });
    },
    componentRendered: function (view) {
      if (isQuestionSupported$1(view.model)) {
        if (view.buttonsView) {
          var handler = _.bind(this.onQuestionMouseDown, this, view);

          view.$el.on('mousedown', handler);
          this.mousedownHandlers.push({
            element: view.$el,
            handler: handler
          });
        } else if (Adapt$1.devtools.get('_debug')) {
          console.warn('adapt-devtools: could not find submit button on ' + view.model.get('_id'));
        }
      }
    },
    onQuestionMouseDown: function (view, e) {
      if (Adapt$1.devtools.get('_hintingEnabled')) Hinting$1.setHinting(view.$el, view.model, false);

      if (e.ctrlKey && !e.shiftKey || Adapt$1.devtools.get('_autoCorrectEnabled')) {
        this.answer(view);
      } else if (e.ctrlKey && e.shiftKey) {
        this.answer(view, true);
      }
    },
    isItemsQuestionModel: function (model) {
      if (ItemsQuestionModel) {
        return model instanceof ItemsQuestionModel;
      } else if (ItemsQuestionModel === null) {
        return false;
      }

      if (require.defined('core/js/models/' + 'itemsQuestionModel')) {
        ItemsQuestionModel = require('core/js/models/' + 'itemsQuestionModel');
        return model instanceof ItemsQuestionModel;
      } else {
        ItemsQuestionModel = null;
        return false;
      }
    },
    answer: function (view, incorrectly) {
      if (view.model.get('_isSubmitted')) return;

      if (Adapt$1.devtools.get('_debug')) {
        console.log('adapt-devtools: answer ' + view.model.get('_id') + (incorrectly === true ? ' incorrectly' : ''));
      }

      if (incorrectly === true) {
        switch (view.model.get('_component')) {
          case 'mcq':
            this.answerMultipleChoiceIncorrectly(view);
            break;

          case 'gmcq':
            this.answerMultipleChoiceIncorrectly(view, true);
            break;

          case 'matching':
            this.answerMatchingIncorrectly(view);
            break;

          case 'ppq':
            this.answerPpqIncorrectly(view);
            break;

          case 'slider':
            this.answerSliderIncorrectly(view);
            break;

          case 'textinput':
            this.answerTextInputIncorrectly(view);
            break;

          case 'questionStrip':
            this.answerQuestionStripIncorrectly(view);
            break;

          default:
            this.answerUnsupportedIncorrectly(view);
        }
      } else {
        switch (view.model.get('_component')) {
          case 'mcq':
            this.answerMultipleChoice(view);
            break;

          case 'gmcq':
            this.answerMultipleChoice(view, true);
            break;

          case 'matching':
            this.answerMatching(view);
            break;

          case 'ppq':
            this.answerPpq(view);
            break;

          case 'slider':
            this.answerSlider(view);
            break;

          case 'textinput':
            this.answerTextInput(view);
            break;

          case 'questionStrip':
            this.answerQuestionStrip(view);
            break;

          default:
            this.answerUnsupported(view);
        }
      }

      view.$('.js-btn-action').trigger('click');
    },
    answerMultipleChoice: function (view, isGraphical) {
      var items = this.isItemsQuestionModel(view.model) ? view.model.getChildren().toJSON() : view.model.get('_items');
      var noCorrectOptions = _.where(items, {
        '_shouldBeSelected': true
      }).length == 0;

      if (this.isItemsQuestionModel(view.model)) {
        if (noCorrectOptions) {
          view.model.getItem(_.random(items.length - 1)).set('_isActive', true);
        } else {
          view.model.getChildren().forEach(item => {
            if (item.get('_shouldBeSelected') && !item.get('_isActive') || !item.get('_shouldBeSelected') && item.get('_isActive')) {
              item.toggleActive();
            }
          });
        }

        return;
      }

      if (noCorrectOptions) {
        if (_.where(items, {
          '_isSelected': true
        }).length == 0) {
          view.$(isGraphical ? '.js-item-input' : '.js-item-input').eq(_.random(items.length - 1)).trigger('change');
        }
      } else {
        _.each(items, function (item, index) {
          if (item._shouldBeSelected && !item._isSelected || !item._shouldBeSelected && item._isSelected) {
            view.$(isGraphical ? '.js-item-input' : '.js-item-input').eq(index).trigger('change');
          }
        });
      }
    },
    answerMultipleChoiceIncorrectly: function (view, isGraphical) {
      var model = view.model;
      var items = this.isItemsQuestionModel(model) ? model.getChildren().toJSON() : model.get('_items');
      var itemCount = items.length;

      var selectionStates = _.times(itemCount, function () {
        return false;
      });

      var nShould = _.where(items, {
        _shouldBeSelected: true
      }).length;

      var nShouldNot = itemCount - nShould;
      var nSelect = model.get('_selectable');
      var nIncorrect = nShouldNot == 0 ? 0 : _.random(nShould == 1 ? 1 : 0, Math.min(nShouldNot, nSelect));
      var nCorrect = nIncorrect == 0 ? _.random(1, Math.min(nShould - 1, nSelect)) : _.random(0, Math.min(nShould, nSelect - nIncorrect));

      if (itemCount == 1 || nSelect == 0) {
        console.warn('adapt-devtools: not possible to answer ' + model.get('_id') + ' incorrectly');
        return;
      }

      for (var j = 0; j < nIncorrect; j++) {
        for (var k = _.random(itemCount), err = itemCount, found = false; !found && err >= 0; k++, err--) {
          var index = k % itemCount;

          if (selectionStates[index] === false) {
            if (!items[index]._shouldBeSelected) selectionStates[index] = found = true;
          }
        }
      }

      for (var j = 0; j < nCorrect; j++) {
        for (var k = _.random(itemCount), err = itemCount, found = false; !found && err >= 0; k++, err--) {
          var index = k % itemCount;

          if (selectionStates[index] === false) {
            if (items[index]._shouldBeSelected) selectionStates[index] = found = true;
          }
        }
      }

      if (this.isItemsQuestionModel(view.model)) {
        view.model.getChildren().forEach((item, index) => {
          if (selectionStates[index] && !item.get('_isActive') || !selectionStates[index] && item.get('_isActive')) {
            item.toggleActive();
          }
        });
        return;
      }

      _.each(items, function (item, index) {
        if (selectionStates[index] && !item._isSelected || !selectionStates[index] && item._isSelected) {
          view.$(isGraphical ? '.js-item-input' : '.js-item-input').eq(index).trigger('change');
        }
      });
    },
    answerMatching: function (view) {
      _.each(view.model.get('_items'), function (item, itemIndex) {
        var noCorrectOptions = _.where(item._options, {
          '_isCorrect': true
        }).length == 0;

        if (noCorrectOptions) {
          if (!view.dropdowns[itemIndex].getFirstSelectedItem()) {
            var i = _.random(item._options.length - 1);

            view.selectValue(itemIndex, i);
          }
        } else {
          _.each(item._options, function (option, optionIndex) {
            if (option._isCorrect) {
              view.selectValue(itemIndex, option._index);
            }
          });
        }
      });
    },
    answerMatchingIncorrectly: function (view) {
      var items = view.model.get('_items'),
          itemCount = items.length,
          nIncorrect = _.random(1, itemCount);

      var selectionStates = _.shuffle(_.times(itemCount, function (i) {
        return i < nIncorrect;
      }));

      _.each(items, function (item, itemIndex) {
        var $select = view.$('select').eq(itemIndex);
        var $options = $select.find('option');

        if (selectionStates[itemIndex]) {
          for (var count = item._options.length, i = _.random(count), err = count; err >= 0; i++, err--) if (!item._options[i % count]._isCorrect) {
            if (view.selectValue) {
              var option = item._options[i % count];
              view.selectValue(itemIndex, option._index);
            } else if (view.model.setOptionSelected) {
              var option = item._options[i % count];
              $select.val(option.text);
              $select.trigger('change');
              view.model.setOptionSelected(itemIndex, i % count, true);
            } else {
              $options.eq(i % count + 1).prop('selected', true);
            }

            return;
          }
        } else {
          _.each(item._options, function (option, optionIndex) {
            if (option._isCorrect) {
              if (view.selectValue) {
                view.selectValue(itemIndex, option._index);
              } else if (view.model.setOptionSelected) {
                $select.val(option.text);
                $select.trigger('change');
                view.model.setOptionSelected(itemIndex, optionIndex, true);
              } else {
                $options.eq(optionIndex + 1).prop('selected', true);
              }
            }
          });
        }
      });
    },
    answerSlider: function (view) {
      var correctAnswer = view.model.get('_correctAnswer');

      if (correctAnswer) {
        view.$('.js-slider-number[data-id="' + correctAnswer + '"]').trigger('click');
      } else {
        var bottom = view.model.get('_correctRange')._bottom;

        var top = view.model.get('_correctRange')._top;

        var d = top - bottom;
        view.$('.js-slider-number[data-id="' + (bottom + Math.floor(Math.random() * (d + 1))) + '"]').trigger('click');
      }
    },
    answerSliderIncorrectly: function (view) {
      var correctAnswer = view.model.get('_correctAnswer');
      var start = view.model.get('_scaleStart'),
          end = view.model.get('_scaleEnd');

      var incorrect = _.times(end - start + 1, function (i) {
        return start + i;
      });

      if (correctAnswer) {
        incorrect.splice(correctAnswer - start, 1);
      } else {
        var bottom = view.model.get('_correctRange')._bottom;

        var top = view.model.get('_correctRange')._top;

        incorrect.splice(bottom - start, top - bottom + 1);
      }

      view.$('.js-slider-number[data-id="' + _.shuffle(incorrect)[0] + '"]').trigger('click');
    },
    answerTextInput: function (view) {
      var answers = view.model.get('_answers');

      _.each(view.model.get('_items'), function (item, index) {
        if (answers) view.$('.js-textinput-textbox').eq(index).val(answers[index][0]).trigger('change');else view.$('.js-textinput-textbox').eq(index).val(item._answers[0]).trigger('change');
      });
    },
    answerTextInputIncorrectly: function (view) {
      var items = view.model.get('_items'),
          itemCount = items.length,
          nIncorrect = _.random(1, itemCount);

      var selectionStates = _.shuffle(_.times(itemCount, function (i) {
        return i < nIncorrect;
      }));

      var answers = view.model.get('_answers');

      _.each(items, function (item, index) {
        if (selectionStates[index]) {
          view.$('.js-textinput-textbox').eq(index).val('***4n 1nc0rr3ct 4nsw3r***').trigger('change');
        } else {
          if (answers) view.$('.js-textinput-textbox').eq(index).val(answers[index][0]).trigger('change');else view.$('.js-textinput-textbox').eq(index).val(item._answers[0]).trigger('change');
        }
      });
    },
    answerQuestionStrip: function (view) {
      _.each(view.model.get('_items'), function (item, itemIndex) {
        _.each(item._subItems, function (subItem, subItemIndex) {
          if (subItem._isCorrect) view.setStage(itemIndex, subItemIndex, true);
        });
      });
    },
    answerQuestionStripIncorrectly: function (view) {
      var items = view.model.get('_items'),
          itemCount = items.length,
          nIncorrect = _.random(1, itemCount);

      var selectionStates = _.shuffle(_.times(itemCount, function (i) {
        return i < nIncorrect;
      }));

      _.each(items, function (item, itemIndex) {
        if (selectionStates[itemIndex]) {
          for (var count = item._subItems.length, i = _.random(count), err = count; err >= 0; i++, err--) if (!item._subItems[i % count]._isCorrect) {
            view.setStage(itemIndex, i % count, true);
            return;
          }
        } else {
          _.each(item._subItems, function (subItem, subItemIndex) {
            if (subItem._isCorrect) view.setStage(itemIndex, subItemIndex, true);
          });
        }
      });
    },
    answerPpq: function (view) {
      var model = view.model,
          items = model.get('_items'),
          itemCount = items.length;
      var isDesktop = Adapt$1.device.screenSize != 'small';

      var items = _.pluck(model.get('_items'), isDesktop ? 'desktop' : 'mobile');

      var $pinboard = view.$('.ppq-pinboard');
      var boardw = $pinboard.width();
      var boardh = $pinboard.height();

      for (i = 0; i < itemCount; i++) {
        var zone = items[i];
        var pin = view.getNextUnusedPin();
        var x = zone.left + zone.width / 2;
        var y = zone.top + zone.height / 2;
        console.log('using correct position', x + ',' + y);
        pin.setPosition(x, y);
        pin.$el.css({
          'left': boardw * x / 100 - pin.$el.width() / 2,
          'top': boardh * y / 100 - pin.$el.height()
        });
      }
    },
    answerPpqIncorrectly: function (view) {
      var model = view.model,
          items = model.get('_items'),
          itemCount = items.length;
      var isDesktop = Adapt$1.device.screenSize != 'small';

      var items = _.pluck(model.get('_items'), isDesktop ? 'desktop' : 'mobile');

      var nSelect = _.random(model.get('_minSelection'), model.get('_maxSelection'));

      var nIncorrect = _.random(1, nSelect);

      var nCorrect = nSelect - nIncorrect;
      var $pinboard = view.$('.ppq-pinboard');
      var boardw = $pinboard.width();
      var boardh = $pinboard.height();
      console.log('nIncorrect=', nIncorrect, 'nCorrect=', nCorrect);

      var maxSize = function (zone) {
        return zone.left < 1 && zone.top < 1 && zone.width > 9999 && zone.height > 9999;
      };

      items = _.map(items, function (item) {
        return {
          'left': Math.round(item.left * 100),
          'top': Math.round(item.top * 100),
          'width': Math.round(item.width * 100),
          'height': Math.round(item.height * 100)
        };
      });

      if (_.some(items, maxSize) || nSelect == 0) {
        console.warn('adapt-devtools: not possible to answer ' + model.get('_id') + ' incorrectly');
        return;
      }

      view.resetPins();

      for (var i = 0; i < nIncorrect; i++) {
        var ok = false;
        var x, y;

        while (!ok) {
          x = _.random(1, 10000);
          ok = !_.some(items, function (zone) {
            return x >= zone.left && x < zone.left + zone.width && zone.top < 1 && zone.height > 9999;
          });
        }

        ok = false;

        while (!ok) {
          y = _.random(1, 10000);
          ok = !_.some(items, function (zone) {
            return x >= zone.left && x < zone.left + zone.width && y >= zone.top && y < zone.top + zone.height;
          });
        }

        x = x / 100;
        y = y / 100;
        console.log('using incorrect position', x + ',' + y);
        var pin = view.getNextUnusedPin();
        pin.setPosition(x, y);
        pin.$el.css({
          'left': boardw * x / 100 - pin.$el.width() / 2,
          'top': boardh * y / 100 - pin.$el.height()
        });
      }

      var correct = _.shuffle(_.times(itemCount, function (i) {
        return i;
      }));

      for (i = 0; i < nCorrect; i++) {
        var zone = items[correct[i]];
        var pin = view.getNextUnusedPin();
        var x = zone.left + zone.width / 2;
        var y = zone.top + zone.height / 2;
        x = x / 100;
        y = y / 100;
        console.log('using correct position', x + ',' + y);
        pin.setPosition(x, y);
        pin.$el.css({
          'left': boardw * x / 100 - pin.$el.width() / 2,
          'top': boardh * y / 100 - pin.$el.height()
        });
      }
    },
    answerUnsupported: function (view) {
      var model = view.model;
      model.set({
        "_isComplete": true,
        "_isInteractionComplete": true,
        "_isCorrect": true,
        "_isSubmitted": true,
        "_score": 1
      });
      model.set("_attemptsLeft", Math.max(0, model.get("_attempts") - 1));
    },
    answerUnsupportedIncorrectly: function (view) {
      var model = view.model;
      model.set({
        "_isComplete": true,
        "_isInteractionComplete": true,
        "_isCorrect": false,
        "_isSubmitted": true,
        "_score": 0
      });
      model.set("_attemptsLeft", Math.max(0, model.get("_attempts") - 1));
    },
    onRemove: function () {
      this.mousedownHandlers.forEach(tuple => {
        tuple.element.off('mousedown', tuple.handler);
      });
    }
  }, Backbone.Events);

  Adapt$1.on('app:dataReady devtools:enable', function () {
    if (!Adapt$1.devtools.get('_isEnabled')) return;
    AutoAnswer.initialize();
  });
  var AutoAnswer$1 = __AMD("extensions/adapt-devtools/js/auto-answer", AutoAnswer);

  var PassHalfFail = _.extend({
    syncIterations: 1,
    mouseTarget: null,
    initialize: function () {
      _.bindAll(this, 'onMouseDown', 'onMouseUp', 'onKeypress', 'onPassHalfFailComplete');

      this._questionViews = [];
      this._currentPageId = null;
      this.listenTo(Adapt$1, 'pageView:preRender', this.onPagePreRender);
      this.listenTo(Adapt$1, 'remove', this.onRemove);
      $(window).off("keypress", this.onKeypress);
      $(window).off('mousedown', this.onMouseDown);
      $(window).off('mouseup', this.onMouseUp);
      $(window).on("keypress", this.onKeypress);
      $(window).on('mousedown', this.onMouseDown);
      $(window).on('mouseup', this.onMouseUp);
    },
    _completeNonQuestions: function () {
      var currentModel = Adapt$1.findById(Adapt$1.location._currentId);

      var nonQuestions = _.filter(currentModel.findDescendantModels("components"), function (m) {
        return m.get('_isQuestionType') !== true;
      });

      _.each(nonQuestions, function (item) {
        item.set("_isComplete", true);
        item.set("_isInteractionComplete", true);
      });
    },
    pass: function (callback) {
      var i = 0,
          qs = this._questionViews,
          len = qs.length;

      function step() {
        for (var j = 0, count = Math.min(PassHalfFail.syncIterations, len - i); j < count; i++, j++) {
          AutoAnswer$1.answer(qs[i]);
          if (!qs[i].model.get('_isSubmitted')) qs[i].$('.js-btn-action').trigger('click');
        }

        i == len ? callback() : setTimeout(step);
      }

      step();
    },
    half: function (callback) {
      var notSubmitted = function (view) {
        return !view.model.get('_isSubmitted');
      };

      var qs = _.shuffle(_.filter(this._questionViews, notSubmitted));

      var i = 0,
          len = qs.length;

      function step() {
        for (var j = 0, count = Math.min(PassHalfFail.syncIterations, len - i); j < count; i++, j++) {
          AutoAnswer$1.answer(qs[i], i % 2 == 0);
          if (!qs[i].model.get('_isSubmitted')) qs[i].$('.js-btn-action').trigger('click');
        }

        i == len ? callback() : setTimeout(step);
      }

      step();
    },
    fail: function (callback) {
      var i = 0,
          qs = this._questionViews,
          len = qs.length;

      function step() {
        for (var j = 0, count = Math.min(PassHalfFail.syncIterations, len - i); j < count; i++, j++) {
          AutoAnswer$1.answer(qs[i], true);
          if (!qs[i].model.get('_isSubmitted')) qs[i].$('.js-btn-action').trigger('click');
        }

        i == len ? callback() : setTimeout(step);
      }

      step();
    },
    onPagePreRender: function (view) {
      this._currentPageId = view.model.get('_id');
      this.listenTo(Adapt$1, 'componentView:postRender', this.onComponentRendered);
    },
    onRemove: function () {
      this.stopListening(Adapt$1, 'componentView:postRender', this.onComponentRendered);
      this._questionViews = [];
    },
    onComponentRendered: function (view) {
      if (view.model.has('_parentId') && view.model.findAncestor('contentObjects').get('_id') == this._currentPageId) {
        if (view.model.get('_isQuestionType')) {
          this._questionViews.push(view);
        }
      }
    },
    onMouseDown: function (e) {
      if (e.which === 1) this.mouseTarget = e.target;
    },
    onMouseUp: function (e) {
      if (e.which === 1) this.mouseTarget = null;
    },
    onKeypress: function (e) {
      var char = String.fromCharCode(e.which).toLowerCase();

      var perform = function (type) {
        if (Adapt$1.devtools.get('_trickleEnabled')) Adapt$1.trigger("trickle:kill");
        var tutorEnabled = Adapt$1.devtools.get('_feedbackEnabled');
        if (tutorEnabled) Adapt$1.devtools.set('_feedbackEnabled', false);
        if (type == 'pass') this.pass(_.partial(this.onPassHalfFailComplete, tutorEnabled));else if (type == 'half') this.half(_.partial(this.onPassHalfFailComplete, tutorEnabled));else this.fail(_.partial(this.onPassHalfFailComplete, tutorEnabled));
        Adapt$1.trigger('drawer:closeDrawer');
      }.bind(this);

      if (this.mouseTarget && $('.drawer .devtools').length === 0) {
        switch (char) {
          case 'p':
            return perform('pass');

          case 'h':
            return perform('half');

          case 'f':
            return perform('fail');
        }
      } else {
        switch (char) {
          case 'p':
            return perform('pass');

          case 'h':
            return perform('half');

          case 'f':
            return perform('fail');
        }
      }
    },
    onPassHalfFailComplete: function (tutorEnabled) {
      console.log('onPassHalfFailComplete');
      if (tutorEnabled) Adapt$1.devtools.set('_feedbackEnabled', true);
    }
  }, Backbone.Events);

  Adapt$1.on('app:dataReady devtools:enable', function () {
    if (!Adapt$1.devtools.get('_isEnabled')) return;
    PassHalfFail.initialize();
  });
  var PassHalfFail$1 = __AMD("extensions/adapt-devtools/js/pass-half-fail", PassHalfFail);

  var ToggleBanking = {
    initialize: function () {
      Adapt$1.articles.each(function (m) {
        var config = this.getConfig(m);

        if (m.has('_assessment') && m.get('_assessment')._banks && !m.get('_assessment')._banks._isEnabled) {
          config._assessmentBankDisabled = true;
        }
      }, this);
    },
    getConfig: function (articleModel) {
      if (!articleModel.has('_devtools')) articleModel.set('_devtools', {});
      return articleModel.get('_devtools');
    },
    getBankedAssessmentsInCurrentPage: function () {
      var pageModel = Adapt$1.findById(Adapt$1.location._currentId);

      var f = function (m) {
        var config = this.getConfig(m);
        if (!config._assessmentBankDisabled && m.has('_assessment') && m.get('_assessment')._isEnabled && m.get('_assessment')._banks._split.length > 1) return true;
        return false;
      };

      return Adapt$1.location._contentType === 'menu' ? [] : _.filter(pageModel.findDescendantModels('articles'), f, this);
    },
    toggle: function () {
      var bankedAssessments = this.getBankedAssessmentsInCurrentPage();

      var isBankingEnabled = function (m) {
        return m.get('_assessment')._banks._isEnabled;
      };

      var enable = !_.some(bankedAssessments, isBankingEnabled);

      _.each(bankedAssessments, function (articleModel) {
        articleModel.get('_assessment')._banks._isEnabled = enable;
        articleModel.set({
          _attemptInProgress: false,
          _isPass: false
        });
      });

      router$1.handleId(Adapt$1.location._currentId);
    }
  };
  Adapt$1.once('adapt:initialize devtools:enable', function () {
    if (!Adapt$1.devtools.get('_isEnabled')) return;
    ToggleBanking.initialize();
  });
  var ToggleBanking$1 = __AMD("extensions/adapt-devtools/js/toggle-banking", ToggleBanking);

  var MapView = Backbone.View.extend({
    events: {
      'click a': 'onLinkClicked'
    },
    initialize: function () {
      this.$('html').addClass('has-devtools-map');
      this._renderIntervalId = setInterval(this._checkRenderInterval.bind(this), 500);
      this.listenTo(Adapt$1.components, 'change:_isComplete', this.onModelCompletionChanged);
      this.listenTo(Adapt$1.blocks, 'change:_isComplete', this.onModelCompletionChanged);
      this.listenTo(Adapt$1.articles, 'change:_isComplete', this.onModelCompletionChanged);
      this.listenTo(Adapt$1.contentObjects, 'change:_isComplete', this.onModelCompletionChanged);
      this.render();
    },
    render: function () {
      var data = this.model;
      var template = Handlebars.templates.devtoolsMap;
      this.$('body').html(template(data));
    },
    remove: function () {
      clearInterval(this._renderIntervalId);
      this.$('body').html('Course closed!');
      this.stopListening();
      return this;
    },
    _checkRenderInterval: function () {
      if (this._invalid) {
        this._invalid = false;
        this.render();
      }
    },
    _getConfig: function (pageModel) {
      if (!pageModel.has('_devtools')) pageModel.set('_devtools', {});
      return pageModel.get('_devtools');
    },
    _disablePageIncompletePrompt: function (pageModel) {
      var config = this._getConfig(pageModel);

      if (pageModel.has('_pageIncompletePrompt')) {
        config._pageIncompletePromptExists = true;

        if (pageModel.get('_pageIncompletePrompt').hasOwnProperty('_isEnabled')) {
          config._pageIncompletePromptEnabled = pageModel.get('_pageIncompletePrompt')._isEnabled;
        }
      } else {
        config._pageIncompletePromptExists = false;
        pageModel.set('_pageIncompletePrompt', {});
      }

      pageModel.get('_pageIncompletePrompt')._isEnabled = false;
    },
    _restorePageIncompletePrompt: function (pageModel) {
      var config = this._getConfig(pageModel);

      if (config._pageIncompletePromptExists) {
        if (config.hasOwnProperty('_pageIncompletePromptEnabled')) pageModel.get('_pageIncompletePrompt')._isEnabled = config._pageIncompletePromptEnabled;else delete pageModel.get('_pageIncompletePrompt')._isEnabled;
      } else {
        pageModel.unset('_pageIncompletePrompt');
      }

      delete config._pageIncompletePromptExists;
      delete config._pageIncompletePromptEnabled;
    },
    onModelCompletionChanged: function () {
      this.invalidate();
    },
    onLinkClicked: function (e) {
      var $target = $(e.currentTarget);
      var id = $target.attr('href').slice(1);
      var model = Adapt$1.findById(id);
      e.preventDefault();

      if (e.ctrlKey && this.el.defaultView) {
        id = id.replace(/-/g, '');
        this.el.defaultView[id] = model;
        this.el.defaultView.console.log('devtools: add property window.' + id + ':');
        this.el.defaultView.console.log(model);
      } else if (e.shiftKey) {
        this.navigateAndDisableTrickle(id);
      } else {
        this.navigateAndDisableTrickleUpTo(id);
      }
    },
    invalidate: function () {
      this._invalid = true;
    },
    navigateAndDisableTrickleUpTo: function (id) {
      var model = Adapt$1.findById(id);
      var pageModel = Adapt$1.findById(Adapt$1.location._currentId);

      this._disablePageIncompletePrompt(pageModel);

      if (model._siblings === 'contentObjects') {
        Backbone.history.navigate('#/id/' + id, {
          trigger: true
        });
      } else {
        var level = model.get('_type') === 'component' ? model.getParent() : model;
        var siblings = level.getParent().getChildren();
        var sibling = null;

        for (var i = 0, count = siblings.indexOf(level); i < count; i++) {
          sibling = siblings.at(i);
          console.log('disabling trickle on ' + sibling.get('_id'));

          if (sibling.has('_trickle')) {
            sibling.get('_trickle')._isEnabled = false;
          } else {
            sibling.set('_trickle', {
              _isEnabled: false
            });
          }
        }

        if (Adapt$1.location._currentId === model.findAncestor('contentObjects').get('_id')) {
          this.listenToOnce(Adapt$1, 'pageView:ready', function (view) {
            _.defer(function () {
              Adapt$1.scrollTo($('.' + id));
              this.checkVisibility(id);
            }.bind(this));
          });
          if (Adapt$1.location._currentId === Adapt$1.course.get('_id')) router$1.handleRoute ? router$1.handleRoute() : router$1.handleCourse();else router$1.handleId(Adapt$1.location._currentId);
        } else {
          this.listenToOnce(Adapt$1, 'pageView:ready', function () {
            _.defer(function () {
              this.checkVisibility(id);
            }.bind(this));
          });
          Backbone.history.navigate('#/id/' + id, {
            trigger: true
          });
        }
      }

      this._restorePageIncompletePrompt(pageModel);

      this.invalidate();
    },
    navigateAndDisableTrickle: function (id) {
      var model = Adapt$1.findById(id);
      var pageModel = Adapt$1.findById(Adapt$1.location._currentId);

      this._disablePageIncompletePrompt(pageModel);

      if (model._siblings === 'contentObjects') {
        Backbone.history.navigate('#/id/' + id, {
          trigger: true
        });
      } else {
        if (Adapt$1.location._currentId === model.findAncestor('contentObjects').get('_id')) {
          Adapt$1.devtools.set('_trickleEnabled', false);
          Adapt$1.scrollTo($('.' + id));
          this.checkVisibility(id);
        } else {
          var targetModel = Adapt$1.trickle ? model.findAncestor('contentObjects') : Adapt$1.course;

          if (!targetModel.has('_trickle')) {
            targetModel.set('_trickle', {
              _isEnabled: false
            });
            this.listenToOnce(Adapt$1, 'pageView:ready', function () {
              _.defer(function () {
                targetModel.get('_trickle')._isEnabled = true;
                this.checkVisibility(id);
              }.bind(this));
            });
          } else if (targetModel.get('_trickle')._isEnabled) {
            targetModel.get('_trickle')._isEnabled = false;
            this.listenToOnce(Adapt$1, 'pageView:ready', function () {
              _.defer(function () {
                targetModel.get('_trickle')._isEnabled = true;
                this.checkVisibility(id);
              }.bind(this));
            });
          }

          Backbone.history.navigate('#/id/' + id, {
            trigger: true
          });
        }
      }

      this._restorePageIncompletePrompt(pageModel);

      this.invalidate();
    },
    checkVisibility: function (id) {
      var model = Adapt$1.findById(id);
      if ($('.' + id).is(':visible') || model === Adapt$1.course) return;

      while (!$('.' + id).is(':visible') && model !== Adapt$1.course) {
        model = model.getParent();
        id = model.get('_id');
      }

      console.log('adapt-devtools::checkVisibility scrolling to ancestor ' + id);
      Adapt$1.scrollTo($('.' + id));
    }
  });

  var CourseMap = _.extend({
    initialize: function () {
      this.listenTo(Adapt$1, 'devtools:mapLoaded', this.onMapLoaded);
      $(window).on('unload', this.onCourseClosed.bind(this));

      function isMenu(options) {
        if (this.get('_type') !== 'page') {
          return options.fn(this);
        }

        return options.inverse(this);
      }

      function eachChild(options) {
        var ret = '';
        var children = this.getChildren().models;

        for (var i = 0, j = children.length; i < j; i++) {
          ret = ret + options.fn(children[i], {
            data: {
              index: i,
              first: i === 0,
              last: i === j - 1
            }
          });
        }

        return ret;
      }

      function getId(options) {
        const val = this.get('_id') || '';
        return val.slice(-6);
      }

      function getProp(prop, options) {
        return this.get(prop);
      }

      function isStringEmpty(str) {
        return !str || str.trim && str.trim().length === 0 || $.trim(str).length === 0;
      }

      function getTitle(options) {
        var t = this.get('displayTitle');
        if (isStringEmpty(t)) t = this.get('title');
        if (isStringEmpty(t)) t = this.get('_id');
        return t;
      }

      function when(prop, options) {
        if (this.get(prop)) {
          return options.fn(this);
        } else {
          return options.inverse(this);
        }
      }

      function isTrickled(options) {
        var trickleConfig = this.get('_trickle');
        var trickled = false;
        var isBlock = this.get('_type') === 'block';
        if (trickleConfig) trickled = (isBlock || trickleConfig._onChildren !== true) && trickleConfig._isEnabled;else if (isBlock) {
          trickleConfig = this.getParent().get('_trickle');
          if (trickleConfig) trickled = trickleConfig._onChildren && trickleConfig._isEnabled;
        }

        if (trickled) {
          return options.fn(this);
        } else {
          return options.inverse(this);
        }
      }

      Handlebars.registerHelper('isMenu', isMenu);
      Handlebars.registerHelper('eachChild', eachChild);
      Handlebars.registerHelper('getId', getId);
      Handlebars.registerHelper('getProp', getProp);
      Handlebars.registerHelper('getTitle', getTitle);
      Handlebars.registerHelper('when', when);
      Handlebars.registerHelper('isTrickled', isTrickled);
    },
    open: function () {
      if (!this.mapWindow) {
        this.mapWindow = window.open('assets/map.html', 'Map');
      } else {
        this.mapWindow.focus();
      }
    },
    onMapClosed: function () {
      console.log('onMapClosed');
      this.mapWindow = null;
    },
    onMapLoaded: function (mapWindow) {
      console.log('onMapLoaded');
      this.mapWindow = mapWindow;
      this.mapWindow.focus();
      $('html', this.mapWindow.document).addClass($('html', window.document).attr('class'));
      this.mapView = new MapView({
        model: Adapt$1,
        el: this.mapWindow.document
      });
      $(this.mapWindow).on('unload', this.onMapClosed.bind(this));
    },
    onCourseClosed: function () {
      if (this.mapView) {
        this.mapView.remove();
      }
    }
  }, Backbone.Events);

  Adapt$1.once('adapt:initialize devtools:enable', function () {
    if (!Adapt$1.devtools.get('_isEnabled')) return;
    CourseMap.initialize();
  });
  var CourseMap$1 = __AMD("extensions/adapt-devtools/js/map", CourseMap);

  var mouseTarget$1 = null;

  function onMouseDown$2(e) {
    if (e.which == 1) mouseTarget$1 = e.target;
  }

  function onMouseUp$2(e) {
    if (e.which == 1) mouseTarget$1 = null;
  }

  function onKeypress$2(e) {
    var char = String.fromCharCode(e.which).toLowerCase();

    if (mouseTarget$1) {
      if (char == 'm') {
        var model = Utils.getModelForElement(mouseTarget$1);

        if (model) {
          var id = model.get('_id').replace(/-/g, '');
          window[id] = model;
          console.log('devtools: add property window.' + id + ':');
          console.log(model.attributes);
        }
      }
    }
  }

  function getAdaptCoreVersion() {
    try {
      if (Adapt$1.build && Adapt$1.build.has('package')) return Adapt$1.build.get('package').version || ">=v3.0.0";
      if (typeof AdaptModel.prototype.checkCompletionStatusFor == 'function') return ">=v2.2.3";
      if (typeof AdaptModel.prototype.setCompletionStatus == 'function') return ">=v2.0.10";
      if (typeof AdaptModel.prototype.checkLocking == 'function') return "v2.0.9";
      if (typeof Adapt$1.checkingCompletion == 'function') return "v2.0.8";
      if (typeof AdaptModel.prototype.getParents == 'function') return "v2.0.7";
      if ($.a11y && $.a11y.options.hasOwnProperty('isIOSFixesEnabled')) return "v2.0.5-v2.0.6";
      if (Adapt$1 instanceof Backbone.Model) return "v2.0.4";
      if (typeof QuestionView$1.prototype.recordInteraction == 'function') return "v2.0.2-v2.0.3";
      if (typeof Adapt$1.findById == 'function') return "v2.0.0-v2.0.1";
      return "v1.x";
    } catch (e) {
      return 'unknown version';
    }
  }

  var Utils = {
    getModelForElement: function (element) {
      var $target = $(element);
      if ($target.length == 0) return false;
      var id = $target.parents('[data-adapt-id]').data('adapt-id');
      return !id ? false : Adapt$1.findById(id);
    }
  };
  Adapt$1.once('adapt:initialize', function () {
    var str = 'Version of Adapt core detected: ' + getAdaptCoreVersion();
    var horz = getHorzLine();
    console.log(horz + '\nVersion of Adapt core detected: ' + getAdaptCoreVersion() + '\n' + horz);

    function getHorzLine() {
      for (var s = '', i = 0, c = str.length; i < c; i++) s += '*';

      return s;
    }
  });
  Adapt$1.once('adapt:initialize devtools:enable', function () {
    if (!Adapt$1.devtools.get('_isEnabled')) return;
    $(window).on("keypress", onKeypress$2);
    $(window).on("mousedown", onMouseDown$2);
    $(window).on("mouseup", onMouseUp$2);
    if (!window.Adapt) window.Adapt = Adapt$1;
  });
  var Utils$1 = __AMD("extensions/adapt-devtools/js/utils", Utils);

  function onTrickleBegun() {
    if (!Adapt$1.devtools.get('_trickleEnabled')) {
      console.log('Trickle started');
      Adapt$1.devtools.set('_trickleEnabled', true);
      Adapt$1.devtools.once('change:_trickleEnabled', onTrickleChange);
    }
  }

  function onTrickleEnded() {
    console.log('Trickle ended');
    Adapt$1.devtools.off('change:_trickleEnabled', onTrickleChange);
    Adapt$1.devtools.set('_trickleEnabled', false);
  }

  function onTrickleChange() {
    if (!Adapt$1.devtools.get('_trickleEnabled')) {
      Adapt$1.trigger('trickle:kill');
    }
  }

  function remove() {
    if (Adapt$1.devtools.get('_trickleEnabled')) {
      onTrickleEnded();
    }
  }

  Adapt$1.once('adapt:initialize devtools:enable', function () {
    if (!Adapt$1.devtools.get('_isEnabled')) return;
    Adapt$1.on('trickle:interactionInitialize trickle:started', onTrickleBegun);
    Adapt$1.on('trickle:kill trickle:finished', onTrickleEnded);
    Adapt$1.on('remove', remove);
  });

  function onShowFeedback() {
    Adapt$1.trigger('tutor:closed');
  }

  function hushTutor() {
    Adapt$1.devtools.set('_tutorListener', Adapt$1._events['questionView:showFeedback'].pop());
    Adapt$1.on('questionView:showFeedback', onShowFeedback);
  }

  function reinstateTutor() {
    Adapt$1.off('questionView:showFeedback', onShowFeedback);

    if (!Adapt$1._events.hasOwnProperty('questionView:showFeedback')) {
      Adapt$1._events['questionView:showFeedback'] = [];
    }

    Adapt$1._events['questionView:showFeedback'].push(Adapt$1.devtools.get('_tutorListener'));
  }

  function onFeedbackToggled() {
    if (Adapt$1.devtools.get('_feedbackEnabled')) {
      reinstateTutor();
      $(document).off('mouseup', '.js-btn-feedback');
    } else {
      hushTutor();
      $(document).on('mouseup', '.js-btn-feedback', onFeedbackButtonClicked);
    }
  }

  function onFeedbackButtonClicked(e) {
    var classes = $(e.currentTarget).parents('.component').attr('class');
    var componentId = /[\s]+(c\-[^\s]+)/.exec(classes)[1];

    if (componentId) {
      reinstateTutor();
      Adapt$1.trigger('questionView:showFeedback', {
        model: Adapt$1.findById(componentId)
      });
      hushTutor();
    } else console.error('devtools:onFeedbackButtonClicked: malformed component class name');
  }

  Adapt$1.once('adapt:initialize devtools:enable', function () {
    if (!Adapt$1.devtools.get('_isEnabled')) return;

    if (Adapt$1.devtools.get('_toggleFeedbackAvailable')) {
      if (Adapt$1._events.hasOwnProperty('questionView:showFeedback') && Adapt$1._events['questionView:showFeedback'].length == 1) {
        Adapt$1.devtools.on('change:_feedbackEnabled', onFeedbackToggled);
      } else {
        console.warn('devtools: no tutor or multiple registrants of questionView:showFeedback so disabling ability to toggle feedback.');
        Adapt$1.devtools.set('_toggleFeedbackAvailable', false);
      }
    }
  });

  var AltText = _.extend({
    initialize: function () {
      this.listenTo(Adapt$1.devtools, 'change:_altTextEnabled', this.toggleAltText);

      if (typeof MutationObserver == 'function') {
        this.observer = new MutationObserver(_.bind(this.onDomMutation, this));
      }
    },
    addTimer: function (fireNow) {
      this.timerId = setInterval(_.bind(this.onTimer, this), 1000);
      if (fireNow) this.onTimer();
    },
    removeTimer: function () {
      clearInterval(this.timerId);
    },
    connectObserver: function () {
      if (this.observer) this.observer.observe(document.getElementById('wrapper'), {
        childList: true,
        subtree: true,
        attributes: true,
        attributeFilter: ['class', 'style']
      });
    },
    disconnectObserver: function () {
      if (this.observer) this.observer.disconnect();
    },
    toggleAltText: function () {
      if (Adapt$1.devtools.get('_altTextEnabled')) {
        this.addTimer(true);
        this.connectObserver();
      } else {
        this.removeTimer();
        this.removeAllAnnotations();
        this.disconnectObserver();
      }
    },
    addAnnotation: function ($img, $annotation) {
      var template = Handlebars.templates['devtoolsAnnotation'];
      var text = $img.attr('alt');
      if (!text) text = $img.attr('aria-label');
      var $annotation = $(template({
        text: text
      }));
      if (!text) $annotation.addClass('has-annotation-warning');
      $img.after($annotation);
      $img.data('annotation', $annotation);
      this.updateAnnotation($img, $annotation);
    },
    removeAnnotation: function ($img, $annotation) {
      $annotation.remove();
      $img.removeData('annotation');
    },
    removeAllAnnotations: function () {
      $('img').each(_.bind(function (index, element) {
        var $img = $(element);
        var $annotation = $img.data('annotation');
        if ($annotation) this.removeAnnotation($img, $annotation);
      }, this));
    },
    updateAnnotation: function ($img, $annotation) {
      var position = $img.position();
      position.left += parseInt($img.css('marginLeft'), 10) + parseInt($img.css('paddingLeft'), 10);
      position.top += parseInt($img.css('marginTop'), 10) + parseInt($img.css('paddingTop'), 10);
      $annotation.css(position);
    },
    onDomMutation: function (mutations) {
      this.mutated = true;
    },
    onTimer: function () {
      if (this.mutated === false) return;
      if (this.observer) this.mutated = false;
      this.disconnectObserver();
      $('img').each(_.bind(function (index, element) {
        var $img = $(element);
        var $annotation = $img.data('annotation');
        var isVisible = $img.is(':visible');

        if (isVisible) {
          if (!$annotation) this.addAnnotation($img, $annotation);else this.updateAnnotation($img, $annotation);
        } else if ($annotation) {
          this.removeAnnotation($img, $annotation);
        }
      }, this));
      this.connectObserver();
    }
  }, Backbone.Events);

  Adapt$1.once('adapt:initialize devtools:enable', function () {
    if (!Adapt$1.devtools.get('_isEnabled')) return;
    AltText.initialize();
  });
  __AMD("extensions/adapt-devtools/js/toggle-alt-text", AltText);

  function breakCoreLocking() {
    Adapt$1.course.unset('_lockType');
    breakLocks(Adapt$1.contentObjects);
    breakLocks(Adapt$1.articles);
    breakLocks(Adapt$1.blocks);

    function breakLocks(collection) {
      collection.each(function (model) {
        model.unset('_lockType');
        model.unset('_isLocked');
      });
    }
  }

  function onUnlocked() {
    if (Adapt$1.devtools.get('_unlocked')) {
      breakCoreLocking();
      if (Adapt$1.location._currentId == Adapt$1.course.get('_id')) router$1.handleRoute ? router$1.handleRoute() : router$1.handleCourse();else router$1.handleId(Adapt$1.location._currentId);
    }
  }

  function onMenuPreRender(view) {
    if (Adapt$1.devtools.get('_unlocked')) {
      if (Adapt$1.location._currentId == view.model.get('_id')) {
        view.model.once('change:_isReady', _.bind(onMenuReady, view));
        view.model.getChildren().each(function (item) {
          if (item.has('_lock')) item.set('_lock', item.get('_lock').length > -1 ? [] : false);
          if (item._lock) item._lock = item._lock.length > -1 ? [] : false;
          if (item._locked === true) item._locked = false;
          if (item._isLocked === true) item._isLocked = false;
        });
      }
    }
  }

  function onMenuReady() {
    if (Adapt$1.devtools.get('_unlocked')) {
      this.$('a, button').prop('disabled', false).css('pointer-events', 'auto');
    }
  }

  Adapt$1.once('adapt:initialize devtools:enable', function () {
    if (!Adapt$1.devtools.get('_isEnabled')) return;

    if (Adapt$1.devtools.get('_unlockAvailable')) {
      Adapt$1.devtools.on('change:_unlocked', onUnlocked);
      Adapt$1.on('menuView:preRender', onMenuPreRender);
    }
  });

  var buffer = '';
  var isMouseDown = false;
  var hitArea = 100;
  var coords = {};
  var topLeftTapHold = false;
  var topRightTapHold = false;
  var listenType = 0;
  var timeoutId;
  var focusableElements = "a,button,input,select,textarea,[tabindex],label";

  function onKeypress$1(e) {
    var c = String.fromCharCode(e.which).toLowerCase();
    buffer += c;
    if (isMouseDown && c == '5' && !Adapt$1.devtools.get('_isEnabled')) enable();else processBuffer();
  }

  function onMouseDown$1() {
    isMouseDown = true;
  }

  function onMouseUp$1() {
    isMouseDown = false;
  }

  function processBuffer() {
    var blen = buffer.length;
    if (blen > 100) buffer = buffer.substr(1, 100);
    blen = buffer.length;

    if (buffer.substr(blen - "kcheat".length, "kcheat".length) == "kcheat") {
      if (!Adapt$1.devtools.get('_isEnabled')) enable();
    }
  }

  function enable() {
    removeHooks();
    Adapt$1.devtools.set('_isEnabled', true);
    Adapt$1.trigger('devtools:enable');
    if (Adapt$1.location._currentId == Adapt$1.course.get('_id')) router$1.handleRoute ? router$1.handleRoute() : router$1.handleCourse();else router$1.handleId(Adapt$1.location._currentId);
  }

  function addHooks() {
    $(window).on("keypress", onKeypress$1);
    $(window).on("mousedown", onMouseDown$1);
    $(window).on("mouseup", onMouseUp$1);

    window.kcheat = function () {
      buffer = "kcheat";
      processBuffer();
    };

    router$1.route('kcheat', 'kcheat', function () {
      if (window.kcheat) window.kcheat();
    });
    if (Modernizr.touch) addTouchHook();
  }

  function removeHooks() {
    $(window).off("keypress", onKeypress$1);
    $(window).off("mousedown", onMouseDown$1);
    $(window).off("mouseup", onMouseUp$1);
    window.kcheat = undefined;
    if (Modernizr.touch) removeTouchHook();
  }

  function addTouchHook() {
    $('body').on('touchstart', onTouchStart);
    $('body').on('touchend', onTouchEnd);
    $('body').on('touchstart', focusableElements, onTouchStart);
  }

  function removeTouchHook() {
    clearTimeout(timeoutId);
    $('body').off('touchstart', onTouchStart);
    $('body').off('touchend', onTouchEnd);
    $('body').off('touchstart', focusableElements, onTouchStart);
  }

  function onTouchStart(event) {
    var touches = event.originalEvent.touches;
    if (touches.length != 1) return;
    coords.x = touches[0].pageX;
    coords.y = touches[0].pageY;

    if (coords.x >= 0 && coords.x < hitArea && coords.y >= 0 && coords.y < hitArea) {
      listenType = 1;
    } else if (coords.x >= $(window).width() - hitArea && coords.x < $(window).width() && coords.y >= 0 && coords.y < hitArea) {
      listenType = 2;
    } else {
      listenType = topLeftTapHold = topRightTapHold = false;
    }

    if (listenType) {
      timeoutId = setTimeout(function () {
        if (listenType) {
          if (listenType == 1) topLeftTapHold = true;else if (listenType == 2) topRightTapHold = true;

          if (topLeftTapHold && topRightTapHold) {
            if (window.kcheat) window.kcheat();
          }
        }
      }, 200);
    }
  }

  function onTouchEnd(event) {
    listenType = false;
    clearTimeout(timeoutId);
  }

  Adapt$1.once('adapt:initialize', function () {
    if (Adapt$1.devtools.get('_isEnabled')) return;

    _.defer(function () {
      addHooks();
    });
  });

  var TraceFocus = _.extend({
    openingTags: new RegExp("<[\\w-]+((\\s+[\\w-]+(\\s*=\\s*(?:\".*?\"|'.*?'|[^'\">\\s]+))*)+\\s*|\\s*)/?>"),
    consoleStyle: 'background: lightgray; color: blue',
    initialize: function () {
      this.onFocusIn = _.bind(this.onFocusIn, this);
      this.listenTo(Adapt$1.devtools, 'change:_traceFocusEnabled', this.toggleTraceFocus);
      this.toggleTraceFocus();
    },
    toggleTraceFocus: function () {
      if (Adapt$1.devtools.get('_traceFocusEnabled')) {
        $('body').on('focusin', this.onFocusIn);
      } else {
        $('body').off('focusin', this.onFocusIn);
      }
    },
    onFocusIn: function (e) {
      if (!$('html').is('.ie, .Edge')) return console.log('%cfocussed', this.consoleStyle, e.target);
      var $el = $(e.target);
      if (!$el[0] || !$el[0].outerHTML) return console.log('focussed: ', e.target);
      var openingTag = this.openingTags.exec($el[0].outerHTML)[0];

      if (openingTag) {
        var tokens = $el.text().replace(/[\s\xA0]*/, '').split(/\r\n|\r|\n/);
        if (tokens[0]) openingTag = openingTag.slice(0, 20) + '[...]';

        if ($('html').is('.ie8')) {
          console.log('focussed: ', openingTag, tokens[0]);
        } else {
          console.log('focussed: ', openingTag, tokens[0], $el);
        }
      } else {
        console.log('focussed: ' + e.target);
      }
    }
  }, Backbone.Events);

  Adapt$1.once('adapt:initialize devtools:enable', function () {
    if (!Adapt$1.devtools.get('_isEnabled')) return;
    TraceFocus.initialize();
  });
  __AMD("extensions/adapt-devtools/js/toggle-trace-focus", TraceFocus);

  var mouseTarget = null;

  function init() {
    $(window).on('keypress', onKeypress);
    $(window).on('mousedown', onMouseDown);
    $(window).on('mouseup', onMouseUp);
  }

  function onKeypress(e) {
    var char = String.fromCharCode(e.which).toLowerCase();

    if (mouseTarget) {
      switch (char) {
        case 'c':
          return complete(mouseTarget);

        case 'r':
          return reset(mouseTarget);
      }
    }
  }

  function complete(element) {
    var model = Utils$1.getModelForElement(element);
    if (!model) return;

    function doCompletion(component) {
      component.set('_isComplete', true);
    }

    var descendantComponents = model.findDescendantModels('components');

    if (!descendantComponents || descendantComponents.length === 0) {
      console.log('devtools: completing', model.get('_id'));
      doCompletion(model);
      return;
    }

    console.log('devtools: completing all components in', model.get('_id'));

    _.each(descendantComponents, function (model) {
      doCompletion(model);
    });
  }

  function reset(element) {
    var model = Utils$1.getModelForElement(element);
    if (!model) return;
    var descendantComponents = model.findDescendantModels('components');

    if (!descendantComponents || descendantComponents.length === 0) {
      console.log('devtools: resetting', model.get('_id'));
      model.reset(true, true);
      return;
    }

    console.log('devtools: resetting all components in', model.get('_id'));

    _.each(descendantComponents, function (model) {
      model.reset(true, true);
    });
  }

  function onMouseDown(e) {
    if (e.which === 1) mouseTarget = e.target;
  }

  function onMouseUp(e) {
    if (e.which === 1) mouseTarget = null;
  }

  Adapt$1.once('adapt:initialize devtools:enable', function () {
    if (!Adapt$1.devtools.get('_isEnabled')) return;
    init();
  });

  var navigationView;
  var DevtoolsView = Backbone.View.extend({
    className: 'devtools',
    events: {
      'click .end-trickle': 'onEndTrickle',
      'change .hinting input': 'onToggleHinting',
      'change .banking input': 'onToggleBanking',
      'change .feedback input': 'onToggleFeedback',
      'change .auto-correct input': 'onToggleAutoCorrect',
      'change .alt-text input': 'onToggleAltText',
      'click .unlock': 'onUnlock',
      'click .open-map': 'onOpenMap',
      'click .open-spoor-log': 'onOpenSpoorLog',
      'click .complete-page': 'onCompletePage',
      'click .complete-menu': 'onCompleteMenu',
      'click .pass': 'onPassHalfFail',
      'click .half': 'onPassHalfFail',
      'click .fail': 'onPassHalfFail',
      'change .trace-focus input': 'onToggleTraceFocus'
    },
    initialize: function () {
      this.render();

      this._checkUnlockVisibility();

      this._checkSpoorLogVisibility();

      this._checkTrickleEndVisibility();

      this._checkBankingVisibility();

      this._checkFeedbackVisibility();

      this._checkHintingVisibility();

      this._checkAutoCorrectVisibility();

      this._checkAltTextVisibility();

      this._checkPassHalfFailVisibility();

      this._checkCompletePageVisibility();

      this._checkCompleteMenuVisibility();

      this._checkTraceFocusVisibility();
    },
    render: function () {
      var data = Adapt$1.devtools.toJSON();
      var template = Handlebars.templates['devtools'];
      this.$el.html(template(data));
      return this;
    },
    _checkUnlockVisibility: function () {
      if (!Adapt$1.devtools.get('_unlockAvailable') || Adapt$1.devtools.get('_unlocked')) this.$('.unlock').addClass('u-display-none');else this.$('.unlock').toggleClass('u-display-none', !this._checkForLocks());
    },
    _checkForLocks: function () {
      if (typeof AdaptModel.prototype.checkLocking !== 'function') return Adapt$1.location._contentType === 'menu';

      var hasLock = function (model) {
        return model.has('_lockType');
      };

      if (hasLock(Adapt$1.course)) return true;
      if (Adapt$1.contentObjects.some(hasLock)) return true;
      if (Adapt$1.articles.some(hasLock)) return true;
      if (Adapt$1.blocks.some(hasLock)) return true;
      return false;
    },
    onUnlock: function () {
      Adapt$1.devtools.set('_unlocked', true);

      this._checkUnlockVisibility();
    },
    onOpenMap: function () {
      CourseMap$1.open();
      Adapt$1.trigger('drawer:closeDrawer');
    },
    _checkSpoorLogVisibility: function () {
      var spoorInstalled = require.defined('extensions/adapt-contrib-spoor/js/adapt-contrib-spoor');

      if (spoorInstalled) return;
      this.$('.open-spoor-log').addClass('is-disabled').attr('disabled', 'disabled');
    },
    onOpenSpoorLog: function () {
      Adapt$1.trigger('drawer:closeDrawer');

      if (Adapt$1.spoor) {
        Adapt$1.spoor.scorm.showDebugWindow();
        return;
      }

      require('extensions/adapt-contrib-spoor/js/scorm').showDebugWindow();
    },
    _checkTrickleEndVisibility: function () {
      this.$('.end-trickle').toggleClass('u-display-none', !Adapt$1.devtools.get('_trickleEnabled'));
    },
    onEndTrickle: function () {
      Adapt$1.devtools.set('_trickleEnabled', false);

      this._checkTrickleEndVisibility();
    },
    _checkBankingVisibility: function () {
      if (!Adapt$1.devtools.get('_toggleFeedbackAvailable')) {
        this.$('.banking').addClass('u-display-none');
        return;
      }

      var bankedAssessments = ToggleBanking$1.getBankedAssessmentsInCurrentPage();

      var isBankingEnabled = function (m) {
        return m.get('_assessment')._banks._isEnabled;
      };

      if (bankedAssessments.length > 0) {
        this.$('.banking').removeClass('u-display-none');
        this.$('.banking label').toggleClass('is-selected', _.some(bankedAssessments, isBankingEnabled));
        return;
      }

      this.$('.banking').addClass('u-display-none');
    },
    onToggleBanking: function () {
      ToggleBanking$1.toggle();

      this._checkBankingVisibility();
    },
    _checkFeedbackVisibility: function () {
      if (Adapt$1.devtools.get('_toggleFeedbackAvailable')) {
        this.$('.feedback').removeClass('u-display-none');
        this.$('.feedback label').toggleClass('is-selected', Adapt$1.devtools.get('_feedbackEnabled'));
        return;
      }

      this.$('.feedback').addClass('u-display-none');
    },
    onToggleFeedback: function () {
      Adapt$1.devtools.toggleFeedback();

      this._checkFeedbackVisibility();
    },
    _checkHintingVisibility: function () {
      if (Adapt$1.devtools.get('_hintingAvailable')) {
        this.$('.hinting').removeClass('u-display-none');
        this.$('.hinting label').toggleClass('is-selected', Adapt$1.devtools.get('_hintingEnabled'));
        return;
      }

      this.$('.hinting').addClass('u-display-none');
    },
    onToggleHinting: function () {
      Adapt$1.devtools.toggleHinting();

      this._checkHintingVisibility();
    },
    _checkAutoCorrectVisibility: function () {
      if (Adapt$1.devtools.get('_autoCorrectAvailable')) {
        this.$('.is-toggle.auto-correct').removeClass('u-display-none');
        this.$('.is-toggle.auto-correct label').toggleClass('is-selected', Adapt$1.devtools.get('_autoCorrectEnabled'));
        this.$('.is-tip.auto-correct').toggleClass('u-display-none', Adapt$1.devtools.get('_autoCorrectEnabled'));
        return;
      }

      this.$('.auto-correct').addClass('u-display-none');
    },
    onToggleAutoCorrect: function () {
      Adapt$1.devtools.toggleAutoCorrect();

      this._checkAutoCorrectVisibility();
    },
    _checkAltTextVisibility: function () {
      if (Adapt$1.devtools.get('_altTextAvailable')) {
        this.$('.is-toggle.alt-text').removeClass('u-display-none');
        this.$('.is-toggle.alt-text label').toggleClass('is-selected', Adapt$1.devtools.get('_altTextEnabled'));
        this.$('.is-tip.alt-text').toggleClass('u-display-none', Adapt$1.devtools.get('_altTextEnabled'));
        return;
      }

      this.$('.alt-text').addClass('u-display-none');
    },
    onToggleAltText: function () {
      Adapt$1.devtools.toggleAltText();

      this._checkAltTextVisibility();
    },
    _checkCompletePageVisibility: function () {
      var currentModel = Adapt$1.findById(Adapt$1.location._currentId);

      if (currentModel.get('_type') !== 'page') {
        this.$('.complete-page').addClass('u-display-none');
        return;
      }

      var incomplete = currentModel.findDescendantModels('components', {
        where: {
          _isInteractionComplete: false
        }
      });
      this.$('.complete-page').toggleClass('u-display-none', incomplete.length === 0);
    },
    onCompletePage: function (e) {
      var currentModel = Adapt$1.findById(Adapt$1.location._currentId);
      if (Adapt$1.devtools.get('_trickleEnabled')) Adapt$1.trigger('trickle:kill');
      var incomplete = currentModel.findDescendantModels('components', {
        where: {
          _isInteractionComplete: false
        }
      });
      incomplete.forEach(function (component) {
        if (component.get('_isQuestionType')) {
          component.set({
            _isCorrect: true,
            _isSubmitted: true,
            _score: 1
          });
          component.set('_attemptsLeft', Math.max(0, component.set('_attempts') - 1));
        }

        component.set('_isComplete', true);
        component.set(currentModel.has('_isInteractionsComplete') ? '_isInteractionsComplete' : '_isInteractionComplete', true);
      });
      Adapt$1.trigger('drawer:closeDrawer');
    },
    _checkCompleteMenuVisibility: function () {
      var currentModel = Adapt$1.findById(Adapt$1.location._currentId);

      if (currentModel.get('_type') !== 'menu' && currentModel.get('_type') !== 'course') {
        this.$('.complete-menu').addClass('u-display-none');
        return;
      }

      var incomplete = currentModel.findDescendantModels('components', {
        where: {
          _isComplete: false
        }
      });
      this.$('.complete-menu').toggleClass('u-display-none', incomplete.length === 0);
    },
    onCompleteMenu: function (e) {
      var currentModel = Adapt$1.findById(Adapt$1.location._currentId);
      if (Adapt$1.devtools.get('_trickleEnabled')) Adapt$1.trigger('trickle:kill');
      var incomplete = currentModel.findDescendantModels('components', {
        where: {
          _isComplete: false
        }
      });

      _.invoke(incomplete, 'set', '_isComplete', true);

      Adapt$1.trigger('drawer:closeDrawer');
    },
    _checkPassHalfFailVisibility: function () {
      var currentModel = Adapt$1.findById(Adapt$1.location._currentId);

      if (currentModel.get('_type') !== 'page') {
        this.$('.pass, .half, .fail').addClass('u-display-none');
        return;
      }

      var unanswered = currentModel.findDescendantModels('components', {
        where: {
          _isQuestionType: true,
          _isSubmitted: false
        }
      });
      if (unanswered.length === 0) this.$('.tip.pass-half-fail').html('');else this.$('.is-tip.pass-half-fail').html('With the ' + unanswered.length + ' unanswered question(s) in this page do the following:');
      this.$('.pass, .half, .fail').toggleClass('u-display-none', unanswered.length === 0);
    },
    onPassHalfFail: function (e) {
      if (Adapt$1.devtools.get('_trickleEnabled')) Adapt$1.trigger('trickle:kill');
      $('.js-loading').show();
      var tutorEnabled = Adapt$1.devtools.get('_feedbackEnabled');
      if (tutorEnabled) Adapt$1.devtools.set('_feedbackEnabled', false);
      if ($(e.currentTarget).hasClass('pass')) PassHalfFail$1.pass(this.onPassHalfFailComplete.bind(this, tutorEnabled));else if ($(e.currentTarget).hasClass('half')) PassHalfFail$1.half(this.onPassHalfFailComplete.bind(this, tutorEnabled));else PassHalfFail$1.fail(this.onPassHalfFailComplete.bind(this, tutorEnabled));
      Adapt$1.trigger('drawer:closeDrawer');
    },
    onPassHalfFailComplete: function (tutorEnabled) {
      console.log('onPassHalfFailComplete');
      if (tutorEnabled) Adapt$1.devtools.set('_feedbackEnabled', true);
      $('.js-loading').hide();
    },
    _checkTraceFocusVisibility: function () {
      if (Adapt$1.devtools.get('_traceFocusAvailable')) {
        this.$('.is-toggle.trace-focus').removeClass('u-display-none');
        this.$('.is-toggle.trace-focus label').toggleClass('is-selected', Adapt$1.devtools.get('_traceFocusEnabled'));
        return;
      }

      this.$('.trace-focus').addClass('u-display-none');
    },
    onToggleTraceFocus: function () {
      Adapt$1.devtools.toggleTraceFocus();

      this._checkTraceFocusVisibility();
    }
  });
  var DevtoolsNavigationView = Backbone.View.extend({
    initialize: function () {
      var template = Handlebars.templates.devtoolsNavigation;
      this.$el = $(template());
      $('html').addClass('devtools-enabled').toggleClass('devtools-extended', Adapt$1.devtools.get('_extended'));
      if (this.$el.is('a') || this.$el.is('button')) this.$el.on('click', this.onDevtoolsClicked.bind(this));else this.$el.find('a, button').on('click', this.onDevtoolsClicked.bind(this));
      this.listenTo(Adapt$1, 'pageView:postRender menuView:postRender', this.onContentRendered);
      this.listenToOnce(Adapt$1, 'pageView:postRender menuView:postRender', this.render);
    },
    render: function () {
      $('.nav__inner').append(this.$el);
      return this;
    },
    remove: function () {
      this.$el.remove();
      this.stopListening();
      return this;
    },
    deferredRender: function () {
      _.defer(this.render.bind(this));
    },
    onContentRendered: function (view) {
      if (view.model.get('_id') === Adapt$1.location._currentId) {
        this.stopListening(view.model, 'change:_isReady', this.deferredRender);
        this.listenToOnce(view.model, 'change:_isReady', this.deferredRender);
      }
    },
    onDevtoolsClicked: function (event) {
      if (event && event.preventDefault) event.preventDefault();
      Adapt$1.drawer.triggerCustomView(new DevtoolsView().$el, false);
    }
  });
  Adapt$1.once('courseModel:dataLoaded', function () {
    Adapt$1.devtools = new DevtoolsModel$1();
  });

  function initNavigationView() {
    if (!Adapt$1.devtools.get('_isEnabled')) return;
    if (navigationView) navigationView.remove();
    navigationView = new DevtoolsNavigationView();
  }

  Adapt$1.once('adapt:initialize devtools:enable', function () {
    initNavigationView();
    Adapt$1.on('app:languageChanged', initNavigationView);
  });

  class MenuItemView extends AdaptView$1 {
    attributes() {
      return AdaptView$1.resultExtend('attributes', {
        'role': 'listitem',
        'aria-labelledby': this.model.get('_id') + '-heading'
      }, this);
    }

    className() {
      return ['menu-item', this.constructor.className, this.model.get('_id'), this.model.get('_classes'), this.setVisibility(), this.setHidden(), this.model.get('_isVisited') ? 'is-visited' : '', this.model.get('_isComplete') ? 'is-complete' : '', this.model.get('_isLocked') ? 'is-locked' : '', this.model.get('_isOptional') ? 'is-optional' : ''].join(' ');
    }

    preRender() {
      this.model.checkCompletionStatus();
      this.model.checkInteractionCompletionStatus();
    }

    postRender() {
      this.$el.imageready(this.setReadyStatus.bind(this));
    }

  }

  MenuItemView.type = 'menuItem';
  var MenuItemView$1 = __AMD("core/js/views/menuItemView", MenuItemView);

  class MenuView extends ContentObjectView {}

  Object.assign(MenuView, {
    childContainer: '.js-children',
    childView: MenuItemView$1,
    type: 'menu',
    template: 'menu'
  });
  var MenuView$1 = __AMD("core/js/views/menuView", MenuView);

  class BoxMenuItemView extends MenuItemView$1 {
    className() {
      return `${super.className()} boxmenu-item`;
    }

    events() {
      return {
        'click .js-btn-click': 'onClickMenuItemButton'
      };
    }

    onClickMenuItemButton(event) {
      if (event && event.preventDefault) event.preventDefault();
      if (this.model.get('_isLocked')) return;
      router$1.navigateToElement(this.model.get('_id'));
    }

  }

  BoxMenuItemView.template = 'boxMenuItem';
  var BoxMenuItemView$1 = __AMD("menu/adapt-contrib-boxMenu/js/BoxMenuItemView", BoxMenuItemView);

  class BoxMenuGroupView extends MenuItemView$1 {
    className() {
      return `${super.className()} boxmenu-group`;
    }

    postRender() {
      _.defer(this.addChildren.bind(this));

      this.$el.imageready(this.setReadyStatus.bind(this));
      this.$el.parents('.boxmenu__item-container').addClass('has-groups');
    }

  }

  BoxMenuGroupView.template = 'boxMenuGroup';
  BoxMenuGroupView.childContainer = '.js-group-children';
  BoxMenuGroupView.childView = BoxMenuItemView$1;
  var BoxMenuGroupView$1 = __AMD("menu/adapt-contrib-boxMenu/js/BoxMenuGroupView", BoxMenuGroupView);

  class BoxMenuView extends MenuView$1 {
    className() {
      return `${super.className()} boxmenu`;
    }

    initialize() {
      super.initialize();
      this.setStyles();
      this.listenTo(Adapt$1, 'device:changed', this.onDeviceResize);
    }

    onDeviceResize() {
      this.setStyles();
    }

    addChildren() {
      let nthChild = 0;
      const models = this.model.getChildren().models;
      const childViews = [];
      models.forEach(model => {
        if (!model.get('_isAvailable')) return;

        if (model.get('_isHidden')) {
          model.set('_isReady', true);
          return;
        }

        nthChild++;
        model.set('_nthChild', nthChild);
        const ChildView = model.get('_type') === 'menu' && model.get('_boxMenu') && model.get('_boxMenu')._renderAsGroup ? BoxMenuGroupView$1 : BoxMenuItemView$1;
        const $parentContainer = this.$(this.constructor.childContainer);
        const childView = new ChildView({
          model
        });
        childViews.push(childView);
        $parentContainer.append(childView.$el);
      });
      this.setChildViews(childViews);
    }

    setStyles() {
      this.addBackgroundLayer();
      this.setBackgroundImage();
      this.setBackgroundStyles();
      this.processHeader();
    }

    addBackgroundLayer() {
      if (this.$el.find(' > .background').length) return;
      this.$background = $('<div class="background" aria-hidden="true"></div>').prependTo(this.$el);
    }

    setBackgroundImage() {
      const config = this.model.get('_boxMenu');
      const backgroundImages = config?._backgroundImage;
      if (!backgroundImages) return;
      const backgroundImage = backgroundImages[`_${Adapt$1.device.screenSize}`] ?? backgroundImages._small;
      this.$el.toggleClass('has-bg-image', Boolean(backgroundImage));
      this.$background.css('background-image', backgroundImage ? 'url(' + backgroundImage + ')' : '');
    }

    setBackgroundStyles() {
      const config = this.model.get('_boxMenu');
      const styles = config?._backgroundStyles;
      if (!styles) return;
      this.$background.css({
        'background-repeat': styles._backgroundRepeat,
        'background-size': styles._backgroundSize,
        'background-position': styles._backgroundPosition
      });
    }

    processHeader() {
      const config = this.model.get('_boxMenu');
      const header = config?._menuHeader;
      if (!header) return;
      const $header = this.$('.menu__header');
      this.addHeaderBackgroundLayer($header);
      this.setHeaderBackgroundImage(header, $header);
      this.setHeaderBackgroundStyles(header, $header);
      this.setHeaderMinimumHeight(header, $header);
    }

    addHeaderBackgroundLayer($header) {
      if ($header.find(' > .background').length) return;
      this.$headerBackground = $('<div class="background" aria-hidden="true"></div>').prependTo($header);
    }

    setHeaderBackgroundImage(config, $header) {
      const backgroundImages = config._backgroundImage;
      if (!backgroundImages) return;
      const backgroundImage = backgroundImages[`_${Adapt$1.device.screenSize}`] ?? backgroundImages._small;
      $header.toggleClass('has-bg-image', Boolean(backgroundImage));
      this.$headerBackground.css('background-image', backgroundImage ? 'url(' + backgroundImage + ')' : '');
    }

    setHeaderBackgroundStyles(config, $header) {
      const styles = config._backgroundStyles;
      if (!styles) return;
      this.$headerBackground.css({
        'background-repeat': styles._backgroundRepeat,
        'background-size': styles._backgroundSize,
        'background-position': styles._backgroundPosition
      });
    }

    setHeaderMinimumHeight(config, $header) {
      const minimumHeights = config._minimumHeights;
      if (!minimumHeights) return;
      const minimumHeight = minimumHeights[`_${Adapt$1.device.screenSize}`] ?? minimumHeights._small;
      $header.toggleClass('has-min-height', Boolean(minimumHeight)).css('min-height', minimumHeight ? minimumHeight + 'px' : '');
    }

  }

  BoxMenuView.template = 'boxMenu';
  var BoxMenuView$1 = __AMD("menu/adapt-contrib-boxMenu/js/BoxMenuView", BoxMenuView);

  Adapt$1.register('course menu', {
    view: BoxMenuView$1
  });
  Adapt$1.register('boxMenu', {
    view: BoxMenuView$1,
    model: MenuModel$1.extend({})
  });

  var ThemeView = Backbone.View.extend({
    className: function () {},
    initialize: function () {
      this.setStyles();
      this.listenTo(Adapt$1, {
        "device:changed": this.onDeviceResize,
        "remove": this.remove
      });
    },
    onDeviceResize: function () {
      this.setStyles();
    },
    remove: function () {
      Backbone.View.prototype.remove.call(this);
      this.onRemove();
    },
    setStyles: function () {
      this.setClasses();
      this.setBackgroundImage();
      this.setBackgroundStyles();
      this.setMinimumHeight();
      this.setCustomStyles();
    },
    setClasses: function () {
      this.$el.addClass(this.className());
    },
    setBackgroundImage: function () {
      var backgroundImages = this.model.get("_backgroundImage");
      if (!backgroundImages) return;
      var backgroundImage;

      switch (Adapt$1.device.screenSize) {
        case "large":
          backgroundImage = backgroundImages._large;
          break;

        case "medium":
          backgroundImage = backgroundImages._medium;
          break;

        default:
          backgroundImage = backgroundImages._small;
      }

      if (backgroundImage) {
        this.$el.addClass("has-bg-image").css("background-image", "url(" + backgroundImage + ")");
      } else {
        this.$el.removeClass("has-bg-image").css("background-image", "");
      }
    },
    setBackgroundStyles: function () {
      var styles = this.model.get("_backgroundStyles");
      if (!styles) return;
      this.$el.css({
        'background-repeat': styles._backgroundRepeat,
        'background-size': styles._backgroundSize,
        'background-position': styles._backgroundPosition
      });
    },
    setMinimumHeight: function () {
      var minimumHeights = this.model.get("_minimumHeights");
      if (!minimumHeights) return;
      var minimumHeight;

      switch (Adapt$1.device.screenSize) {
        case "large":
          minimumHeight = minimumHeights._large;
          break;

        case "medium":
          minimumHeight = minimumHeights._medium;
          break;

        default:
          minimumHeight = minimumHeights._small;
      }

      if (minimumHeight) {
        this.$el.addClass("has-min-height").css("min-height", minimumHeight + "px");
      } else {
        this.$el.removeClass("has-min-height").css("min-height", "");
      }
    },
    setCustomStyles: function () {},
    onRemove: function () {}
  });
  var ThemeView$1 = __AMD("theme/5ee351b2d140fe35be130b76/js/themeView", ThemeView);

  var ThemePageView = ThemeView$1.extend({
    className: function () {},
    setCustomStyles: function () {
      this.processHeader();
    },
    processHeader: function () {
      var header = this.model.get('_pageHeader');
      if (!header) return;
      var $header = this.$('.page__header');
      this.setHeaderBackgroundImage(header, $header);
      this.setHeaderBackgroundStyles(header, $header);
      this.setHeaderMinimumHeight(header, $header);
    },
    setHeaderBackgroundImage: function (config, $header) {
      var backgroundImages = config._backgroundImage;
      if (!backgroundImages) return;
      var backgroundImage;

      switch (Adapt$1.device.screenSize) {
        case "large":
          backgroundImage = backgroundImages._large;
          break;

        case "medium":
          backgroundImage = backgroundImages._medium;
          break;

        default:
          backgroundImage = backgroundImages._small;
      }

      if (backgroundImage) {
        $header.addClass("has-bg-image").css("background-image", "url(" + backgroundImage + ")");
      } else {
        $header.removeClass("has-bg-image").css("background-image", "");
      }
    },
    setHeaderBackgroundStyles: function (config, $header) {
      var styles = config._backgroundStyles;
      if (!styles) return;
      $header.css({
        'background-repeat': styles._backgroundRepeat,
        'background-size': styles._backgroundSize,
        'background-position': styles._backgroundPosition
      });
    },
    setHeaderMinimumHeight: function (config, $header) {
      var minimumHeights = config._minimumHeights;
      if (!minimumHeights) return;
      var minimumHeight;

      switch (Adapt$1.device.screenSize) {
        case "large":
          minimumHeight = minimumHeights._large;
          break;

        case "medium":
          minimumHeight = minimumHeights._medium;
          break;

        default:
          minimumHeight = minimumHeights._small;
      }

      if (minimumHeight) {
        $header.addClass("has-min-height").css("min-height", minimumHeight + "px");
      } else {
        $header.removeClass("has-min-height").css("min-height", "");
      }
    },
    onRemove: function () {}
  });
  var ThemePageView$1 = __AMD("theme/5ee351b2d140fe35be130b76/js/themePageView", ThemePageView);

  var ThemeArticleView = ThemeView$1.extend({
    className: function () {},
    setCustomStyles: function () {},
    onRemove: function () {}
  });
  var ThemeArticleView$1 = __AMD("theme/5ee351b2d140fe35be130b76/js/themeArticleView", ThemeArticleView);

  var ThemeBlockView = ThemeView$1.extend({
    className: function () {
      return this.model.get("_isDividerBlock") ? "is-divider-block" : "";
    },
    setCustomStyles: function () {},
    onRemove: function () {}
  });
  var ThemeBlockView$1 = __AMD("theme/5ee351b2d140fe35be130b76/js/themeBlockView", ThemeBlockView);

  function onDataReady() {
    $("html").addClass(Adapt$1.course.get("_courseStyle"));
  }

  function onPostRender(view) {
    var model = view.model;
    var theme = model.get("_odi-generic");
    if (!theme) return;

    switch (model.get("_type")) {
      case "page":
        new ThemePageView$1({
          model: new Backbone.Model(theme),
          el: view.$el
        });
        break;

      case "article":
        new ThemeArticleView$1({
          model: new Backbone.Model(theme),
          el: view.$el
        });
        break;

      case "block":
        new ThemeBlockView$1({
          model: new Backbone.Model(theme),
          el: view.$el
        });
        break;

      default:
        new ThemeView$1({
          model: new Backbone.Model(theme),
          el: view.$el
        });
    }
  }

  Adapt$1.on({
    "app:dataReady": onDataReady,
    "pageView:postRender articleView:postRender blockView:postRender": onPostRender
  });

  register("header", function Header(props) {
    const jsxHeading = React.useRef(null);
    const {
      _id,
      displayTitle,
      body,
      instruction,
      mobileInstruction,
      _type,
      _component,
      _disableAccessibilityState,
      _isA11yComponentDescriptionEnabled,
      classNamePrefixes = [_type && _type.toLowerCase(), _component && _component.toLowerCase()].filter(Boolean)
    } = props;
    const sizedInstruction = mobileInstruction && device$1.screenSize !== 'large' ? mobileInstruction : instruction;

    const _globals = Adapt$1.course.get('_globals');

    const ariaRegion = _globals?._components?.[`_${_component}`]?.ariaRegion;
    const isSet = displayTitle || body || sizedInstruction;

    if (!isSet && _isA11yComponentDescriptionEnabled && ariaRegion) {
      return React__default["default"].createElement("div", {
        className: "aria-label",
        dangerouslySetInnerHTML: {
          __html: compile(ariaRegion)
        }
      });
    }

    if (!isSet) return null;
    return React__default["default"].createElement("div", {
      id: `${_id}-header`,
      className: prefixClasses(classNamePrefixes, ['__header'])
    }, React__default["default"].createElement("div", {
      className: prefixClasses(classNamePrefixes, ['__header-inner'])
    }, displayTitle && React__default["default"].createElement("div", {
      className: prefixClasses(classNamePrefixes, ['__title'])
    }, !_disableAccessibilityState && React__default["default"].createElement("div", {
      className: "js-heading",
      ref: jsxHeading
    }), React__default["default"].createElement("div", {
      className: prefixClasses(classNamePrefixes, ['__title-inner']),
      "aria-hidden": !_disableAccessibilityState,
      dangerouslySetInnerHTML: {
        __html: compile(displayTitle, props)
      }
    })), _isA11yComponentDescriptionEnabled && ariaRegion && React__default["default"].createElement("div", {
      className: "aria-label",
      dangerouslySetInnerHTML: {
        __html: compile(ariaRegion, props)
      }
    }), body && React__default["default"].createElement("div", {
      className: prefixClasses(classNamePrefixes, ['__body'])
    }, React__default["default"].createElement("div", {
      className: prefixClasses(classNamePrefixes, ['__body-inner']),
      dangerouslySetInnerHTML: {
        __html: compile(body, props)
      }
    })), sizedInstruction && React__default["default"].createElement("div", {
      className: prefixClasses(classNamePrefixes, ['__instruction'])
    }, React__default["default"].createElement("div", {
      className: prefixClasses(classNamePrefixes, ['__instruction-inner']),
      dangerouslySetInnerHTML: {
        __html: compile(sizedInstruction, props)
      }
    }))));
  });

  register("image", function Image(props) {
    const hasMediumSetting = Object.prototype.hasOwnProperty.call(props, '_medium') || Object.prototype.hasOwnProperty.call(props, 'medium');
    const screenSize = hasMediumSetting ? device$1.screenSize : device$1.screenSize === 'large' ? 'large' : 'small';
    const src = props[`_${screenSize}`] || props[`${screenSize}`] || props._src || props.src;
    const hasSource = Boolean(src);
    if (!hasSource) return null;
    const attributionClassNamePrefixes = props.attributionClassNamePrefixes || props.classNamePrefixes;
    return React__default["default"].createElement("span", {
      id: props.id,
      className: classes([prefixClasses(props.classNamePrefixes, ['__image-container']), props.classes, props.attribution && 'has-attribution'])
    }, React__default["default"].createElement("img", {
      className: prefixClasses(props.classNamePrefixes, ['__image']),
      src: src,
      "aria-label": a11y$1.normalize(props.alt),
      "aria-hidden": !props.alt,
      loading: "eager",
      "aria-describedby": props.longdescription ? props.longDescriptionId : undefined
    }), props.attribution && React__default["default"].createElement("span", {
      className: prefixClasses(attributionClassNamePrefixes, ['__attribution'])
    }, React__default["default"].createElement("span", {
      className: prefixClasses(attributionClassNamePrefixes, ['__attribution-inner'])
    }, html(props.attribution))));
  });

  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  const LinkWrapper = _ref => {
    let {
      href,
      children,
      target,
      className,
      role
    } = _ref;
    return href ? React__default["default"].createElement("a", {
      href: href,
      target: target,
      className: className,
      role: role
    }, children) : children;
  };

  register("graphic", function Graphic(props) {
    const {
      _id,
      _isScrollable,
      _scrollPercent,
      _graphic,
      _globals
    } = props;
    const scrollableProperties = _isScrollable ? {
      role: 'slider',
      className: 'component__widget graphic__widget js-graphic-scrollbar',
      'aria-controls': `graphic__scroll__container__${_id}`,
      'aria-orientation': 'horizontal',
      'aria-valuemax': '100',
      'aria-valuemin': '0',
      'aria-valuenow': _scrollPercent,
      'aria-label': Handlebars.compile(_globals._components._graphic.scrollAriaLabel)(props),
      'aria-describedby': _graphic.longdescription ? `graphic__longdescription__${_id}` : undefined,
      tabIndex: '0'
    } : {};
    return React__default["default"].createElement("div", {
      className: "component__inner graphic__inner"
    }, React__default["default"].createElement(templates.header, props), React__default["default"].createElement("div", _extends({
      className: "component__widget graphic__widget"
    }, scrollableProperties), React__default["default"].createElement(LinkWrapper, {
      href: _graphic._url,
      target: _graphic._target,
      className: "graphic__link js-graphic-link",
      role: "link"
    }, React__default["default"].createElement(templates.image, _extends({}, _graphic, {
      "aria-hidden": _isScrollable,
      id: `graphic__scroll__container__${_id}`,
      longDescriptionId: `graphic__longdescription__${_id}`,
      classes: "js-graphic-scroll-container",
      classNamePrefixes: ['component', 'graphic']
    })), _graphic.longdescription && React__default["default"].createElement("div", {
      id: `graphic__longdescription__${_id}`,
      className: "graphic__longdescription"
    }, React__default["default"].createElement("div", {
      className: "graphic__longdescription-inner"
    }, _graphic.longdescription)))));
  });

  register("matching", function Matching(props) {
    const {
      _isEnabled,
      _isInteractionComplete,
      _isCorrect,
      _shouldShowMarking,
      _isCorrectAnswerShown,
      _items,
      _options,
      _globals
    } = props;
    const displayAsCorrect = _isInteractionComplete && (_isCorrectAnswerShown || _isCorrect);
    return React__default["default"].createElement("div", {
      className: "component__inner matching__inner"
    }, React__default["default"].createElement(templates.header, props), React__default["default"].createElement("div", {
      className: classes(['component__widget matching__widget', !_isEnabled && 'is-disabled', _isInteractionComplete && 'is-complete is-submitted show-user-answer', displayAsCorrect && 'is-correct'])
    }, _items.map((_ref, index) => {
      let {
        text,
        _index
      } = _ref;

      const activeOption = _options.find(option => option._itemIndex === _index && option._isActive);

      const displayItemAsCorrect = !_isEnabled && _shouldShowMarking && (_isCorrectAnswerShown || activeOption?._shouldBeSelected);
      return React__default["default"].createElement("div", {
        key: _index,
        className: classes(['matching-item', 'item', `item-${index}`, 'js-matching-item', _shouldShowMarking && (displayItemAsCorrect ? 'is-correct' : 'is-incorrect')])
      }, text && React__default["default"].createElement("div", {
        className: "matching-item__title"
      }, React__default["default"].createElement("div", {
        className: "matching-item__title_inner",
        dangerouslySetInnerHTML: {
          __html: text
        }
      })), React__default["default"].createElement("div", {
        className: "matching-item__select-container js-matching-item-select-container"
      }, React__default["default"].createElement(templates.matchingDropDown, _extends({}, props, {
        _itemIndex: _index
      })), React__default["default"].createElement("div", {
        className: "matching-item__select-state"
      }, React__default["default"].createElement("div", {
        className: "matching-item__select-icon matching-item__select-correct-icon",
        "aria-label": _globals._accessibility._ariaLabels.correct
      }, React__default["default"].createElement("div", {
        className: "icon"
      })), React__default["default"].createElement("div", {
        className: "matching-item__select-icon matching-item__select-incorrect-icon",
        "aria-label": _globals._accessibility._ariaLabels.incorrect
      }, React__default["default"].createElement("div", {
        className: "icon"
      })))));
    })), React__default["default"].createElement("div", {
      className: "btn__container"
    }));
  });

  register("matchingDropDown", function MatchingDropDown(props) {
    const button = React.useRef(null);
    const list = React.useRef(null);
    const [wasOpen, setWasOpen] = React.useState(false);
    const [isOpen, setIsOpen] = React.useState(false);
    const [isShown, setIsShown] = React.useState(false);
    const [blurTimeoutHandle, setBlurTimeoutHandle] = React.useState(null);
    const [isListOffScreen, setIsListOffScreen] = React.useState(false);
    const [listHeight, setListHeight] = React.useState(null);
    const [buttonWidth, setButtonWidth] = React.useState(null);
    const [buttonOffsetLeft, setButtonOffsetLeft] = React.useState(null);

    const onStartInteraction = () => setWasOpen(isOpen);

    const onButtonClick = () => {
      if (wasOpen || isOpen) {
        setIsOpen(false);
        return;
      }

      if (blurTimeoutHandle) {
        clearTimeout(blurTimeoutHandle);
        setBlurTimeoutHandle(null);
      }

      setIsShown(false);
      setIsOpen(true);
      setTimeout(() => {
        const offset = list?.current.getBoundingClientRect();
        const height = $(list?.current).height();
        const windowHeight = $(window).height();
        setIsListOffScreen(offset.top + height > windowHeight);
        setListHeight(height);
        setButtonOffsetLeft(button?.current.offsetLeft);
        setButtonWidth($(button?.current).outerWidth());
        setIsShown(true);
        list?.current.focus();
        scrollToHighlightedListItem();
      }, 100);
    };

    const scrollToHighlightedListItem = () => {
      if (!list?.current) return;
      const highlighted = $('li[aria-selected]', list.current)[0];
      if (!highlighted) return;
      const height = list.current.clientHeight;
      const pos = highlighted.offsetTop - height / 2;
      list.current.scrollTop = pos;
    };

    const onOptionClicked = event => {
      const li = $(event.target).closest('li');
      const optionIndex = $(li).val();
      const option = options.find(option => option._index === optionIndex);
      chooseOption(option);
    };

    const chooseOption = option => {
      setActiveOption(option._index);
      button?.current.focus();
    };

    const onListBlur = () => {
      if (!isOpen) return;

      const handleBlur = () => {
        setIsShown(false);
        setIsOpen(false);
      };

      setBlurTimeoutHandle(setTimeout(handleBlur, 100));
    };

    const onDocumentClick = event => {
      if (!isOpen) return;
      const parents = [document.activeElement, ...$(document.activeElement).parents().toArray()];
      if (parents.includes(list?.current)) return;
      onListBlur();
    };

    const KEYCODE = {
      UP: 38,
      DOWN: 40,
      ENTER: 13,
      SPACE: 32,
      ESCAPE: 27
    };
    const validKeyCodes = Object.values(KEYCODE);

    const onDocumentKeyDown = event => {
      if (!isOpen || !validKeyCodes.includes(event.keyCode)) return;

      switch (event.keyCode) {
        case KEYCODE.UP:
          {
            event.preventDefault();
            const option = getPreviousOption() || getLastOption();
            highlightOption(option);
            break;
          }

        case KEYCODE.DOWN:
          {
            event.preventDefault();
            const option = getNextOption() || getFirstOption();
            highlightOption(option);
            break;
          }

        case KEYCODE.ENTER:
        case KEYCODE.SPACE:
          event.preventDefault();
          chooseOption(highlightedOption);
          break;

        case KEYCODE.ESCAPE:
          event.preventDefault();
          button?.current.focus();
      }
    };

    const getCurrentOptionIndex = () => options.findIndex(option => option === highlightedOption);

    const getPreviousOption = () => options[getCurrentOptionIndex() - 1];

    const getLastOption = () => options[options.length - 1];

    const getNextOption = () => options[getCurrentOptionIndex() + 1];

    const getFirstOption = () => options[0];

    const highlightOption = option => {
      setHighlightedOption(option._index);
      scrollToHighlightedListItem();
    };

    React.useEffect(() => {
      document.addEventListener('click', onDocumentClick, {
        capture: true
      });
      document.addEventListener('keydown', onDocumentKeyDown);
      return () => {
        document.removeEventListener('click', onDocumentClick, {
          capture: true
        });
        document.removeEventListener('keydown', onDocumentKeyDown);
      };
    }, [onDocumentKeyDown, onDocumentClick]);
    const {
      _id,
      _isEnabled,
      placeholder,
      _itemIndex,
      _options,
      _isCorrectAnswerShown,
      setActiveOption,
      setHighlightedOption
    } = props;

    const options = _options.filter(_ref => {
      let {
        _itemIndex: itemIndex
      } = _ref;
      return itemIndex === _itemIndex || itemIndex === -1;
    });

    const activeOption = options.find(option => option._itemIndex === _itemIndex && option._isActive) || {
      text: placeholder
    };
    const highlightedOption = options.find(option => option._itemIndex === _itemIndex && option._isHighlighted) || {
      text: placeholder
    };
    const correctActiveOption = activeOption?._shouldBeSelected ? activeOption : options.find(option => option._shouldBeSelected);
    const displayActiveOption = _isCorrectAnswerShown ? correctActiveOption : activeOption;
    return React__default["default"].createElement("div", {
      className: "dropdown",
      disabled: !_isEnabled
    }, React__default["default"].createElement("button", {
      disabled: !_isEnabled,
      className: classes(['dropdown__btn js-dropdown-btn', !_isEnabled && 'is-disabled']),
      "aria-haspopup": "listbox",
      "aria-expanded": isOpen,
      onMouseDown: onStartInteraction,
      onTouchStart: onStartInteraction,
      onClick: onButtonClick,
      ref: button
    }, React__default["default"].createElement("span", {
      className: "dropdown__inner js-dropdown-inner",
      dangerouslySetInnerHTML: {
        __html: displayActiveOption?.text
      }
    }), React__default["default"].createElement("span", {
      className: "dropdown__icon"
    }, React__default["default"].createElement("span", {
      className: "icon"
    }))), React__default["default"].createElement("ul", {
      className: classes(['dropdown__list js-dropdown-list', !isOpen && 'u-display-none', isOpen && !isShown && 'u-visibility-hidden']),
      style: {
        top: !isShown || !isListOffScreen ? '' : -listHeight,
        left: buttonOffsetLeft,
        width: buttonWidth
      },
      role: "listbox",
      tabIndex: "-1",
      onBlur: onListBlur,
      ref: list,
      disabled: !_isEnabled,
      "aria-activedescendant": highlightedOption && `dropdown__item__${_id}__${_itemIndex}__${highlightedOption._index}`
    }, options.map(_ref2 => {
      let {
        displayText,
        text,
        _index,
        _isHighlighted
      } = _ref2;
      return React__default["default"].createElement("li", {
        key: _index,
        id: `dropdown__item__${_id}__${_itemIndex}__${_index}`,
        className: "dropdown-item js-dropdown-list-item",
        role: "option",
        text: text,
        value: _index,
        "aria-selected": _isHighlighted || null,
        selected: _isHighlighted || null,
        onClick: onOptionClicked
      }, React__default["default"].createElement("div", {
        className: "dropdown-item__inner js-dropdown-list-item-inner",
        dangerouslySetInnerHTML: {
          __html: displayText || text
        }
      }));
    })));
  });

  register("mcq", function Mcq(props) {
    const ariaLabels = Adapt$1.course.get('_globals')._accessibility._ariaLabels;

    const {
      _id,
      _isEnabled,
      _isInteractionComplete,
      _isCorrect,
      _isCorrectAnswerShown,
      _shouldShowMarking,
      _isRadio,
      displayTitle,
      body,
      instruction,
      ariaQuestion,
      onKeyPress,
      onItemSelect,
      onItemFocus,
      onItemBlur
    } = props;
    return React__default["default"].createElement("div", {
      className: "component__inner mcq__inner"
    }, React__default["default"].createElement(templates.header, props), React__default["default"].createElement("div", {
      className: classes(['component__widget', 'mcq__widget', !_isEnabled && 'is-disabled', _isInteractionComplete && 'is-complete is-submitted show-user-answer', _isCorrect && 'is-correct']),
      role: _isRadio ? 'radiogroup' : 'group',
      "aria-labelledby": ariaQuestion ? null : (displayTitle || body || instruction) && `${_id}-header`,
      "aria-label": ariaQuestion || null
    }, props._items.map((_ref, index) => {
      let {
        text,
        _index,
        _isActive,
        _shouldBeSelected,
        _isHighlighted
      } = _ref;
      return React__default["default"].createElement("div", {
        className: classes([`mcq-item item-${index}`, _shouldShowMarking && _shouldBeSelected && 'is-correct', _shouldShowMarking && !_shouldBeSelected && 'is-incorrect']),
        key: _index
      }, React__default["default"].createElement("input", {
        className: "mcq-item__input",
        id: `${_id}-${index}-input`,
        name: _isRadio ? `${_id}-item` : null,
        type: _isRadio ? 'radio' : 'checkbox',
        disabled: !_isEnabled,
        defaultChecked: _isActive,
        "aria-label": !_shouldShowMarking ? a11y$1.normalize(text) : `${_shouldBeSelected ? ariaLabels.correct : ariaLabels.incorrect}, ${_isActive ? ariaLabels.selectedAnswer : ariaLabels.unselectedAnswer}. ${a11y$1.normalize(text)}`,
        "data-adapt-index": _index,
        onKeyPress: onKeyPress,
        onChange: onItemSelect,
        onFocus: onItemFocus,
        onBlur: onItemBlur
      }), React__default["default"].createElement("label", {
        className: classes(['mcq-item__label', !_isEnabled && 'is-disabled', _isHighlighted && 'is-highlighted', (_isCorrectAnswerShown ? _shouldBeSelected : _isActive) && 'is-selected']),
        "aria-hidden": true,
        htmlFor: `${_id}-${index}-input`,
        "data-adapt-index": _index
      }, React__default["default"].createElement("span", {
        className: "mcq-item__state"
      }, React__default["default"].createElement("span", {
        className: classes(['mcq-item__icon', 'mcq-item__answer-icon', _isRadio ? 'is-radio' : 'is-checkbox'])
      }, React__default["default"].createElement("span", {
        className: "icon"
      })), React__default["default"].createElement("span", {
        className: "mcq-item__icon mcq-item__correct-icon"
      }, React__default["default"].createElement("span", {
        className: "icon"
      })), React__default["default"].createElement("span", {
        className: "mcq-item__icon mcq-item__incorrect-icon"
      }, React__default["default"].createElement("span", {
        className: "icon"
      }))), React__default["default"].createElement("span", {
        className: "mcq-item__text"
      }, React__default["default"].createElement("span", {
        className: "mcq-item__text-inner",
        dangerouslySetInnerHTML: {
          __html: compile(text)
        }
      }))));
    })), React__default["default"].createElement("div", {
      className: "btn__container"
    }));
  });

  register("text", function Text(props) {
    return React__default["default"].createElement("div", {
      className: "component__inner text__inner"
    }, React__default["default"].createElement(templates.header, props));
  });

  register("gmcq", function Gmcq(props) {
    const ariaLabels = Adapt$1.course.get('_globals')._accessibility._ariaLabels;

    const {
      _id,
      _isEnabled,
      _isInteractionComplete,
      _isCorrect,
      _isCorrectAnswerShown,
      _canShowMarking,
      _isRadio,
      _columns,
      displayTitle,
      body,
      instruction,
      onKeyPress,
      onItemSelect,
      onItemFocus,
      onItemBlur,
      isInteractive
    } = props;
    const screenSize = Adapt$1.device.screenSize;
    const shouldShowMarking = !isInteractive() && _canShowMarking;
    return React__default["default"].createElement("div", {
      className: "component__inner gmcq__inner"
    }, React__default["default"].createElement(templates.header, props), React__default["default"].createElement("div", {
      className: classes(['component__widget', 'gmcq__widget', !_isEnabled && 'is-disabled', _isInteractionComplete && 'is-complete is-submitted show-user-answer', _isCorrect && 'is-correct', _columns && screenSize === 'large' && 'has-column-layout']),
      role: _isRadio ? 'radiogroup' : 'group',
      "aria-labelledby": (displayTitle || body || instruction) && `${_id}-header`
    }, props._items.map((_ref, index) => {
      let {
        text,
        _index,
        _isActive,
        _shouldBeSelected,
        _graphic
      } = _ref;
      return React__default["default"].createElement("div", {
        className: classes([`gmcq__item item-${index}`, shouldShowMarking && _shouldBeSelected ? 'is-correct' : null, shouldShowMarking && !_shouldBeSelected ? 'is-incorrect' : null]),
        style: _columns && screenSize === 'large' ? {
          width: `${100 / _columns}%`
        } : null,
        key: _index
      }, React__default["default"].createElement("input", {
        className: "gmcq__item-input",
        id: `${_id}-${index}-input`,
        name: _isRadio ? `${_id}-item` : null,
        type: _isRadio ? 'radio' : 'checkbox',
        disabled: !_isEnabled,
        "aria-label": !shouldShowMarking ? `${Adapt$1.a11y.normalize(text)} ${_graphic?.alt || ''}` : `${_shouldBeSelected ? ariaLabels.correct : ariaLabels.incorrect}, ${_isActive ? ariaLabels.selectedAnswer : ariaLabels.unselectedAnswer}. ${Adapt$1.a11y.normalize(text)} ${_graphic?.alt || ''}`,
        "data-adapt-index": _index,
        onKeyPress: onKeyPress,
        onChange: onItemSelect,
        onFocus: onItemFocus,
        onBlur: onItemBlur
      }), React__default["default"].createElement("label", {
        className: classes(['gmcq__item-label', 'js-item-label', !_isEnabled && 'is-disabled', (_isCorrectAnswerShown ? _shouldBeSelected : _isActive) && 'is-selected']),
        "aria-hidden": true,
        htmlFor: `${_id}-${index}-input`,
        "data-adapt-index": _index
      }, React__default["default"].createElement(templates.image, _extends({}, _graphic, {
        classNamePrefixes: ['gmcq__item'],
        attributionClassNamePrefixes: ['component', 'gmcq']
      })), React__default["default"].createElement("div", {
        className: "gmcq__item-option"
      }, React__default["default"].createElement("div", {
        className: "gmcq__item-state"
      }, React__default["default"].createElement("div", {
        className: classes(['gmcq__item-icon', 'gmcq__item-answer-icon', _isRadio ? 'is-radio' : 'is-checkbox'])
      }, React__default["default"].createElement("div", {
        className: "icon"
      })), React__default["default"].createElement("div", {
        className: "gmcq__item-icon gmcq__item-correct-icon"
      }, React__default["default"].createElement("div", {
        className: "icon"
      })), React__default["default"].createElement("div", {
        className: "gmcq__item-icon gmcq__item-incorrect-icon"
      }, React__default["default"].createElement("div", {
        className: "icon"
      }))), text && React__default["default"].createElement("div", {
        className: "gmcq__item-text"
      }, React__default["default"].createElement("div", {
        className: "gmcq__item-text-inner"
      }, html(compile(text)))))));
    })), React__default["default"].createElement("div", {
      className: "btn__container"
    }));
  });

  $('body').append(Handlebars.templates.loading());
  data$1.on('ready', () => {
    logging$1.debug('Calling Adapt.init');
    Adapt$1.init();
    Adapt$1.off('adaptCollection:dataLoaded courseModel:dataLoaded');
  }).init();

}));
// Allow ES export default to be exported as amd modules
window.__AMD = function(id, value) {
  window.define(id, function() { return value; }); // define for external use
  window.require([id]); // force module to load
  return value; // return for export
};
//# sourceMappingURL=adapt.min.js.map
